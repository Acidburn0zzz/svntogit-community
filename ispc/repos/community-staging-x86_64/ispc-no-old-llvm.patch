diff --git a/CMakeLists.txt b/CMakeLists.txt
index 980bff42..23b8a353 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -165,11 +165,7 @@ set (ISPC_TARGETS
         generic-1 generic-4 generic-8 generic-16 generic-32 generic-64)
 
 set(CLANG_LIBRARY_LIST clangFrontend clangDriver clangSerialization clangParse clangSema clangAnalysis clangAST clangBasic clangEdit clangLex)
-set(LLVM_COMPONENTS engine ipo bitreader bitwriter instrumentation linker)
-# Component "option" was introduced in 3.3 and starting with 3.4 it is required for the link step.
-if (${LLVM_VERSION_NUMBER} VERSION_GREATER "3.3.0")
-    set(LLVM_COMPONENTS ${LLVM_COMPONENTS} option)
-endif()
+set(LLVM_COMPONENTS engine ipo bitreader bitwriter instrumentation linker option)
 
 list(APPEND LLVM_COMPONENTS x86)
 if (ARM_ENABLED)
@@ -297,14 +293,12 @@ else()
     set_source_files_properties(${BISON_OUTPUT} PROPERTIES COMPILE_FLAGS "/wd4005 /wd4065")
 endif()
 
-if (${LLVM_VERSION_NUMBER} VERSION_GREATER "3.4.0")
-    target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_11)
-    if (UNIX)
-        set_target_properties(${PROJECT_NAME} PROPERTIES CXX_EXTENSIONS OFF)
-        target_compile_options(${PROJECT_NAME} PRIVATE -Wno-c99-extensions -Wno-deprecated-register -fno-rtti)
-        if (ISPC_USE_ASAN)
-            target_compile_options(${PROJECT_NAME} PRIVATE -fsanitize=address)
-        endif()
+target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_11)
+if (UNIX)
+    set_target_properties(${PROJECT_NAME} PROPERTIES CXX_EXTENSIONS OFF)
+    target_compile_options(${PROJECT_NAME} PRIVATE -Wno-c99-extensions -Wno-deprecated-register -fno-rtti)
+    if (ISPC_USE_ASAN)
+        target_compile_options(${PROJECT_NAME} PRIVATE -fsanitize=address)
     endif()
 endif()
 
@@ -344,16 +338,12 @@ if (WIN32)
     target_link_libraries(${PROJECT_NAME} version.lib shlwapi.lib odbc32.lib odbccp32.lib)
 else()
     target_link_libraries(${PROJECT_NAME} pthread dl)
-    if (${LLVM_VERSION_NUMBER} VERSION_GREATER "3.4.0")
-        target_link_libraries(${PROJECT_NAME} z)
-    endif()
+    target_link_libraries(${PROJECT_NAME} z)
     if (APPLE)
         target_link_libraries(${PROJECT_NAME} curses)
     else()
         target_link_libraries(${PROJECT_NAME} tinfo)
-        if (${LLVM_VERSION_NUMBER} VERSION_GREATER "3.3.0")
-            target_link_libraries(${PROJECT_NAME} curses)
-        endif()
+        target_link_libraries(${PROJECT_NAME} curses)
     endif()
 endif()
 
diff --git a/cmake/LLVMConfig.cmake b/cmake/LLVMConfig.cmake
index 32958cad..f26cb8ba 100644
--- a/cmake/LLVMConfig.cmake
+++ b/cmake/LLVMConfig.cmake
@@ -123,20 +123,11 @@ if (NOT CMAKE_BUILD_TYPE STREQUAL "DEBUG" )
 endif()
 
 run_llvm_config(LLVM_VERSION_NUMBER "--version")
+message(STATUS "Detected LLVM version: ${LLVM_VERSION_NUMBER}")
 
 function(get_llvm_libfiles resultList)
     run_llvm_config(LLVM_LIBS "--libfiles" ${ARGN})
     str_to_list("${LLVM_LIBS}" tmpList)
-    # bug in llvm-config on Windows from LLVM 3.8 and older
-    if (${LLVM_VERSION_NUMBER} VERSION_LESS "3.9.0")
-        if (WIN32)
-            foreach(llvm_lib ${tmpList})
-                string(REGEX REPLACE "lib(LLVM[-.a-zA-Z0-9]+)\.a$" "\\1\.lib" llvm_lib "${llvm_lib}")
-                list(APPEND FIXED_LLVM_LIBRARY_LIST ${llvm_lib})
-            endforeach()
-            set(tmpList ${FIXED_LLVM_LIBRARY_LIST})
-        endif()
-    endif()
     set(${resultList} ${tmpList} PARENT_SCOPE)
 endfunction()
 
@@ -144,4 +135,4 @@ function(get_llvm_cppflags resultList)
     run_llvm_config(CPP_FLAGS "--cppflags")
     str_to_list("${CPP_FLAGS}" tmpList)
     set(${resultList} ${tmpList} PARENT_SCOPE)
-endfunction()
\ No newline at end of file
+endfunction()
diff --git a/builtins/dispatch.ll b/builtins/dispatch.ll
index 6042f164..ad96bc8a 100644
--- a/builtins/dispatch.ll
+++ b/builtins/dispatch.ll
@@ -140,33 +140,8 @@
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
-;; LLVM has different IR for different versions since 3.7
-
 define(`PTR_OP_ARGS',
-  ifelse(LLVM_VERSION, LLVM_3_7,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_3_8,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_3_9,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_4_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_5_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_6_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_7_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_7_1,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_8_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_9_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_10_0,
-    ``$1 , $1 *'',
-    ``$1 *''
-  )
+  `$1 , $1 *'
 )
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
diff --git a/builtins/target-avx512knl-i32x16.ll b/builtins/target-avx512knl-i32x16.ll
index d9ba2c81..b119bd3a 100644
--- a/builtins/target-avx512knl-i32x16.ll
+++ b/builtins/target-avx512knl-i32x16.ll
@@ -31,29 +31,7 @@
 
 define(`WIDTH',`16')
 
-ifelse(LLVM_VERSION, LLVM_3_7,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_3_8,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_3_9,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_4_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_5_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_6_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_7_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_7_1,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_8_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_9_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_10_0,
-    `include(`target-avx512-common.ll')'
-  )
+include(`target-avx512-common.ll')
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; rcp, rsqrt
@@ -82,28 +60,6 @@ define <16 x float> @__rsqrt_fast_varying_float(<16 x float> %v) nounwind readon
 }
 ')
 
-ifelse(LLVM_VERSION, LLVM_3_7,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_3_8,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_3_9,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_4_0,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_5_0,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_6_0,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_7_0,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_7_1,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_8_0,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_9_0,
-    rcp_rsqrt_varying_float_knl(),
-         LLVM_VERSION, LLVM_10_0,
-    rcp_rsqrt_varying_float_knl()
-  )
+rcp_rsqrt_varying_float_knl()
 
 ;;saturation_arithmetic_novec()
diff --git a/builtins/target-avx512skx-i32x16.ll b/builtins/target-avx512skx-i32x16.ll
index 77114c11..be0f03c0 100644
--- a/builtins/target-avx512skx-i32x16.ll
+++ b/builtins/target-avx512skx-i32x16.ll
@@ -31,28 +31,7 @@
 
 define(`WIDTH',`16')
 
-
-ifelse(LLVM_VERSION, LLVM_3_8,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_3_9,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_4_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_5_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_6_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_7_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_7_1,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_8_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_9_0,
-    `include(`target-avx512-common.ll')',
-         LLVM_VERSION, LLVM_10_0,
-    `include(`target-avx512-common.ll')'
-  )
+include(`target-avx512-common.ll')
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; rcp, rsqrt
@@ -101,26 +80,6 @@ define <16 x float> @__rsqrt_fast_varying_float(<16 x float> %v) nounwind readon
 }
 ')
 
-ifelse(LLVM_VERSION, LLVM_3_8,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_3_9,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_4_0,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_5_0,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_6_0,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_7_0,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_7_1,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_8_0,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_9_0,
-    rcp_rsqrt_varying_float_skx(),
-         LLVM_VERSION, LLVM_10_0,
-    rcp_rsqrt_varying_float_skx()
-  )
+rcp_rsqrt_varying_float_skx()
 
 ;;saturation_arithmetic_novec()
diff --git a/builtins/util.m4 b/builtins/util.m4
index 772b63e0..ded34e74 100644
--- a/builtins/util.m4
+++ b/builtins/util.m4
@@ -49,85 +49,16 @@ define(`MASK_HIGH_BIT_ON',
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
-;; LLVM has different IR for different versions since 3.7
-
 define(`PTR_OP_ARGS',
-  ifelse(LLVM_VERSION, LLVM_3_7,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_3_8,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_3_9,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_4_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_5_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_6_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_7_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_7_1,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_8_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_9_0,
-    ``$1 , $1 *'',
-         LLVM_VERSION, LLVM_10_0,
-    ``$1 , $1 *'',
-    ``$1 *''
-  )
+    `$1 , $1 *'
 )
 
-;; x86 mask load/stores have different mask type since 3.8
-
 define(`MdORi64',
-  ifelse(LLVM_VERSION, LLVM_3_8,
-    ``i64'',
-    LLVM_VERSION, LLVM_3_9,
-    ``i64'',
-    LLVM_VERSION, LLVM_4_0,
-    ``i64'',
-    LLVM_VERSION, LLVM_5_0,
-    ``i64'',
-    LLVM_VERSION, LLVM_6_0,
-    ``i64'',
-    LLVM_VERSION, LLVM_7_0,
-    ``i64'',
-    LLVM_VERSION, LLVM_7_1,
-    ``i64'',
-    LLVM_VERSION, LLVM_8_0,
-    ``i64'',
-    LLVM_VERSION, LLVM_9_0,
-    ``i64'',
-    LLVM_VERSION, LLVM_10_0,
-    ``i64'',
-    ``double''
-  )
+  ``i64''
 )
 
 define(`MfORi32',
-  ifelse(LLVM_VERSION, LLVM_3_8,
-    ``i32'',
-    LLVM_VERSION, LLVM_3_9,
-    ``i32'',
-    LLVM_VERSION, LLVM_4_0,
-    ``i32'',
-    LLVM_VERSION, LLVM_5_0,
-    ``i32'',
-    LLVM_VERSION, LLVM_6_0,
-    ``i32'',
-    LLVM_VERSION, LLVM_7_0,
-    ``i32'',
-    LLVM_VERSION, LLVM_7_1,
-    ``i32'',
-    LLVM_VERSION, LLVM_8_0,
-    ``i32'',
-    LLVM_VERSION, LLVM_9_0,
-    ``i32'',
-    LLVM_VERSION, LLVM_10_0,
-    ``i32'',
-    ``float''
-  )
+  ``i32''
 )
 
 
@@ -1617,103 +1548,19 @@ define <$1 x $2> @__atomic_compare_exchange_$3_global($2* %ptr, <$1 x $2> %cmp,
   per_lane($1, <$1 x MASK> %mask, `
    %cmp_LANE_ID = extractelement <$1 x $2> %cmp, i32 LANE
    %val_LANE_ID = extractelement <$1 x $2> %val, i32 LANE
-
-  ;; 3.5 - trunk code is the same since m4 has no OR and AND operators
-  ifelse(LLVM_VERSION,LLVM_3_5,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_3_6,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_3_7,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_3_8,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_3_9,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_4_0,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_5_0,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_6_0,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_7_0,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_7_1,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_8_0,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_9_0,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',LLVM_VERSION,LLVM_10_0,`
-    %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
-    %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
-  ',`
-    %r_LANE_ID = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst
-  ')
+   %r_LANE_ID_t = cmpxchg $2 * %ptr, $2 %cmp_LANE_ID, $2 %val_LANE_ID seq_cst seq_cst
+   %r_LANE_ID = extractvalue { $2, i1 } %r_LANE_ID_t, 0
    %rp_LANE_ID = getelementptr PTR_OP_ARGS(`$2') %rptr32, i32 LANE
    store $2 %r_LANE_ID, $2 * %rp_LANE_ID')
-
-  %r = load PTR_OP_ARGS(`<$1 x $2> ')  %rptr
-  ret <$1 x $2> %r
+   %r = load PTR_OP_ARGS(`<$1 x $2> ')  %rptr
+   ret <$1 x $2> %r
 }
 
 define $2 @__atomic_compare_exchange_uniform_$3_global($2* %ptr, $2 %cmp,
                                                        $2 %val) nounwind alwaysinline {                                                           
-  ;; 3.5 - trunk code is the same since m4 has no OR and AND operators
-  ifelse(LLVM_VERSION,LLVM_3_5,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_3_6,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_3_7,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_3_8,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_3_9,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_4_0,`
    %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
    %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_5_0,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_6_0,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_7_0,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_7_1,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_8_0,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_9_0,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',LLVM_VERSION,LLVM_10_0,`
-   %r_t = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst seq_cst
-   %r = extractvalue { $2, i1 } %r_t, 0
-  ',`
-   %r = cmpxchg $2 * %ptr, $2 %cmp, $2 %val seq_cst
-  ')
-  ret $2 %r
+   ret $2 %r
 }
 ')
 
diff --git a/src/builtins.cpp b/src/builtins.cpp
index 924c2d7a..3f035e94 100644
--- a/src/builtins.cpp
+++ b/src/builtins.cpp
@@ -47,15 +47,9 @@
 
 #include <math.h>
 #include <stdlib.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/Attributes.h>
-#include <llvm/DerivedTypes.h>
-#include <llvm/Instructions.h>
-#include <llvm/Intrinsics.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Module.h>
-#include <llvm/Type.h>
-#else
+
+#include <llvm/ADT/Triple.h>
+#include <llvm/Bitcode/BitcodeReader.h>
 #include <llvm/IR/Attributes.h>
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/Instructions.h>
@@ -63,20 +57,9 @@
 #include <llvm/IR/LLVMContext.h>
 #include <llvm/IR/Module.h>
 #include <llvm/IR/Type.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
 #include <llvm/Linker/Linker.h>
-#else
-#include <llvm/Linker.h>
-#endif
-#include <llvm/ADT/Triple.h>
 #include <llvm/Support/MemoryBuffer.h>
 #include <llvm/Target/TargetMachine.h>
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-#include <llvm/Bitcode/ReaderWriter.h>
-#else
-#include <llvm/Bitcode/BitcodeReader.h>
-#endif
 
 extern int yyparse();
 struct yy_buffer_state;
@@ -265,11 +248,7 @@ static void lAddModuleSymbols(llvm::Module *module, SymbolTable *symbolTable) {
 
     llvm::Module::iterator iter;
     for (iter = module->begin(); iter != module->end(); ++iter) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        llvm::Function *func = iter;
-#else /* LLVM 3.8+ */
         llvm::Function *func = &*iter;
-#endif
         lCreateISPCSymbol(func, symbolTable);
     }
 }
@@ -283,11 +262,7 @@ static void lAddModuleSymbols(llvm::Module *module, SymbolTable *symbolTable) {
 static void lCheckModuleIntrinsics(llvm::Module *module) {
     llvm::Module::iterator iter;
     for (iter = module->begin(); iter != module->end(); ++iter) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        llvm::Function *func = iter;
-#else /* LLVM 3.8+ */
         llvm::Function *func = &*iter;
-#endif
         if (!func->isIntrinsic())
             continue;
 
@@ -829,37 +804,13 @@ static void lSetInternalFunctions(llvm::Module *module) {
 void AddBitcodeToModule(const unsigned char *bitcode, int length, llvm::Module *module, SymbolTable *symbolTable,
                         bool warn) {
     llvm::StringRef sb = llvm::StringRef((char *)bitcode, length);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    llvm::MemoryBuffer *bcBuf = llvm::MemoryBuffer::getMemBuffer(sb);
-#else // LLVM 3.6+
     llvm::MemoryBufferRef bcBuf = llvm::MemoryBuffer::getMemBuffer(sb)->getMemBufferRef();
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_4_0 // LLVM 4.0+
     llvm::Expected<std::unique_ptr<llvm::Module>> ModuleOrErr = llvm::parseBitcodeFile(bcBuf, *g->ctx);
     if (!ModuleOrErr) {
         Error(SourcePos(), "Error parsing stdlib bitcode: %s", toString(ModuleOrErr.takeError()).c_str());
     } else {
         llvm::Module *bcModule = ModuleOrErr.get().release();
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
-    llvm::ErrorOr<std::unique_ptr<llvm::Module>> ModuleOrErr = llvm::parseBitcodeFile(bcBuf, *g->ctx);
-    if (std::error_code EC = ModuleOrErr.getError())
-        Error(SourcePos(), "Error parsing stdlib bitcode: %s", EC.message().c_str());
-    else {
-        llvm::Module *bcModule = ModuleOrErr.get().release();
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_5 || ISPC_LLVM_VERSION == ISPC_LLVM_3_6
-    llvm::ErrorOr<llvm::Module *> ModuleOrErr = llvm::parseBitcodeFile(bcBuf, *g->ctx);
-    if (std::error_code EC = ModuleOrErr.getError())
-        Error(SourcePos(), "Error parsing stdlib bitcode: %s", EC.message().c_str());
-    else {
-        llvm::Module *bcModule = ModuleOrErr.get();
-#else // LLVM 3.2 - 3.4
-    std::string bcErr;
-    llvm::Module *bcModule = llvm::ParseBitcodeFile(bcBuf, *g->ctx, &bcErr);
-    if (!bcModule)
-        Error(SourcePos(), "Error parsing stdlib bitcode: %s", bcErr.c_str());
-    else {
-#endif
         // FIXME: this feels like a bad idea, but the issue is that when we
         // set the llvm::Module's target triple in the ispc Module::Module
         // constructor, we start by calling llvm::sys::getHostTriple() (and
@@ -906,7 +857,6 @@ void AddBitcodeToModule(const unsigned char *bitcode, int length, llvm::Module *
                 // architecture and investigate what happened.
                 // Generally we allow library DataLayout to be subset of module
                 // DataLayout or library DataLayout to be empty.
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
                 if (!VerifyDataLayoutCompatibility(module->getDataLayoutStr(), bcModule->getDataLayoutStr()) && warn) {
                     Warning(SourcePos(),
                             "Module DataLayout is incompatible with "
@@ -915,33 +865,15 @@ void AddBitcodeToModule(const unsigned char *bitcode, int length, llvm::Module *
                             "Library DL: %s\n",
                             module->getDataLayoutStr().c_str(), bcModule->getDataLayoutStr().c_str());
                 }
-#else
-                if (!VerifyDataLayoutCompatibility(module->getDataLayout(), bcModule->getDataLayout()) && warn) {
-                    Warning(SourcePos(),
-                            "Module DataLayout is incompatible with "
-                            "library DataLayout:\n"
-                            "Module  DL: %s\n"
-                            "Library DL: %s\n",
-                            module->getDataLayout().c_str(), bcModule->getDataLayout().c_str());
-                }
-#endif
             }
 #endif
                 bcModule->setTargetTriple(mTriple.str());
         bcModule->setDataLayout(module->getDataLayout());
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // 3.2-3.5
-        std::string(linkError);
-
-        if (llvm::Linker::LinkModules(module, bcModule, llvm::Linker::DestroySource, &linkError))
-            Error(SourcePos(), "Error linking stdlib bitcode: %s", linkError.c_str());
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 // 3.6-3.7
-        llvm::Linker::LinkModules(module, bcModule);
-#else                                    // LLVM 3.8+
-                                         // A hack to move over declaration, which have no definition.
-                                         // New linker is kind of smart and think it knows better what to do, so
-                                         // it removes unused declarations without definitions.
-                                         // This trick should be legal, as both modules use the same LLVMContext.
+        // A hack to move over declaration, which have no definition.
+        // New linker is kind of smart and think it knows better what to do, so
+        // it removes unused declarations without definitions.
+        // This trick should be legal, as both modules use the same LLVMContext.
         for (llvm::Function &f : *bcModule) {
             if (f.isDeclaration()) {
                 // Declarations with uses will be moved by Linker.
@@ -955,7 +887,6 @@ void AddBitcodeToModule(const unsigned char *bitcode, int length, llvm::Module *
         if (llvm::Linker::linkModules(*module, std::move(M))) {
             Error(SourcePos(), "Error linking stdlib bitcode.");
         }
-#endif
 
         lSetInternalFunctions(module);
         if (symbolTable != NULL)
@@ -973,58 +904,27 @@ static void lDefineConstantInt(const char *name, int val, llvm::Module *module,
     sym->constValue = new ConstExpr(sym->type, val, SourcePos());
     llvm::Type *ltype = LLVMTypes::Int32Type;
     llvm::Constant *linit = LLVMInt32(val);
-#if ISPC_LLVM_VERSION < ISPC_LLVM_3_6
-    // Use WeakODRLinkage rather than InternalLinkage so that a definition
-    // survives even if it's not used in the module, so that the symbol is
-    // there in the debugger.
-    llvm::GlobalValue::LinkageTypes linkage =
-        g->generateDebuggingSymbols ? llvm::GlobalValue::WeakODRLinkage : llvm::GlobalValue::InternalLinkage;
-    sym->storagePtr = new llvm::GlobalVariable(*module, ltype, true, linkage, linit, name);
-#else // LLVM 3.6+
     auto GV = new llvm::GlobalVariable(*module, ltype, true, llvm::GlobalValue::InternalLinkage, linit, name);
     dbg_sym.push_back(GV);
     sym->storagePtr = GV;
-#endif
     symbolTable->AddVariable(sym);
 
     if (m->diBuilder != NULL) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::DIFile file;
-        llvm::DIType diType = sym->type->GetDIType(file);
-        Assert(diType.Verify());
-#else // LLVM 3.7+
         llvm::DIFile *file = m->diCompileUnit->getFile();
         llvm::DICompileUnit *cu = m->diCompileUnit;
         llvm::DIType *diType = sym->type->GetDIType(file);
-#endif
         // FIXME? DWARF says that this (and programIndex below) should
         // have the DW_AT_artifical attribute.  It's not clear if this
         // matters for anything though.
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::DIGlobalVariable var =
-            m->diBuilder->createGlobalVariable(name, file, 0 /* line */, diType, true /* static */, sym->storagePtr);
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_6                                       // LLVM 3.6
-        llvm::Constant *sym_const_storagePtr = llvm::dyn_cast<llvm::Constant>(sym->storagePtr);
-        Assert(sym_const_storagePtr);
-        llvm::DIGlobalVariable var = m->diBuilder->createGlobalVariable(file, name, name, file, 0 /* line */, diType,
-                                                                        true /* static */, sym_const_storagePtr);
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // LLVM 3.7 - 3.9
-        llvm::Constant *sym_const_storagePtr = llvm::dyn_cast<llvm::Constant>(sym->storagePtr);
-        Assert(sym_const_storagePtr);
-        m->diBuilder->createGlobalVariable(cu, name, name, file, 0 /* line */, diType, true /* static */,
-                                           sym_const_storagePtr);
-#else                                                                          // LLVM 4.0+
         llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storagePtr);
         llvm::DIGlobalVariableExpression *var =
             m->diBuilder->createGlobalVariableExpression(cu, name, name, file, 0 /* line */, diType, true /* static */);
         sym_GV_storagePtr->addDebugInfo(var);
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        Assert(var.Verify());
-#else // LLVM 3.7+
-      // coming soon
-#endif
+        /*#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
+                Assert(var.Verify());
+        #else // LLVM 3.7+
+              // coming soon
+        #endif*/
     }
 }
 
@@ -1037,11 +937,7 @@ static void lDefineConstantIntFunc(const char *name, int val, llvm::Module *modu
     llvm::Function *func = module->getFunction(name);
     dbg_sym.push_back(func);
     Assert(func != NULL); // it should be declared already...
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-    func->addFnAttr(llvm::Attributes::AlwaysInline);
-#else // LLVM 3.3+
     func->addFnAttr(llvm::Attribute::AlwaysInline);
-#endif
     llvm::BasicBlock *bblock = llvm::BasicBlock::Create(*g->ctx, "entry", func, 0);
     llvm::ReturnInst::Create(*g->ctx, LLVMInt32(val), bblock);
 
@@ -1060,58 +956,29 @@ static void lDefineProgramIndex(llvm::Module *module, SymbolTable *symbolTable,
 
     llvm::Type *ltype = LLVMTypes::Int32VectorType;
     llvm::Constant *linit = LLVMInt32Vector(pi);
-#if ISPC_LLVM_VERSION < ISPC_LLVM_3_6
-    // See comment in lDefineConstantInt() for why WeakODRLinkage is used here
-    llvm::GlobalValue::LinkageTypes linkage =
-        g->generateDebuggingSymbols ? llvm::GlobalValue::WeakODRLinkage : llvm::GlobalValue::InternalLinkage;
-    sym->storagePtr = new llvm::GlobalVariable(*module, ltype, true, linkage, linit, sym->name.c_str());
-#else // LLVM 3.6+
+
     auto GV =
         new llvm::GlobalVariable(*module, ltype, true, llvm::GlobalValue::InternalLinkage, linit, sym->name.c_str());
     dbg_sym.push_back(GV);
     sym->storagePtr = GV;
-#endif
     symbolTable->AddVariable(sym);
 
     if (m->diBuilder != NULL) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::DIFile file;
-        llvm::DIType diType = sym->type->GetDIType(file);
-        Assert(diType.Verify());
-#else // LLVM 3.7+
         llvm::DIFile *file = m->diCompileUnit->getFile();
         llvm::DICompileUnit *cu = m->diCompileUnit;
         llvm::DIType *diType = sym->type->GetDIType(file);
-#endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_6 // LLVM 3.6
-        llvm::Constant *sym_const_storagePtr = llvm::dyn_cast<llvm::Constant>(sym->storagePtr);
-        Assert(sym_const_storagePtr);
-        llvm::DIGlobalVariable var =
-            m->diBuilder->createGlobalVariable(file, sym->name.c_str(), sym->name.c_str(), file, 0 /* line */, diType,
-                                               false /* static */, sym_const_storagePtr);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::DIGlobalVariable var = m->diBuilder->createGlobalVariable(sym->name.c_str(), file, 0 /* line */, diType,
-                                                                        false /* static */, sym->storagePtr);
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // LLVM 3.7 - 3.9
-        llvm::Constant *sym_const_storagePtr = llvm::dyn_cast<llvm::Constant>(sym->storagePtr);
-        Assert(sym_const_storagePtr);
-        m->diBuilder->createGlobalVariable(cu, sym->name.c_str(), sym->name.c_str(), file, 0 /* line */, diType,
-                                           false /* static */, sym_const_storagePtr);
-#else                                                                          // LLVM 4.0+
         llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storagePtr);
         llvm::DIGlobalVariableExpression *var = m->diBuilder->createGlobalVariableExpression(
             cu, sym->name.c_str(), sym->name.c_str(), file, 0 /* line */, diType, false /* static */);
         sym_GV_storagePtr->addDebugInfo(var);
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        Assert(var.Verify());
-#else // LLVM 3.7+
-      // coming soon
-#endif
+        /*#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
+                Assert(var.Verify());
+        #else // LLVM 3.7+
+              // coming soon
+        #endif*/
     }
 }
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
 static void emitLLVMUsed(llvm::Module &module, std::vector<llvm::Constant *> &list) {
     // Convert list to what ConstantArray needs.
     llvm::SmallVector<llvm::Constant *, 8> UsedArray;
@@ -1128,7 +995,6 @@ static void emitLLVMUsed(llvm::Module &module, std::vector<llvm::Constant *> &li
 
     GV->setSection("llvm.metadata");
 }
-#endif
 
 void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module *module, bool includeStdlibISPC) {
     // debug_symbols are symbols that supposed to be preserved in debug information.
@@ -1434,7 +1300,6 @@ void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module
             }
             break;
         }
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
         case Target::KNL_AVX512: {
             switch (g->target->getVectorWidth()) {
             case 16:
@@ -1449,8 +1314,6 @@ void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module
             }
             break;
         }
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
         case Target::SKX_AVX512: {
             switch (g->target->getVectorWidth()) {
             case 8:
@@ -1472,7 +1335,6 @@ void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module
             }
             break;
         }
-#endif
         case Target::GENERIC: {
             switch (g->target->getVectorWidth()) {
             case 4:
@@ -1712,7 +1574,6 @@ void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module
             }
             break;
         }
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
         case Target::KNL_AVX512: {
             switch (g->target->getVectorWidth()) {
             case 16:
@@ -1727,8 +1588,6 @@ void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module
             }
             break;
         }
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
         case Target::SKX_AVX512: {
             switch (g->target->getVectorWidth()) {
             case 8:
@@ -1750,7 +1609,6 @@ void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module
             }
             break;
         }
-#endif
         case Target::GENERIC: {
             switch (g->target->getVectorWidth()) {
             case 4:
@@ -1849,11 +1707,9 @@ void DefineStdlib(SymbolTable *symbolTable, llvm::LLVMContext *ctx, llvm::Module
     }
 
     // LLVM 3.6 is only because it was not tested with earlier versions.
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
     if (g->generateDebuggingSymbols) {
         emitLLVMUsed(*module, debug_symbols);
     }
-#endif
 
     if (includeStdlibISPC) {
         // If the user wants the standard library to be included, parse the
diff --git a/src/cbackend.cpp b/src/cbackend.cpp
index 0b4709a6..7f8bf904 100644
--- a/src/cbackend.cpp
+++ b/src/cbackend.cpp
@@ -32,70 +32,38 @@
 
 #include "llvmutil.h"
 
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include "llvm/CallingConv.h"
-#include "llvm/Constants.h"
-#include "llvm/DerivedTypes.h"
-#include "llvm/InlineAsm.h"
-#include "llvm/Instructions.h"
-#include "llvm/IntrinsicInst.h"
-#include "llvm/Intrinsics.h"
-#include "llvm/Module.h"
-#else // LLVM 3.3+
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallString.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ValueTracking.h"
+#include "llvm/CodeGen/IntrinsicLowering.h"
+#include "llvm/CodeGen/Passes.h"
+#include "llvm/IR/CFG.h"
+#include "llvm/IR/CallSite.h"
 #include "llvm/IR/CallingConv.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/GetElementPtrTypeIterator.h"
 #include "llvm/IR/InlineAsm.h"
+#include "llvm/IR/InstIterator.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
-#include "llvm/IR/Module.h"
-#endif
-#include "llvm/Pass.h"
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 // <= 3.6
-#include "llvm/PassManager.h"
-#else // LLVM 3.7+
 #include "llvm/IR/LegacyPassManager.h"
-#endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include "llvm/TypeFinder.h"
-#else // LLVM_3_3+
+#include "llvm/IR/Module.h"
 #include "llvm/IR/TypeFinder.h"
-#endif
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/SmallString.h"
-#include "llvm/ADT/StringExtras.h"
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.2, 3.3, 3.4
-#include "llvm/Support/InstIterator.h"
-#else // 3.5+
-#include "llvm/IR/InstIterator.h"
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-#include "llvm/Analysis/FindUsedTypes.h"
-#endif
-#include "llvm/Analysis/LoopInfo.h"
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
-#include "llvm/IR/CFG.h"
-#include "llvm/IR/CallSite.h"
-#include "llvm/IR/GetElementPtrTypeIterator.h"
 #include "llvm/IR/Verifier.h"
+#include "llvm/Pass.h"
 #include "llvm/Support/FileSystem.h"
 #include <llvm/IR/IRPrintingPasses.h>
-#else
-#include "llvm/Analysis/Verifier.h"
-#include "llvm/Support/CFG.h"
-#include "llvm/Support/CallSite.h"
-#include "llvm/Support/GetElementPtrTypeIterator.h"
-#include <llvm/Assembly/PrintModulePass.h>
-#endif
-#include "llvm/Analysis/ValueTracking.h"
-#include "llvm/CodeGen/IntrinsicLowering.h"
-#include "llvm/CodeGen/Passes.h"
 //#include "llvm/Target/Mangler.h"
 #include "llvm/Transforms/Scalar.h"
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_7_0
 #include "llvm/Transforms/Utils.h"
 #endif
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/InstVisitor.h"
 #include "llvm/MC/MCAsmInfo.h"
 #include "llvm/MC/MCContext.h"
 #include "llvm/MC/MCInstrInfo.h"
@@ -103,29 +71,13 @@
 #include "llvm/MC/MCRegisterInfo.h"
 #include "llvm/MC/MCSubtargetInfo.h"
 #include "llvm/MC/MCSymbol.h"
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2 // 3.2
-#include "llvm/DataLayout.h"
-#else // LLVM 3.3+
-#include "llvm/IR/DataLayout.h"
-#endif
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/FormattedStream.h"
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2 // 3.2
-#include "llvm/Support/InstVisitor.h"
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.3, 3.4
-#include "llvm/InstVisitor.h"
-#else // LLVM 3.5+
-#include "llvm/IR/InstVisitor.h"
-#endif
 #include "llvm/Support/Host.h"
 #include "llvm/Support/MathExtras.h"
 #include "llvm/Support/TargetRegistry.h"
 #include "llvm/Target/TargetMachine.h"
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.2, 3.3, 3.4
-#include "llvm/Config/config.h"
-#endif
-
 #include <llvm/Support/ToolOutputFile.h>
 #include <llvm/Transforms/IPO.h>
 #include <llvm/Transforms/Utils/BasicBlockUtils.h>
@@ -203,9 +155,7 @@ class TypeFinder {
     // To avoid walking constant expressions multiple times and other IR
     // objects, we keep several helper maps.
     llvm::DenseSet<const llvm::Value *> VisitedConstants;
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
     llvm::DenseSet<const llvm::Metadata *> VisitedMDNodes;
-#endif
     llvm::DenseSet<llvm::Type *> VisitedTypes;
     std::vector<llvm::ArrayType *> &ArrayTypes;
     std::vector<llvm::IntegerType *> &IntegerTypes;
@@ -280,11 +230,7 @@ class TypeFinder {
 
         for (llvm::Module::const_named_metadata_iterator I = M.named_metadata_begin(), E = M.named_metadata_end();
              I != E; ++I) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-            const llvm::NamedMDNode *NMD = I;
-#else /* LLVM 3.8+ */
             const llvm::NamedMDNode *NMD = &*I;
-#endif
             for (unsigned i = 0, e = NMD->getNumOperands(); i != e; ++i)
                 incorporateMDNode(NMD->getOperand(i));
         }
@@ -309,17 +255,10 @@ class TypeFinder {
     /// walked in other ways.  GlobalValues, basic blocks, instructions, and
     /// inst operands are all explicitly enumerated.
     void incorporateValue(const llvm::Value *V) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // 3.2, 3.3, 3.4, 3.5
-        if (const llvm::MDNode *M = llvm::dyn_cast<llvm::MDNode>(V)) {
-            incorporateMDNode(M);
-            return;
-        }
-#else /* LLVN 3.6+ */
         if (const llvm::MetadataAsValue *MV = llvm::dyn_cast<llvm::MetadataAsValue>(V)) {
             incorporateMDNode(MV->getMetadata());
             return;
         }
-#endif
         if (!llvm::isa<llvm::Constant>(V) || llvm::isa<llvm::GlobalValue>(V))
             return;
 
@@ -336,19 +275,6 @@ class TypeFinder {
             incorporateValue(*I);
     }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // 3.2, 3.3, 3.4, 3.5
-    void incorporateMDNode(const llvm::MDNode *V) {
-
-        // Already visited?
-        if (!VisitedConstants.insert(V).second)
-            return;
-
-        // Look in operands for types.
-        for (unsigned i = 0, e = V->getNumOperands(); i != e; ++i)
-            if (llvm::Value *Op = V->getOperand(i))
-                incorporateValue(Op);
-    }
-#else // LLVM 3.6+
     void incorporateMDNode(const llvm::Metadata *M) {
 
         // Already visited?
@@ -369,7 +295,6 @@ class TypeFinder {
             llvm_unreachable("Unknown Metadata subclass");
         }
     }
-#endif
 };
 } // end anonymous namespace
 
@@ -390,13 +315,7 @@ static bool is_vec16_i64_ty(llvm::Type *Ty) {
 namespace {
 class CBEMCAsmInfo : public llvm::MCAsmInfo {
   public:
-    CBEMCAsmInfo() {
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.2, 3.3, 3.4
-        GlobalPrefix = "";
-#endif
-        PrivateGlobalPrefix = "";
-    }
+    CBEMCAsmInfo() { PrivateGlobalPrefix = ""; }
 };
 
 /// CWriter - This class is the main chunk of code that converts an LLVM
@@ -441,27 +360,15 @@ class CWriter : public llvm::FunctionPass, public llvm::InstVisitor<CWriter> {
         : FunctionPass(ID), Out(o), IL(0), /* Mang(0), */ LI(0), TheModule(0), TAsm(0), MRI(0), MOFI(0), TCtx(0), TD(0),
           OpaqueCounter(0), NextAnonValueNumber(0), includeName(incname ? incname : "generic_defs.h"),
           vectorWidth(vecwidth) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 // <= 3.6
-        initializeLoopInfoPass(*llvm::PassRegistry::getPassRegistry());
-#else // LLVM 3.7+
         initializeLoopInfoWrapperPassPass(*llvm::PassRegistry::getPassRegistry());
-#endif
         FPCounter = 0;
         VectorConstantIndex = 0;
     }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // <= 3.9
-    virtual const char *getPassName() const { return "C backend"; }
-#else // LLVM 4.0+
     virtual llvm::StringRef getPassName() const { return "C backend"; }
-#endif
 
     void getAnalysisUsage(llvm::AnalysisUsage &AU) const {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 // <= 3.6
-        AU.addRequired<llvm::LoopInfo>();
-#else // LLVM 3.7+
         AU.addRequired<llvm::LoopInfoWrapperPass>();
-#endif
         AU.setPreservesAll();
     }
 
@@ -473,11 +380,7 @@ class CWriter : public llvm::FunctionPass, public llvm::InstVisitor<CWriter> {
         if (F.hasAvailableExternallyLinkage())
             return false;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 // <= 3.6
-        LI = &getAnalysis<llvm::LoopInfo>();
-#else // LLVM 3.7+
         LI = &getAnalysis<llvm::LoopInfoWrapperPass>().getLoopInfo();
-#endif
 
         // Get rid of intrinsics we can't handle.
         lowerIntrinsics(F);
@@ -513,25 +416,11 @@ class CWriter : public llvm::FunctionPass, public llvm::InstVisitor<CWriter> {
 
     llvm::raw_ostream &printType(llvm::raw_ostream &Out, llvm::Type *Ty, bool isSigned = false,
                                  const std::string &VariableName = "", bool IgnoreName = false,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                                 const llvm::AttrListPtr &PAL = llvm::AttrListPtr()
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                                 const llvm::AttributeSet &PAL = llvm::AttributeSet()
-#else // LLVM 5.0+
-                                 const llvm::AttributeList &PAL = llvm::AttributeList()
-#endif
-    );
+                                 const llvm::AttributeList &PAL = llvm::AttributeList());
     llvm::raw_ostream &printSimpleType(llvm::raw_ostream &Out, llvm::Type *Ty, bool isSigned,
                                        const std::string &NameSoFar = "");
 
-    void printStructReturnPointerFunctionType(llvm::raw_ostream &Out,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                                              const llvm::AttrListPtr &PAL,
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                                              const llvm::AttributeSet &PAL,
-#else // LLVM 5.0+
-                                              const llvm::AttributeList &PAL,
-#endif
+    void printStructReturnPointerFunctionType(llvm::raw_ostream &Out, const llvm::AttributeList &PAL,
                                               llvm::PointerType *Ty);
 
     std::string getStructName(llvm::StructType *ST);
@@ -606,11 +495,9 @@ class CWriter : public llvm::FunctionPass, public llvm::InstVisitor<CWriter> {
         if (llvm::isa<llvm::CmpInst>(I) && llvm::isa<llvm::VectorType>(I.getType()) == false)
             return true;
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // 3.5+
         // This instruction returns a struct on LLVM older than 3.4, and can not be inlined
         if (llvm::isa<llvm::AtomicCmpXchgInst>(I))
             return false;
-#endif
 
         // Must be an expression, must be used exactly once.  If it is dead, we
         // emit it inline where it would go.
@@ -630,11 +517,7 @@ class CWriter : public llvm::FunctionPass, public llvm::InstVisitor<CWriter> {
         // Must not be used in inline asm, extractelement, or shufflevector.
         if (I.hasOneUse()) {
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // 3.5+
             const llvm::Instruction &User = llvm::cast<llvm::Instruction>(*I.user_back());
-#else
-            const llvm::Instruction &User = llvm::cast<llvm::Instruction>(*I.use_back());
-#endif
             if (isInlineAsm(User) || llvm::isa<llvm::ExtractElementInst>(User) ||
                 llvm::isa<llvm::ShuffleVectorInst>(User) || llvm::isa<llvm::AtomicRMWInst>(User) ||
                 llvm::isa<llvm::AtomicCmpXchgInst>(User))
@@ -642,11 +525,7 @@ class CWriter : public llvm::FunctionPass, public llvm::InstVisitor<CWriter> {
         }
 
         // Only inline instruction it if it's use is in the same BB as the inst.
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // 3.5+
         return I.getParent() == llvm::cast<llvm::Instruction>(I.user_back())->getParent();
-#else
-        return I.getParent() == llvm::cast<llvm::Instruction>(I.use_back())->getParent();
-#endif
     }
 
     // isDirectAlloca - Define fixed sized allocas in the entry block as direct
@@ -763,14 +642,7 @@ std::string CWriter::getArrayName(llvm::ArrayType *AT) { return "l_array_" + llv
 /// printStructReturnPointerFunctionType - This is like printType for a struct
 /// return type, except, instead of printing the type as void (*)(Struct*, ...)
 /// print it as "Struct (*)(...)", for struct return functions.
-void CWriter::printStructReturnPointerFunctionType(llvm::raw_ostream &Out,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                                                   const llvm::AttrListPtr &PAL,
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                                                   const llvm::AttributeSet &PAL,
-#else // LLVM 5.0+
-                                                   const llvm::AttributeList &PAL,
-#endif
+void CWriter::printStructReturnPointerFunctionType(llvm::raw_ostream &Out, const llvm::AttributeList &PAL,
                                                    llvm::PointerType *TheTy) {
     llvm::FunctionType *FTy = llvm::cast<llvm::FunctionType>(TheTy->getElementType());
     std::string tstr;
@@ -785,25 +657,11 @@ void CWriter::printStructReturnPointerFunctionType(llvm::raw_ostream &Out,
         if (PrintedType)
             FunctionInnards << ", ";
         llvm::Type *ArgTy = *I;
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-        if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::ByVal)) {
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        if (PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::ByVal)) {
-#else // LLVM 5.0+
         if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::ByVal)) {
-#endif
             assert(ArgTy->isPointerTy());
             ArgTy = llvm::cast<llvm::PointerType>(ArgTy)->getElementType();
         }
-        printType(FunctionInnards, ArgTy,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                  PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::SExt),
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                  PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::SExt),
-#else // LLVM 5.0+
-                  PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt),
-#endif
-                  "");
+        printType(FunctionInnards, ArgTy, PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt), "");
         PrintedType = true;
     }
     if (FTy->isVarArg()) {
@@ -814,15 +672,7 @@ void CWriter::printStructReturnPointerFunctionType(llvm::raw_ostream &Out,
         FunctionInnards << "void";
     }
     FunctionInnards << ')';
-    printType(Out, RetTy,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-              PAL.getParamAttributes(0).hasAttribute(llvm::Attributes::SExt),
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-              PAL.getParamAttributes(0).hasAttribute(llvm::AttributeSet::ReturnIndex, llvm::Attribute::SExt),
-#else // LLVM 5.0+
-              PAL.getParamAttributes(0).hasAttribute(llvm::Attribute::SExt),
-#endif
-              FunctionInnards.str());
+    printType(Out, RetTy, PAL.getParamAttributes(0).hasAttribute(llvm::Attribute::SExt), FunctionInnards.str());
 }
 
 llvm::raw_ostream &CWriter::printSimpleType(llvm::raw_ostream &Out, llvm::Type *Ty, bool isSigned,
@@ -916,15 +766,7 @@ llvm::raw_ostream &CWriter::printSimpleType(llvm::raw_ostream &Out, llvm::Type *
 // declaration.
 //
 llvm::raw_ostream &CWriter::printType(llvm::raw_ostream &Out, llvm::Type *Ty, bool isSigned,
-                                      const std::string &NameSoFar, bool IgnoreName,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                                      const llvm::AttrListPtr &PAL
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                                      const llvm::AttributeSet &PAL
-#else // LLVM 5.0+
-                                      const llvm::AttributeList &PAL
-#endif
-) {
+                                      const std::string &NameSoFar, bool IgnoreName, const llvm::AttributeList &PAL) {
 
     if (Ty->isFloatingPointTy() || Ty->isX86_MMXTy() || Ty->isIntegerTy() || Ty->isVectorTy() || Ty->isVoidTy()) {
         printSimpleType(Out, Ty, isSigned, NameSoFar);
@@ -940,28 +782,13 @@ llvm::raw_ostream &CWriter::printType(llvm::raw_ostream &Out, llvm::Type *Ty, bo
         unsigned Idx = 1;
         for (llvm::FunctionType::param_iterator I = FTy->param_begin(), E = FTy->param_end(); I != E; ++I) {
             llvm::Type *ArgTy = *I;
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-            if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::ByVal)) {
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-            if (PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::ByVal)) {
-#else // LLVM 5.0+
             if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::ByVal)) {
-#endif
                 assert(ArgTy->isPointerTy());
                 ArgTy = llvm::cast<llvm::PointerType>(ArgTy)->getElementType();
             }
             if (I != FTy->param_begin())
                 FunctionInnards << ", ";
-            printType(FunctionInnards, ArgTy,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                      PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::SExt),
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                      PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex,
-                                                               llvm::Attribute::SExt),
-#else // LLVM 5.0+
-                      PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt),
-#endif
-                      "");
+            printType(FunctionInnards, ArgTy, PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt), "");
             ++Idx;
         }
         if (FTy->isVarArg()) {
@@ -972,14 +799,7 @@ llvm::raw_ostream &CWriter::printType(llvm::raw_ostream &Out, llvm::Type *Ty, bo
             FunctionInnards << "void";
         }
         FunctionInnards << ')';
-        printType(Out, FTy->getReturnType(),
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                  PAL.getParamAttributes(0).hasAttribute(llvm::Attributes::SExt),
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                  PAL.getParamAttributes(0).hasAttribute(llvm::AttributeSet::ReturnIndex, llvm::Attribute::SExt),
-#else // LLVM 5.0+
-                  PAL.getParamAttributes(0).hasAttribute(llvm::Attribute::SExt),
-#endif
+        printType(Out, FTy->getReturnType(), PAL.getParamAttributes(0).hasAttribute(llvm::Attribute::SExt),
                   FunctionInnards.str());
         return Out;
     }
@@ -1194,15 +1014,6 @@ void CWriter::printConstantDataSequential(llvm::ConstantDataSequential *CDS, boo
 
 static inline std::string ftostr(const llvm::APFloat &V) {
     std::string Buf;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    if (&V.getSemantics() == &llvm::APFloat::IEEEdouble) {
-        llvm::raw_string_ostream(Buf) << V.convertToDouble();
-        return Buf;
-    } else if (&V.getSemantics() == &llvm::APFloat::IEEEsingle) {
-        llvm::raw_string_ostream(Buf) << (double)V.convertToFloat();
-        return Buf;
-    }
-#else // LLVM 4.0+
     if (&V.getSemantics() == &llvm::APFloat::IEEEdouble()) {
         llvm::raw_string_ostream(Buf) << V.convertToDouble();
         return Buf;
@@ -1210,7 +1021,6 @@ static inline std::string ftostr(const llvm::APFloat &V) {
         llvm::raw_string_ostream(Buf) << (double)V.convertToFloat();
         return Buf;
     }
-#endif
     return "<unknown format in ftostr>"; // error
 }
 
@@ -1230,11 +1040,7 @@ static bool isFPCSafeToPrint(const llvm::ConstantFP *CFP) {
         return false;
     llvm::APFloat APF = llvm::APFloat(CFP->getValueAPF()); // copy
     if (CFP->getType() == llvm::Type::getFloatTy(CFP->getContext()))
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // <= 3.9
-        APF.convert(llvm::APFloat::IEEEdouble, llvm::APFloat::rmNearestTiesToEven, &ignored);
-#else // LLVM 4.0+
         APF.convert(llvm::APFloat::IEEEdouble(), llvm::APFloat::rmNearestTiesToEven, &ignored);
-#endif
 #if HAVE_PRINTF_A && ENABLE_CBE_PRINTF_A
     char Buffer[100];
     snprintf(Buffer, sizeof(Buffer), "%a", APF.convertToDouble());
@@ -1750,11 +1556,7 @@ void CWriter::printConstant(llvm::Constant *CPV, bool Static) {
                 // useful.
                 llvm::APFloat Tmp = FPC->getValueAPF();
                 bool LosesInfo;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // <= 3.9
-                Tmp.convert(llvm::APFloat::IEEEdouble, llvm::APFloat::rmTowardZero, &LosesInfo);
-#else // LLVM 4.0+
                 Tmp.convert(llvm::APFloat::IEEEdouble(), llvm::APFloat::rmTowardZero, &LosesInfo);
-#endif
                 V = Tmp.convertToDouble();
             }
 
@@ -2066,11 +1868,7 @@ std::string CWriter::GetValueName(const llvm::Value *Operand) {
 
     // Resolve potential alias.
     if (const llvm::GlobalAlias *GA = llvm::dyn_cast<llvm::GlobalAlias>(Operand)) {
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 /* LLVM 3.5+ */
         if (const llvm::Value *V = GA->getAliasee())
-#else /* <= LLVM 3.4 */
-        if (const llvm::Value *V = GA->resolveAliasedGlobal(false))
-#endif
             Operand = V;
     }
 
@@ -2437,13 +2235,8 @@ static SpecialGlobalClass getGlobalVariableClass(const llvm::GlobalVariable *GV)
 
     // Otherwise, if it is other metadata, don't print it.  This catches things
     // like debug information.
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_8 /* LLVM 3.5-3.8 */
-    // Here we compare char *
-    if (!strcmp(GV->getSection(), "llvm.metadata"))
-#else
     // Here we compare strings
     if (GV->getSection() == "llvm.metadata")
-#endif
         return NotPrinted;
 
     return NotSpecial;
@@ -2499,22 +2292,14 @@ bool CWriter::doInitialization(llvm::Module &M) {
 #endif
     TAsm = new CBEMCAsmInfo();
     MRI = new llvm::MCRegisterInfo();
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4 // LLVM 3.4+
     TCtx = new llvm::MCContext(TAsm, MRI, NULL);
-#else
-    TCtx = new llvm::MCContext(*TAsm, *MRI, NULL);
-#endif
     // Mang = new llvm::Mangler(*TCtx, *TD);
 
     // Keep track of which functions are static ctors/dtors so they can have
     // an attribute added to their prototypes.
     std::set<llvm::Function *> StaticCtors, StaticDtors;
     for (llvm::Module::global_iterator I = M.global_begin(), E = M.global_end(); I != E; ++I) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        switch (getGlobalVariableClass(I)) {
-#else /* LLVM 3.8+ */
         switch (getGlobalVariableClass(&*I)) {
-#endif
         default:
             break;
         case GlobalCtors:
@@ -2624,11 +2409,7 @@ bool CWriter::doInitialization(llvm::Module &M) {
 
             if (I->hasExternalLinkage() || I->hasExternalWeakLinkage() || I->hasCommonLinkage())
                 Out << "extern ";
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
             else if (I->hasDLLImportStorageClass())
-#else
-            else if (I->hasDLLImportLinkage())
-#endif
                 Out << "__declspec(dllimport) ";
             else
                 continue; // Internal Global
@@ -2696,11 +2477,7 @@ bool CWriter::doInitialization(llvm::Module &M) {
             case llvm::Intrinsic::uadd_with_overflow:
             case llvm::Intrinsic::sadd_with_overflow:
             case llvm::Intrinsic::umul_with_overflow:
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-                intrinsicsToDefine.push_back(I);
-#else /* LLVM 3.8+ */
                 intrinsicsToDefine.push_back(&*I);
-#endif
                 break;
             }
             continue;
@@ -2722,24 +2499,14 @@ bool CWriter::doInitialization(llvm::Module &M) {
 
         if (I->hasExternalWeakLinkage())
             Out << "extern ";
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        printFunctionSignature(I, true);
-#else /* LLVM 3.8+ */
         printFunctionSignature(&*I, true);
-#endif
         if (I->hasWeakLinkage() || I->hasLinkOnceLinkage())
             Out << " __ATTRIBUTE_WEAK__";
         if (I->hasExternalWeakLinkage())
             Out << " __EXTERNAL_WEAK__";
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        if (StaticCtors.count(I))
-            Out << " __ATTRIBUTE_CTOR__";
-        if (StaticDtors.count(I))
-#else /* LLVM 3.8+ */
         if (StaticCtors.count(&*I))
             Out << " __ATTRIBUTE_CTOR__";
         if (StaticDtors.count(&*I))
-#endif
             Out << " __ATTRIBUTE_DTOR__";
         if (I->hasHiddenVisibility())
             Out << " __HIDDEN__";
@@ -2801,36 +2568,20 @@ bool CWriter::doInitialization(llvm::Module &M) {
         for (llvm::Module::global_iterator I = M.global_begin(), E = M.global_end(); I != E; ++I)
             if (!I->isDeclaration()) {
                 // Ignore special globals, such as debug info.
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-                if (getGlobalVariableClass(I))
-#else /* LLVM 3.8+ */
                 if (getGlobalVariableClass(&*I))
-#endif
                     continue;
 
                 if (I->hasLocalLinkage())
                     Out << "static ";
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
                 else if (I->hasDLLImportStorageClass())
                     Out << "__declspec(dllimport) ";
                 else if (I->hasDLLExportStorageClass())
                     Out << "__declspec(dllexport) ";
-#else
-                else if (I->hasDLLImportLinkage())
-                    Out << "__declspec(dllimport) ";
-                else if (I->hasDLLExportLinkage())
-                    Out << "__declspec(dllexport) ";
-#endif
                 // Thread Local Storage
                 if (I->isThreadLocal())
                     Out << "__thread ";
 
-                printType(Out, I->getType()->getElementType(), false,
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-                          GetValueName(I));
-#else /* LLVM 3.8+ */
-                          GetValueName(&*I));
-#endif
+                printType(Out, I->getType()->getElementType(), false, GetValueName(&*I));
 
                 if (I->hasLinkOnceLinkage())
                     Out << " __attribute__((common))";
@@ -3157,26 +2908,16 @@ void CWriter::printContainedStructs(llvm::Type *Ty, llvm::SmallPtrSet<llvm::Type
 
     if (llvm::StructType *ST = llvm::dyn_cast<llvm::StructType>(Ty)) {
         // Check to see if we have already printed this struct.
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
         if (!Printed.insert(Ty).second)
             return;
-#else
-        if (!Printed.insert(Ty))
-            return;
-#endif
 
         // Print structure type out.
         printType(Out, ST, false, getStructName(ST), true);
         Out << ";\n\n";
     }
     if (llvm::ArrayType *AT = llvm::dyn_cast<llvm::ArrayType>(Ty)) {
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
         if (!Printed.insert(Ty).second)
             return;
-#else
-        if (!Printed.insert(Ty))
-            return;
-#endif
 
         Out << "namespace {\n";
         printType(Out, AT, false, getArrayName(AT), true);
@@ -3185,13 +2926,8 @@ void CWriter::printContainedStructs(llvm::Type *Ty, llvm::SmallPtrSet<llvm::Type
 }
 
 void CWriter::printContainedArrays(llvm::ArrayType *ATy, llvm::SmallPtrSet<llvm::Type *, 16> &Printed) {
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
     if (!Printed.insert(ATy).second)
         return;
-#else
-    if (!Printed.insert(ATy))
-        return;
-#endif
 
     llvm::ArrayType *ChildTy = llvm::dyn_cast<llvm::ArrayType>(ATy->getElementType());
     if (ChildTy != NULL)
@@ -3207,17 +2943,10 @@ void CWriter::printFunctionSignature(const llvm::Function *F, bool Prototype) {
 
     if (F->hasLocalLinkage())
         Out << "static ";
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
     if (F->hasDLLImportStorageClass())
         Out << "__declspec(dllimport) ";
     if (F->hasDLLExportStorageClass())
         Out << "__declspec(dllexport) ";
-#else
-    if (F->hasDLLImportLinkage())
-        Out << "__declspec(dllimport) ";
-    if (F->hasDLLExportLinkage())
-        Out << "__declspec(dllexport) ";
-#endif
     switch (F->getCallingConv()) {
     case llvm::CallingConv::X86_StdCall:
         Out << "__attribute__((stdcall)) ";
@@ -3234,13 +2963,7 @@ void CWriter::printFunctionSignature(const llvm::Function *F, bool Prototype) {
 
     // Loop over the arguments, printing them...
     llvm::FunctionType *FT = llvm::cast<llvm::FunctionType>(F->getFunctionType());
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-    const llvm::AttrListPtr &PAL = F->getAttributes();
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-    const llvm::AttributeSet &PAL = F->getAttributes();
-#else // LLVM 5.0+
     const llvm::AttributeList &PAL = F->getAttributes();
-#endif
 
     std::string tstr;
     llvm::raw_string_ostream FunctionInnards(tstr);
@@ -3267,38 +2990,15 @@ void CWriter::printFunctionSignature(const llvm::Function *F, bool Prototype) {
                 if (PrintedArg)
                     FunctionInnards << ", ";
                 if (I->hasName() || !Prototype)
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-                    ArgName = GetValueName(I);
-#else /* LLVM 3.8+ */
                     ArgName = GetValueName(&*I);
-#endif
                 else
                     ArgName = "";
                 llvm::Type *ArgTy = I->getType();
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::ByVal)) {
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                if (PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex,
-                                                             llvm::Attribute::ByVal)) {
-#else // LLVM 5.0+
                 if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::ByVal)) {
-#endif
                     ArgTy = llvm::cast<llvm::PointerType>(ArgTy)->getElementType();
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-                    ByValParams.insert(I);
-#else /* LLVM 3.8+ */
                     ByValParams.insert(&*I);
-#endif
                 }
-                printType(FunctionInnards, ArgTy,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                          PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::SExt),
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                          PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex,
-                                                                   llvm::Attribute::SExt),
-#else // LLVM 5.0+
-                          PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt),
-#endif
+                printType(FunctionInnards, ArgTy, PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt),
                           ArgName);
                 PrintedArg = true;
                 ++Idx;
@@ -3321,25 +3021,11 @@ void CWriter::printFunctionSignature(const llvm::Function *F, bool Prototype) {
             if (PrintedArg)
                 FunctionInnards << ", ";
             llvm::Type *ArgTy = *I;
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-            if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::ByVal)) {
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-            if (PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::ByVal)) {
-#else // LLVM 5.0+
             if (PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::ByVal)) {
-#endif
                 assert(ArgTy->isPointerTy());
                 ArgTy = llvm::cast<llvm::PointerType>(ArgTy)->getElementType();
             }
-            printType(FunctionInnards, ArgTy,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                      PAL.getParamAttributes(Idx).hasAttribute(llvm::Attributes::SExt)
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                      PAL.getParamAttributes(Idx).hasAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::SExt)
-#else // LLVM 5.0+
-                      PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt)
-#endif
-            );
+            printType(FunctionInnards, ArgTy, PAL.getParamAttributes(Idx).hasAttribute(llvm::Attribute::SExt));
             PrintedArg = true;
             ++Idx;
         }
@@ -3370,15 +3056,7 @@ void CWriter::printFunctionSignature(const llvm::Function *F, bool Prototype) {
     }
 
     // Print out the return type and the signature built above.
-    printType(Out, RetTy,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-              PAL.getParamAttributes(0).hasAttribute(llvm::Attributes::SExt),
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-              PAL.getParamAttributes(0).hasAttribute(llvm::AttributeSet::ReturnIndex, llvm::Attribute::SExt),
-#else // LLVM 5.0+
-              PAL.getParamAttributes(0).hasAttribute(llvm::Attribute::SExt),
-#endif
-              FunctionInnards.str());
+    printType(Out, RetTy, PAL.getParamAttributes(0).hasAttribute(llvm::Attribute::SExt), FunctionInnards.str());
 }
 
 static inline bool isFPIntBitCast(const llvm::Instruction &I) {
@@ -3447,11 +3125,7 @@ void CWriter::printFunction(llvm::Function &F) {
     // print the basic blocks
     for (llvm::Function::iterator BB = F.begin(), E = F.end(); BB != E; ++BB) {
         if (llvm::Loop *L = LI->getLoopFor(&*BB)) {
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_9 // LLVM 3.9+
             if (L->getHeader()->getIterator() == BB && L->getParentLoop() == 0)
-#else
-            if (L->getHeader() == BB && L->getParentLoop() == 0)
-#endif
                 printLoop(L);
         } else {
             printBasicBlock(&*BB);
@@ -3547,24 +3221,15 @@ void CWriter::visitSwitchInst(llvm::SwitchInst &SI) {
     Out << ";\n";
 
     for (llvm::SwitchInst::CaseIt i = SI.case_begin(), e = SI.case_end(); i != e; ++i) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        llvm::ConstantInt *CaseVal = i.getCaseValue();
-        llvm::BasicBlock *Succ = i.getCaseSuccessor();
-#else // LLVM 5.0+
         llvm::ConstantInt *CaseVal = i->getCaseValue();
         llvm::BasicBlock *Succ = i->getCaseSuccessor();
-#endif
         Out << "  case ";
         writeOperand(CaseVal);
         Out << ":\n";
         printPHICopiesForSuccessor(SI.getParent(), Succ, 2);
         printBranchToBlock(SI.getParent(), Succ, 2);
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
         if (llvm::Function::iterator(Succ) == std::next(llvm::Function::iterator(SI.getParent())))
-#else
-        if (llvm::Function::iterator(Succ) == llvm::next(llvm::Function::iterator(SI.getParent())))
-#endif
             Out << "    break;\n";
     }
 
@@ -3583,11 +3248,7 @@ bool CWriter::isGotoCodeNecessary(llvm::BasicBlock *From, llvm::BasicBlock *To)
     /// FIXME: This should be reenabled, but loop reordering safe!!
     return true;
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
     if (std::next(llvm::Function::iterator(From)) != llvm::Function::iterator(To))
-#else
-    if (llvm::next(llvm::Function::iterator(From)) != llvm::Function::iterator(To))
-#endif
         return true; // Not the direct successor, we need a goto.
 
     // llvm::isa<llvm::SwitchInst>(From->getTerminator())
@@ -3599,20 +3260,12 @@ bool CWriter::isGotoCodeNecessary(llvm::BasicBlock *From, llvm::BasicBlock *To)
 
 void CWriter::printPHICopiesForSuccessor(llvm::BasicBlock *CurBlock, llvm::BasicBlock *Successor, unsigned Indent) {
     for (llvm::BasicBlock::iterator I = Successor->begin(); llvm::isa<llvm::PHINode>(I); ++I) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        llvm::PHINode *PN = llvm::cast<llvm::PHINode>(I);
-#else /* LLVM 3.8+ */
         llvm::PHINode *PN = llvm::cast<llvm::PHINode>(&*I);
-#endif
         // Now we have to do the printing.
         llvm::Value *IV = PN->getIncomingValueForBlock(CurBlock);
         if (!llvm::isa<llvm::UndefValue>(IV)) {
             Out << std::string(Indent, ' ');
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-            Out << "  " << GetValueName(I) << "__PHI = ";
-#else /* LLVM 3.8+ */
             Out << "  " << GetValueName(&*I) << "__PHI = ";
-#endif
             writeOperand(IV);
             Out << ";   /* for PHI node */\n";
         }
@@ -4357,9 +4010,7 @@ void CWriter::lowerIntrinsics(llvm::Function &F) {
                         const char *BuiltinName = "";
 #define GET_GCC_BUILTIN_NAME
 #define Intrinsic llvm::Intrinsic
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include "llvm/Intrinsics.gen"
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_6_0 /* LLVM 3.3-6.0 */
+#if ISPC_LLVM_VERSION == ISPC_LLVM_6_0 /* LLVM 6.0 */
 #include "llvm/IR/Intrinsics.gen"
 #else /* LLVM 7.0+ */
 // This looks completely broken, even in 3.2, need to figure out what's going on here
@@ -4375,21 +4026,12 @@ void CWriter::lowerIntrinsics(llvm::Function &F) {
                         // All other intrinsic calls we must lower.
                         llvm::Instruction *Before = 0;
                         if (CI != &BB->front())
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
                             Before = &*std::prev(llvm::BasicBlock::iterator(CI));
-#else
-                            Before = prior(llvm::BasicBlock::iterator(CI));
-#endif
 
                         IL->LowerIntrinsicCall(CI);
-                        if (Before) {  // Move iterator to instruction after call
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-                            I = Before;
-                            ++I;
-#else /* LLVM 3.8+ */
+                        if (Before) { // Move iterator to instruction after call
                             I = Before->getIterator();
                             ++I;
-#endif
                         } else {
                             I = BB->begin();
                         }
@@ -4437,13 +4079,7 @@ void CWriter::visitCallInst(llvm::CallInst &I) {
 
     // If this is a call to a struct-return function, assign to the first
     // parameter instead of passing it to the call.
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-    const llvm::AttrListPtr &PAL = I.getAttributes();
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-    const llvm::AttributeSet &PAL = I.getAttributes();
-#else // LLVM 5.0+
     const llvm::AttributeList &PAL = I.getAttributes();
-#endif
 
     bool hasByVal = I.hasByValArgument();
     bool isStructRet = (I.getNumArgOperands() > 0) && I.hasStructRetAttr();
@@ -4550,29 +4186,11 @@ void CWriter::visitCallInst(llvm::CallInst &I) {
         } else if (ArgNo < NumDeclaredParams && (*AI)->getType() != FTy->getParamType(ArgNo)) {
             Out << '(';
             printType(Out, FTy->getParamType(ArgNo),
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                      PAL.getParamAttributes(ArgNo + 1).hasAttribute(llvm::Attributes::SExt)
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                      PAL.getParamAttributes(ArgNo + 1).hasAttribute(llvm::AttributeSet::FunctionIndex,
-                                                                     llvm::Attribute::SExt)
-#else // LLVM 5.0+
-                      PAL.getParamAttributes(ArgNo + 1).hasAttribute(llvm::Attribute::SExt)
-#endif
-            );
+                      PAL.getParamAttributes(ArgNo + 1).hasAttribute(llvm::Attribute::SExt));
             Out << ')';
         }
         // Check if the argument is expected to be passed by value.
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        if (I.paramHasAttr(ArgNo + 1,
-#else // LLVM 5.0+
-        if (I.paramHasAttr(ArgNo,
-#endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                           llvm::Attributes::ByVal
-#else /* LLVM 3.3+ */
-                           llvm::Attribute::ByVal
-#endif
-                           )) {
+        if (I.paramHasAttr(ArgNo, llvm::Attribute::ByVal)) {
             writeOperandDeref(*AI);
         } else {
             writeOperand(*AI);
@@ -4593,9 +4211,7 @@ bool CWriter::visitBuiltinCall(llvm::CallInst &I, llvm::Intrinsic::ID ID, bool &
         const char *BuiltinName = "";
 #define GET_GCC_BUILTIN_NAME
 #define Intrinsic llvm::Intrinsic
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include "llvm/Intrinsics.gen"
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_6_0 /* LLVM 3.3-6.0 */
+#if ISPC_LLVM_VERSION == ISPC_LLVM_6_0 /* LLVM 6.0 */
 #include "llvm/IR/Intrinsics.gen"
 #else /* LLVM 7.0+ */
 // This looks completely broken, even in 3.2, need to figure out what's going on here
@@ -4811,11 +4427,7 @@ void CWriter::printGEPExpression(llvm::Value *Ptr, llvm::gep_type_iterator I, ll
     llvm::VectorType *LastIndexIsVector = 0;
     {
         for (llvm::gep_type_iterator TmpI = I; TmpI != E; ++TmpI)
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-            LastIndexIsVector = llvm::dyn_cast<llvm::VectorType>(*TmpI);
-#else // LLVM 4.0+
             LastIndexIsVector = llvm::dyn_cast<llvm::VectorType>(TmpI.getIndexedType());
-#endif
     }
 
     Out << "(";
@@ -4847,11 +4459,7 @@ void CWriter::printGEPExpression(llvm::Value *Ptr, llvm::gep_type_iterator I, ll
         // exposed, like a global, avoid emitting (&foo)[0], just emit foo instead.
         if (isAddressExposed(Ptr)) {
             writeOperandInternal(Ptr, Static);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-        } else if (I != E && (*I)->isStructTy()) {
-#else // LLVM 4.0+
         } else if (I != E && I.isStruct()) {
-#endif
             // If we didn't already emit the first operand, see if we can print it as
             // P->f instead of "P[0].f"
             writeOperand(Ptr);
@@ -5160,10 +4768,8 @@ void CWriter::visitAtomicRMWInst(llvm::AtomicRMWInst &AI) {
 
 void CWriter::visitAtomicCmpXchgInst(llvm::AtomicCmpXchgInst &ACXI) {
     Out << "(";
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
     printType(Out, ACXI.getType(), false);
     Out << "::init("; // LLVM cmpxchg returns a struct, so we need make an assighment properly
-#endif
     Out << "__atomic_cmpxchg(";
     writeOperand(ACXI.getPointerOperand());
     Out << ", ";
@@ -5171,9 +4777,7 @@ void CWriter::visitAtomicCmpXchgInst(llvm::AtomicCmpXchgInst &ACXI) {
     Out << ", ";
     writeOperand(ACXI.getNewValOperand());
     Out << ")";
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
     Out << ", true /* There is no way to learn the value of this bit inside ISPC, so making it constant */)";
-#endif
     Out << ")";
 }
 
@@ -5187,11 +4791,7 @@ class SmearCleanupPass : public llvm::BasicBlockPass {
         vectorWidth = width;
     }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // <= 3.9
-    const char *getPassName() const { return "Smear Cleanup Pass"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Smear Cleanup Pass"; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
     static char ID;
@@ -5268,14 +4868,7 @@ llvm::Value *SmearCleanupPass::getShuffleSmearValue(llvm::Instruction *inst) con
 
     // Check that the shuffle is a broadcast of the element of the first vector,
     // i.e. mask vector is vector with equal elements of expected size.
-    if (!(mask &&
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-          (mask->isNullValue() ||
-           (shuffleInst->getMask()->getType()->isVectorTy() &&
-            llvm::dyn_cast<llvm::ConstantVector>(shuffleInst->getMask())->getSplatValue() != 0)) &&
-#else
-          (mask->isNullValue() || (shuffleInst->getMask()->getSplatValue() != 0)) &&
-#endif
+    if (!(mask && (mask->isNullValue() || (shuffleInst->getMask()->getSplatValue() != 0)) &&
           llvm::dyn_cast<llvm::VectorType>(mask->getType())->getNumElements() == vectorWidth)) {
         return NULL;
     }
@@ -5299,16 +4892,9 @@ llvm::Value *SmearCleanupPass::getShuffleSmearValue(llvm::Instruction *inst) con
             // Declare the __extract_element function if needed; it takes a vector and
             // a scalar parameter and returns a scalar of the vector parameter type.
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
-            llvm::Constant *ef =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                module->getOrInsertFunction(
-                    "__extract_element", shuffleInst->getOperand(0)->getType()->getVectorElementType(),
-                    shuffleInst->getOperand(0)->getType(), llvm::IntegerType::get(module->getContext(), 32), NULL);
-#else // LLVM 5.0+
-                module->getOrInsertFunction(
-                    "__extract_element", shuffleInst->getOperand(0)->getType()->getVectorElementType(),
-                    shuffleInst->getOperand(0)->getType(), llvm::IntegerType::get(module->getContext(), 32));
-#endif
+            llvm::Constant *ef = module->getOrInsertFunction(
+                "__extract_element", shuffleInst->getOperand(0)->getType()->getVectorElementType(),
+                shuffleInst->getOperand(0)->getType(), llvm::IntegerType::get(module->getContext(), 32));
             extractFunc = llvm::dyn_cast<llvm::Function>(ef);
 #else // LLVM 9.0+
             llvm::FunctionCallee ef = module->getOrInsertFunction(
@@ -5324,15 +4910,8 @@ llvm::Value *SmearCleanupPass::getShuffleSmearValue(llvm::Instruction *inst) con
         if (extractFunc == NULL) {
             return NULL;
         }
-        llvm::Instruction *extractCall =
-            llvm::ExtractElementInst::Create(shuffleInst->getOperand(0),
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                                             // mask is of VectorType
-                                             llvm::dyn_cast<llvm::ConstantVector>(mask)->getSplatValue(),
-#else
-                                             mask->getSplatValue(),
-#endif
-                                             "__extract_element", inst);
+        llvm::Instruction *extractCall = llvm::ExtractElementInst::Create(
+            shuffleInst->getOperand(0), mask->getSplatValue(), "__extract_element", inst);
         return extractCall;
     }
 
@@ -5361,12 +4940,7 @@ bool SmearCleanupPass::runOnBasicBlock(llvm::BasicBlock &bb) {
                 // scalar parameter and returns a vector of the same
                 // parameter type.
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
-                llvm::Constant *sf =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                    module->getOrInsertFunction(smearFuncName, iter->getType(), smearType, NULL);
-#else  // LLVM 5.0+
-                    module->getOrInsertFunction(smearFuncName, iter->getType(), smearType);
-#endif // LLVM 9.0+
+                llvm::Constant *sf = module->getOrInsertFunction(smearFuncName, iter->getType(), smearType);
                 smearFunc = llvm::dyn_cast<llvm::Function>(sf);
 #else
                 llvm::FunctionCallee sf = module->getOrInsertFunction(smearFuncName, iter->getType(), smearType);
@@ -5400,11 +4974,7 @@ class AndCmpCleanupPass : public llvm::BasicBlockPass {
   public:
     AndCmpCleanupPass() : BasicBlockPass(ID) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // <= 3.9
-    const char *getPassName() const { return "AndCmp Cleanup Pass"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "AndCmp Cleanup Pass"; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
     static char ID;
@@ -5463,14 +5033,8 @@ bool AndCmpCleanupPass::runOnBasicBlock(llvm::BasicBlock &bb) {
                 // replacing and the third argument is the mask type.
                 llvm::Type *cmpOpType = opCmp->getOperand(0)->getType();
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
-                llvm::Constant *acf =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                    m->module->getOrInsertFunction(funcName, LLVMTypes::MaskType, cmpOpType, cmpOpType,
-                                                   LLVMTypes::MaskType, NULL);
-#else // LLVM 5.0+
-                    m->module->getOrInsertFunction(funcName, LLVMTypes::MaskType, cmpOpType, cmpOpType,
-                                                   LLVMTypes::MaskType);
-#endif
+                llvm::Constant *acf = m->module->getOrInsertFunction(funcName, LLVMTypes::MaskType, cmpOpType,
+                                                                     cmpOpType, LLVMTypes::MaskType);
                 andCmpFunc = llvm::dyn_cast<llvm::Function>(acf);
 #else
                 llvm::FunctionCallee acf = m->module->getOrInsertFunction(funcName, LLVMTypes::MaskType, cmpOpType,
@@ -5517,61 +5081,36 @@ class MaskOpsCleanupPass : public llvm::BasicBlockPass {
         // Declare the __not, __and_not1, and __and_not2 functions that we
         // expect the target to end up providing.
         notFunc =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-            llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__not", mt, mt, NULL));
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_8_0 // LLVM 5.0-LLVM 8.0
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__not", mt, mt));
-#else                                    // LLVM 9.0+
+#else
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__not", mt, mt).getCallee());
 #endif
         assert(notFunc != NULL);
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-        notFunc->addFnAttr(llvm::Attributes::NoUnwind);
-        notFunc->addFnAttr(llvm::Attributes::ReadNone);
-#else /* LLVM 3.3+ */
         notFunc->addFnAttr(llvm::Attribute::NoUnwind);
         notFunc->addFnAttr(llvm::Attribute::ReadNone);
-#endif
 
         andNotFuncs[0] =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-            llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not1", mt, mt, mt, NULL));
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_8_0 // LLVM 5.0-LLVM 8.0
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not1", mt, mt, mt));
-#else                                    // LLVM 9.0+
+#else
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not1", mt, mt, mt).getCallee());
 #endif
         assert(andNotFuncs[0] != NULL);
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-        andNotFuncs[0]->addFnAttr(llvm::Attributes::NoUnwind);
-        andNotFuncs[0]->addFnAttr(llvm::Attributes::ReadNone);
-#else /* LLVM 3.3+ */
         andNotFuncs[0]->addFnAttr(llvm::Attribute::NoUnwind);
         andNotFuncs[0]->addFnAttr(llvm::Attribute::ReadNone);
-#endif
         andNotFuncs[1] =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-            llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not2", mt, mt, mt, NULL));
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_8_0 // LLVM 5.0-LLVM 8.0
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not2", mt, mt, mt));
-#else                                    // LLVM 9.0+
+#else
             llvm::dyn_cast<llvm::Function>(m->getOrInsertFunction("__and_not2", mt, mt, mt).getCallee());
 #endif
         assert(andNotFuncs[1] != NULL);
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-        andNotFuncs[1]->addFnAttr(llvm::Attributes::NoUnwind);
-        andNotFuncs[1]->addFnAttr(llvm::Attributes::ReadNone);
-#else /* LLVM 3.3+ */
         andNotFuncs[1]->addFnAttr(llvm::Attribute::NoUnwind);
         andNotFuncs[1]->addFnAttr(llvm::Attribute::ReadNone);
-#endif
     }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // <= 3.9
-    const char *getPassName() const { return "MaskOps Cleanup Pass"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "MaskOps Cleanup Pass"; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
   private:
@@ -5678,11 +5217,7 @@ bool MaskOpsCleanupPass::runOnBasicBlock(llvm::BasicBlock &bb) {
 
 bool WriteCXXFile(llvm::Module *module, const char *fn, int vectorWidth, const char *includeName) {
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 // 3.2, 3.3, 3.4, 3.5, 3.6
-    llvm::PassManager pm;
-#else // LLVM 3.7+
     llvm::legacy::PassManager pm;
-#endif
 #if 0
     if (const llvm::TargetData *td = targetMachine->getTargetData())
         pm.add(new llvm::TargetData(*td));
@@ -5690,29 +5225,13 @@ bool WriteCXXFile(llvm::Module *module, const char *fn, int vectorWidth, const c
         pm.add(new llvm::TargetData(module));
 #endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3 // 3.2, 3.3
-    int flags = 0;
-#else // LLVM 3.4+
     llvm::sys::fs::OpenFlags flags = llvm::sys::fs::F_None;
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // 3.2, 3.3, 3.4, 3.5
-    std::string error;
-#else // LLVM 3.6+
     std::error_code error;
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_5_0
-    llvm::tool_output_file *of = new llvm::tool_output_file(fn, error, flags);
-#else // LLVM 6.0+
     llvm::ToolOutputFile *of = new llvm::ToolOutputFile(fn, error, flags);
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // 3.2, 3.3, 3.4, 3.5
-    if (error.size()) {
-#else // LLVM 3.6+
     if (error) {
-#endif
         fprintf(stderr, "Error opening output file \"%s\".\n", fn);
         return false;
     }
@@ -5728,10 +5247,6 @@ bool WriteCXXFile(llvm::Module *module, const char *fn, int vectorWidth, const c
     pm.add(llvm::createDeadCodeEliminationPass()); // clean up after smear pass
                                                    // CO    pm.add(llvm::createPrintModulePass(&fos));
     pm.add(new CWriter(fos, includeName, vectorWidth));
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-    // This interface is depricated for 3.3+
-    pm.add(llvm::createGCInfoDeleter());
-#endif
     // CO    pm.add(llvm::createVerifierPass());
 
     pm.run(*module);
diff --git a/src/ctx.cpp b/src/ctx.cpp
index c3395416..2aba41a1 100644
--- a/src/ctx.cpp
+++ b/src/ctx.cpp
@@ -44,23 +44,13 @@
 #include "sym.h"
 #include "type.h"
 #include "util.h"
-#include <map>
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_5_0 // LLVM 5.0+
 #include <llvm/BinaryFormat/Dwarf.h>
-#else // LLVM up to 4.x
-#include <llvm/Support/Dwarf.h>
-#endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/DerivedTypes.h>
-#include <llvm/Instructions.h>
-#include <llvm/Metadata.h>
-#include <llvm/Module.h>
-#else
+#include <map>
+
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/Instructions.h>
 #include <llvm/IR/Metadata.h>
 #include <llvm/IR/Module.h>
-#endif
 #ifdef ISPC_NVPTX_ENABLED
 #include <llvm/Support/FormattedStream.h>
 #include <llvm/Support/raw_ostream.h>
@@ -281,12 +271,7 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
             snprintf(buf, sizeof(buf), "__off_all_on_mask_%s", g->target->GetISAString());
 
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
-            llvm::Constant *offFunc =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                m->module->getOrInsertFunction(buf, LLVMTypes::VoidType, NULL);
-#else // LLVM 5.0+
-                m->module->getOrInsertFunction(buf, LLVMTypes::VoidType);
-#endif
+            llvm::Constant *offFunc = m->module->getOrInsertFunction(buf, LLVMTypes::VoidType);
 #else // LLVM 9.0+
             llvm::FunctionCallee offFuncCallee = m->module->getOrInsertFunction(buf, LLVMTypes::VoidType);
             llvm::Constant *offFunc = llvm::cast<llvm::Constant>(offFuncCallee.getCallee());
@@ -309,62 +294,26 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
 
         /* If debugging is enabled, tell the debug information emission
            code about this new function */
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        diFile = funcStartPos.GetDIFile();
-        AssertPos(currentPos, diFile.Verify());
-#else /* LLVM 3.7+ */
         diFile = funcStartPos.GetDIFile();
-#endif
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3 /* 3.2, 3.3 */
-        llvm::DIScope scope = llvm::DIScope(m->diBuilder->getCU());
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.4, 3.5, 3.6 */
-        llvm::DIScope scope = llvm::DIScope(m->diCompileUnit);
-#else                                    /* LLVM 3.7+ */
         llvm::DIScope *scope = m->diCompileUnit;
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        llvm::DIType diSubprogramType;
-        AssertPos(currentPos, scope.Verify());
-#else /* LLVM 3.7+ */
         llvm::DIType *diSubprogramType = NULL;
-#endif
 
         const FunctionType *functionType = function->GetType();
         if (functionType == NULL)
             AssertPos(currentPos, m->errorCount > 0);
         else {
             diSubprogramType = functionType->GetDIType(scope);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-            AssertPos(currentPos, diSubprogramType.Verify());
-#else /* LLVM 3.7+ */
-            // comming soon
-#endif
+            /*#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 // 3.2, 3.3, 3.4, 3.5, 3.6
+                        AssertPos(currentPos, diSubprogramType.Verify());
+            #else // LLVM 3.7+
+                        // comming soon
+            #endif*/
         }
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3 /* 3.2, 3.3 */
-        llvm::DIType diSubprogramType_n = diSubprogramType;
-        int flags = llvm::DIDescriptor::FlagPrototyped;
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_6                                       /* 3.4, 3.5, 3.6 */
-        Assert(diSubprogramType.isCompositeType());
-        llvm::DICompositeType diSubprogramType_n = static_cast<llvm::DICompositeType>(diSubprogramType);
-        int flags = llvm::DIDescriptor::FlagPrototyped;
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_7                                       /* LLVM 3.7 */
-        Assert(llvm::isa<llvm::DICompositeTypeBase>(diSubprogramType));
-        llvm::DISubroutineType *diSubprogramType_n =
-            llvm::cast<llvm::DISubroutineType>(getDICompositeType(diSubprogramType));
-        int flags = llvm::DINode::FlagPrototyped;
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_8 || ISPC_LLVM_VERSION == ISPC_LLVM_3_9 /* LLVM 3.8, 3.9 */
-        Assert(llvm::isa<llvm::DISubroutineType>(diSubprogramType));
-        llvm::DISubroutineType *diSubprogramType_n = llvm::cast<llvm::DISubroutineType>(diSubprogramType);
-        int flags = llvm::DINode::FlagPrototyped;
-#else                                                                          /* LLVM 4.0+ */
+        /* LLVM 4.0+ */
         Assert(llvm::isa<llvm::DISubroutineType>(diSubprogramType));
         llvm::DISubroutineType *diSubprogramType_n = llvm::cast<llvm::DISubroutineType>(diSubprogramType);
         llvm::DINode::DIFlags flags = llvm::DINode::FlagPrototyped;
 
-#endif
-
         std::string mangledName = llvmFunction->getName();
         if (mangledName == funSym->name)
             mangledName = "";
@@ -373,26 +322,12 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
         bool isOptimized = (g->opt.level > 0);
         int firstLine = funcStartPos.first_line;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        diSubprogram = m->diBuilder->createFunction(diFile /* scope */, funSym->name, mangledName, diFile, firstLine,
-                                                    diSubprogramType_n, isStatic, true, /* is defn */
-                                                    firstLine, flags, isOptimized, llvmFunction);
-        AssertPos(currentPos, diSubprogram.Verify());
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_7                                       /* LLVM 3.7 */
-        diSubprogram = m->diBuilder->createFunction(diFile /* scope */, funSym->name, mangledName, diFile, firstLine,
-                                                    diSubprogramType_n, isStatic, true, /* is defn */
-                                                    firstLine, flags, isOptimized, llvmFunction);
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_8 || ISPC_LLVM_VERSION == ISPC_LLVM_3_9 /* LLVM 3.8, 3.9 */
+#if ISPC_LLVM_VERSION < ISPC_LLVM_8_0
         diSubprogram = m->diBuilder->createFunction(diFile /* scope */, funSym->name, mangledName, diFile, firstLine,
                                                     diSubprogramType_n, isStatic, true, /* is defn */
                                                     firstLine, flags, isOptimized);
         llvmFunction->setSubprogram(diSubprogram);
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_4_0 && ISPC_LLVM_VERSION <= ISPC_LLVM_7_1 /* LLVM 4.0 to 7.1 */
-        diSubprogram = m->diBuilder->createFunction(diFile /* scope */, funSym->name, mangledName, diFile, firstLine,
-                                                    diSubprogramType_n, isStatic, true, /* is defn */
-                                                    firstLine, flags, isOptimized);
-        llvmFunction->setSubprogram(diSubprogram);
-#else                                                                          /* LLVM 8.0+ */
+#else /* LLVM 8.0+ */
         /* isDefinition is always set to 'true' */
         llvm::DISubprogram::DISPFlags SPFlags = llvm::DISubprogram::SPFlagDefinition;
         if (isOptimized)
@@ -1403,11 +1338,7 @@ static llvm::Value *lGetStringAsValue(llvm::BasicBlock *bblock, const char *s) {
                                                  llvm::GlobalValue::InternalLinkage, sConstant, var_name.c_str());
     llvm::Value *indices[2] = {LLVMInt32(0), LLVMInt32(0)};
     llvm::ArrayRef<llvm::Value *> arrayRef(&indices[0], &indices[2]);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-    return llvm::GetElementPtrInst::Create(sPtr, arrayRef, "sptr", bblock);
-#else /* LLVM 3.7+ */
     return llvm::GetElementPtrInst::Create(PTYPE(sPtr), sPtr, arrayRef, "sptr", bblock);
-#endif
 }
 
 void FunctionEmitContext::AddInstrumentationPoint(const char *note) {
@@ -1441,48 +1372,24 @@ void FunctionEmitContext::AddDebugPos(llvm::Value *value, const SourcePos *pos,
             // If first_line == 0, then we're in the middle of setting up
             // the standard library or the like; don't add debug positions
             // for those functions
-            inst->setDebugLoc(llvm::DebugLoc::get(p.first_line, p.first_column,
-                                                  scope ?
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-                                                        *scope
-#else /* LLVM 3.7+ */
-                                                        scope
-#endif
-                                                        : GetDIScope()));
+            inst->setDebugLoc(llvm::DebugLoc::get(p.first_line, p.first_column, scope ? scope : GetDIScope()));
     }
 }
 
 void FunctionEmitContext::StartScope() {
     if (m->diBuilder != NULL) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        llvm::DIScope parentScope;
-        llvm::DILexicalBlock lexicalBlock;
-#else /* LLVM 3.7+ */
         llvm::DIScope *parentScope;
         llvm::DILexicalBlock *lexicalBlock;
-#endif
         if (debugScopes.size() > 0)
             parentScope = debugScopes.back();
         else
             parentScope = diSubprogram;
 
         lexicalBlock = m->diBuilder->createLexicalBlock(parentScope, diFile, currentPos.first_line,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_5
-                                                        // Revision 202736 in LLVM adds support of DWARF discriminator
-                                                        // to the last argument and revision 202737 in clang adds 0
-                                                        // for the last argument by default.
-                                                        currentPos.first_column, 0);
-#else
                                                         // Revision 216239 in LLVM removes support of DWARF
                                                         // discriminator as the last argument
                                                         currentPos.first_column);
-#endif                                 // LLVM 3.2, 3.3, 3.4 and 3.6+
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        AssertPos(currentPos, lexicalBlock.Verify());
-        debugScopes.push_back(lexicalBlock);
-#else /* LLVM 3.7+ */
         debugScopes.push_back(llvm::cast<llvm::DILexicalBlockBase>(lexicalBlock));
-#endif
     }
 }
 
@@ -1493,12 +1400,7 @@ void FunctionEmitContext::EndScope() {
     }
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-llvm::DIScope
-#else /* LLVM 3.7+ */
-llvm::DIScope *
-#endif
-FunctionEmitContext::GetDIScope() const {
+llvm::DIScope *FunctionEmitContext::GetDIScope() const {
     AssertPos(currentPos, debugScopes.size() > 0);
     return debugScopes.back();
 }
@@ -1507,84 +1409,32 @@ void FunctionEmitContext::EmitVariableDebugInfo(Symbol *sym) {
     if (m->diBuilder == NULL)
         return;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-    llvm::DIScope scope = GetDIScope();
-    llvm::DIType diType = sym->type->GetDIType(scope);
-    AssertPos(currentPos, diType.Verify());
-    llvm::DIVariable var =
-#else /* LLVM 3.7+ */
     llvm::DIScope *scope = GetDIScope();
     llvm::DIType *diType = sym->type->GetDIType(scope);
-    llvm::DILocalVariable *var =
-#endif
+    llvm::DILocalVariable *var = m->diBuilder->createAutoVariable(
+        scope, sym->name, sym->pos.GetDIFile(), sym->pos.first_line, diType, true /* preserve through opts */);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7*/
-        m->diBuilder->createLocalVariable(llvm::dwarf::DW_TAG_auto_variable, scope, sym->name, sym->pos.GetDIFile(),
-                                          sym->pos.first_line, diType, true /* preserve through opts */);
-#else /* LLVM 3.8+ */
-        m->diBuilder->createAutoVariable(scope, sym->name, sym->pos.GetDIFile(), sym->pos.first_line, diType,
-                                         true /* preserve through opts */);
-#endif
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-    AssertPos(currentPos, var.Verify());
-    llvm::Instruction *declareInst = m->diBuilder->insertDeclare(sym->storagePtr, var,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_6
-                                                                 m->diBuilder->createExpression(),
-#endif
-                                                                 bblock);
-    AddDebugPos(declareInst, &sym->pos, &scope);
-#else /* LLVM 3.7+ */
     llvm::Instruction *declareInst =
         m->diBuilder->insertDeclare(sym->storagePtr, var, m->diBuilder->createExpression(),
                                     llvm::DebugLoc::get(sym->pos.first_line, sym->pos.first_column, scope), bblock);
     AddDebugPos(declareInst, &sym->pos, scope);
-#endif
 }
 
 void FunctionEmitContext::EmitFunctionParameterDebugInfo(Symbol *sym, int argNum) {
     if (m->diBuilder == NULL)
         return;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    int flags = 0;
-#else // LLVM 4.0+
     llvm::DINode::DIFlags flags = llvm::DINode::FlagZero;
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-    llvm::DIScope scope = diSubprogram;
-    llvm::DIType diType = sym->type->GetDIType(scope);
-    AssertPos(currentPos, diType.Verify());
-    llvm::DIVariable var =
-#else /* LLVM 3.7+ */
     llvm::DIScope *scope = diSubprogram;
     llvm::DIType *diType = sym->type->GetDIType(scope);
     llvm::DILocalVariable *var =
-#endif
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        m->diBuilder->createLocalVariable(llvm::dwarf::DW_TAG_arg_variable, scope, sym->name, sym->pos.GetDIFile(),
-                                          sym->pos.first_line, diType, true /* preserve through opts */, flags,
-                                          argNum + 1);
-#else /* LLVM 3.8+ */
         m->diBuilder->createParameterVariable(scope, sym->name, argNum + 1, sym->pos.GetDIFile(), sym->pos.first_line,
                                               diType, true /* preserve through opts */, flags);
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-    AssertPos(currentPos, var.Verify());
-    llvm::Instruction *declareInst = m->diBuilder->insertDeclare(sym->storagePtr, var,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_6
-                                                                 m->diBuilder->createExpression(),
-#endif
-                                                                 bblock);
-    AddDebugPos(declareInst, &sym->pos, &scope);
-#else /* LLVM 3.7+ */
     llvm::Instruction *declareInst =
         m->diBuilder->insertDeclare(sym->storagePtr, var, m->diBuilder->createExpression(),
                                     llvm::DebugLoc::get(sym->pos.first_line, sym->pos.first_column, scope), bblock);
     AddDebugPos(declareInst, &sym->pos, scope);
-#endif
 }
 
 /** If the given type is an array of vector types, then it's the
@@ -2096,12 +1946,8 @@ llvm::Value *FunctionEmitContext::GetElementPtrInst(llvm::Value *basePtr, llvm::
         // uniform, so just emit the regular LLVM GEP instruction
         llvm::Value *ind[1] = {index};
         llvm::ArrayRef<llvm::Value *> arrayRef(&ind[0], &ind[1]);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        llvm::Instruction *inst = llvm::GetElementPtrInst::Create(basePtr, arrayRef, name ? name : "gep", bblock);
-#else /* LLVM 3.7+ */
         llvm::Instruction *inst =
             llvm::GetElementPtrInst::Create(PTYPE(basePtr), basePtr, arrayRef, name ? name : "gep", bblock);
-#endif
         AddDebugPos(inst);
         return inst;
     } else
@@ -2149,12 +1995,8 @@ llvm::Value *FunctionEmitContext::GetElementPtrInst(llvm::Value *basePtr, llvm::
         // uniform, so just emit the regular LLVM GEP instruction
         llvm::Value *indices[2] = {index0, index1};
         llvm::ArrayRef<llvm::Value *> arrayRef(&indices[0], &indices[2]);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        llvm::Instruction *inst = llvm::GetElementPtrInst::Create(basePtr, arrayRef, name ? name : "gep", bblock);
-#else /* LLVM 3.7+ */
         llvm::Instruction *inst =
             llvm::GetElementPtrInst::Create(PTYPE(basePtr), basePtr, arrayRef, name ? name : "gep", bblock);
-#endif
         AddDebugPos(inst);
         return inst;
     } else {
@@ -2234,12 +2076,8 @@ llvm::Value *FunctionEmitContext::AddElementOffset(llvm::Value *fullBasePtr, int
         // If the pointer is uniform, we can use the regular LLVM GEP.
         llvm::Value *offsets[2] = {LLVMInt32(0), LLVMInt32(elementNum)};
         llvm::ArrayRef<llvm::Value *> arrayRef(&offsets[0], &offsets[2]);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 /* 3.2, 3.3, 3.4, 3.5, 3.6 */
-        resultPtr = llvm::GetElementPtrInst::Create(basePtr, arrayRef, name ? name : "struct_offset", bblock);
-#else /* LLVM 3.7+ */
         resultPtr =
             llvm::GetElementPtrInst::Create(PTYPE(basePtr), basePtr, arrayRef, name ? name : "struct_offset", bblock);
-#endif
     } else {
         // Otherwise do the math to find the offset and add it to the given
         // varying pointers
@@ -2535,43 +2373,23 @@ void FunctionEmitContext::addGSMetadata(llvm::Value *v, SourcePos pos) {
     llvm::Instruction *inst = llvm::dyn_cast<llvm::Instruction>(v);
     if (inst == NULL)
         return;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 /* 3.2, 3.3, 3.4, 3.5 */
-    llvm::Value *str = llvm::MDString::get(*g->ctx, pos.name);
-#else /* LLVN 3.6+ */
     llvm::MDString *str = llvm::MDString::get(*g->ctx, pos.name);
-#endif
     llvm::MDNode *md = llvm::MDNode::get(*g->ctx, str);
     inst->setMetadata("filename", md);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 /* 3.2, 3.3, 3.4, 3.5 */
-    llvm::Value *first_line = LLVMInt32(pos.first_line);
-#else /* LLVN 3.6+ */
     llvm::Metadata *first_line = llvm::ConstantAsMetadata::get(LLVMInt32(pos.first_line));
-#endif
     md = llvm::MDNode::get(*g->ctx, first_line);
     inst->setMetadata("first_line", md);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 /* 3.2, 3.3, 3.4, 3.5 */
-    llvm::Value *first_column = LLVMInt32(pos.first_column);
-#else /* LLVN 3.6+ */
     llvm::Metadata *first_column = llvm::ConstantAsMetadata::get(LLVMInt32(pos.first_column));
-#endif
     md = llvm::MDNode::get(*g->ctx, first_column);
     inst->setMetadata("first_column", md);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 /* 3.2, 3.3, 3.4, 3.5 */
-    llvm::Value *last_line = LLVMInt32(pos.last_line);
-#else /* LLVN 3.6+ */
     llvm::Metadata *last_line = llvm::ConstantAsMetadata::get(LLVMInt32(pos.last_line));
-#endif
     md = llvm::MDNode::get(*g->ctx, last_line);
     inst->setMetadata("last_line", md);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 /* 3.2, 3.3, 3.4, 3.5 */
-    llvm::Value *last_column = LLVMInt32(pos.last_column);
-#else /* LLVN 3.6+ */
     llvm::Metadata *last_column = llvm::ConstantAsMetadata::get(LLVMInt32(pos.last_column));
-#endif
     md = llvm::MDNode::get(*g->ctx, last_column);
     inst->setMetadata("last_column", md);
 }
@@ -2588,21 +2406,13 @@ llvm::Value *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, const char *n
         // end of allocaBlock
         llvm::Instruction *retInst = allocaBlock->getTerminator();
         AssertPos(currentPos, retInst);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        inst = new llvm::AllocaInst(llvmType, name ? name : "", retInst);
-#else // LLVM 5.0+
         unsigned AS = llvmFunction->getParent()->getDataLayout().getAllocaAddrSpace();
         inst = new llvm::AllocaInst(llvmType, AS, name ? name : "", retInst);
-#endif
     } else {
         // Unless the caller overrode the default and wants it in the
         // current basic block
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        inst = new llvm::AllocaInst(llvmType, name ? name : "", bblock);
-#else // LLVM 5.0+
         unsigned AS = llvmFunction->getParent()->getDataLayout().getAllocaAddrSpace();
         inst = new llvm::AllocaInst(llvmType, AS, name ? name : "", bblock);
-#endif
     }
 
     // If no alignment was specified but we have an array of a uniform
@@ -2923,17 +2733,13 @@ void FunctionEmitContext::MemcpyInst(llvm::Value *dest, llvm::Value *src, llvm::
         align = LLVMInt32(1);
 #if ISPC_LLVM_VERSION <= ISPC_LLVM_8_0
     llvm::Constant *mcFunc =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        m->module->getOrInsertFunction("llvm.memcpy.p0i8.p0i8.i64", LLVMTypes::VoidType, LLVMTypes::VoidPointerType,
-                                       LLVMTypes::VoidPointerType, LLVMTypes::Int64Type, LLVMTypes::Int32Type,
-                                       LLVMTypes::BoolType, NULL);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_6_0 // LLVM 5.0-6.0
+#if ISPC_LLVM_VERSION == ISPC_LLVM_6_0 // LLVM 6.0
         m->module->getOrInsertFunction("llvm.memcpy.p0i8.p0i8.i64", LLVMTypes::VoidType, LLVMTypes::VoidPointerType,
                                        LLVMTypes::VoidPointerType, LLVMTypes::Int64Type, LLVMTypes::Int32Type,
                                        LLVMTypes::BoolType);
-#else                                    // LLVM 7.0+
-                                         // Now alignment goes as an attribute, not as a parameter.
-                                         // See LLVM r322965/r323597 for more details.
+#else // LLVM 7.0+
+      // Now alignment goes as an attribute, not as a parameter.
+      // See LLVM r322965/r323597 for more details.
         m->module->getOrInsertFunction("llvm.memcpy.p0i8.p0i8.i64", LLVMTypes::VoidType, LLVMTypes::VoidPointerType,
                                        LLVMTypes::VoidPointerType, LLVMTypes::Int64Type, LLVMTypes::BoolType);
 #endif
@@ -3134,17 +2940,10 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
         // alias analysis.
         // TODO: what other attributes needs to be copied?
         // TODO: do the same for varing path.
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3 && ISPC_LLVM_VERSION < ISPC_LLVM_5_0 // LLVM 3.3-4.0
-        llvm::CallInst *cc = llvm::dyn_cast<llvm::CallInst>(ci);
-        if (cc && cc->getCalledFunction() && cc->getCalledFunction()->doesNotAlias(0)) {
-            cc->addAttribute(0, llvm::Attribute::NoAlias);
-        }
-#else // LLVM 5.0+
         llvm::CallInst *cc = llvm::dyn_cast<llvm::CallInst>(ci);
         if (cc && cc->getCalledFunction() && cc->getCalledFunction()->returnDoesNotAlias()) {
             cc->addAttribute(llvm::AttributeList::ReturnIndex, llvm::Attribute::NoAlias);
         }
-#endif
 
         AddDebugPos(ci);
         return ci;
diff --git a/src/ctx.h b/src/ctx.h
index 1fc41db9..904cc4ba 100644
--- a/src/ctx.h
+++ b/src/ctx.h
@@ -40,20 +40,11 @@
 
 #include "ispc.h"
 #include <map>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/InstrTypes.h>
-#include <llvm/Instructions.h>
-#else // 3.3+
-#include <llvm/IR/InstrTypes.h>
-#include <llvm/IR/Instructions.h>
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4
-#include <llvm/DIBuilder.h>
-#include <llvm/DebugInfo.h>
-#else // 3.5+
+
 #include <llvm/IR/DIBuilder.h>
 #include <llvm/IR/DebugInfo.h>
-#endif
+#include <llvm/IR/InstrTypes.h>
+#include <llvm/IR/Instructions.h>
 
 struct CFInfo;
 
@@ -348,13 +339,8 @@ class FunctionEmitContext {
         llvm::Instruction for convenience; in calling code we often have
         Instructions stored using Value pointers; the code here returns
         silently if it's not actually given an instruction. */
-    void AddDebugPos(llvm::Value *instruction, const SourcePos *pos = NULL,
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-                     llvm::DIScope *scope = NULL);
-#else /* LLVM 3.7+ */
-                     llvm::DIScope *scope = NULL);
+    void AddDebugPos(llvm::Value *instruction, const SourcePos *pos = NULL, llvm::DIScope *scope = NULL);
     // llvm::MDScope *scope = NULL );
-#endif
 
     /** Inform the debugging information generation code that a new scope
         is starting in the source program. */
@@ -366,11 +352,8 @@ class FunctionEmitContext {
 
     /** Returns the llvm::DIScope corresponding to the current program
         scope. */
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIScope GetDIScope() const;
-#else // LLVM 3.7++
+
     llvm::DIScope *GetDIScope() const;
-#endif
 
     /** Emits debugging information for the variable represented by
         sym.  */
@@ -655,19 +638,6 @@ class FunctionEmitContext {
         emitted. */
     std::vector<CFInfo *> controlFlowInfo;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    /** DIFile object corresponding to the source file where the current
-        function was defined (used for debugging info). */
-    llvm::DIFile diFile;
-
-    /** DISubprogram corresponding to this function (used for debugging
-        info). */
-    llvm::DISubprogram diSubprogram;
-
-    /** These correspond to the current set of nested scopes in the
-        function. */
-    std::vector<llvm::DILexicalBlock> debugScopes;
-#else // LLVM 3.7++
     /** DIFile object corresponding to the source file where the current
         function was defined (used for debugging info). */
     llvm::DIFile *diFile;
@@ -679,7 +649,6 @@ class FunctionEmitContext {
     /** These correspond to the current set of nested scopes in the
         function. */
     std::vector<llvm::DIScope *> debugScopes;
-#endif
 
     /** True if a 'launch' statement has been encountered in the function. */
     bool launchedTasks;
diff --git a/src/expr.cpp b/src/expr.cpp
index eaa6e697..2f6f85ce 100644
--- a/src/expr.cpp
+++ b/src/expr.cpp
@@ -56,29 +56,16 @@
 #include <list>
 #include <set>
 #include <stdio.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/CallingConv.h>
-#include <llvm/DerivedTypes.h>
-#include <llvm/Function.h>
-#include <llvm/Instructions.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Module.h>
-#include <llvm/Type.h>
-#else
+
+#include <llvm/ExecutionEngine/GenericValue.h>
 #include <llvm/IR/CallingConv.h>
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/Function.h>
+#include <llvm/IR/InstIterator.h>
 #include <llvm/IR/Instructions.h>
 #include <llvm/IR/LLVMContext.h>
 #include <llvm/IR/Module.h>
 #include <llvm/IR/Type.h>
-#endif
-#include <llvm/ExecutionEngine/GenericValue.h>
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
-#include <llvm/IR/InstIterator.h>
-#else
-#include <llvm/Support/InstIterator.h>
-#endif
 
 /////////////////////////////////////////////////////////////////////////////////////
 // Expr
diff --git a/src/func.cpp b/src/func.cpp
index da8ea063..d8f35396 100644
--- a/src/func.cpp
+++ b/src/func.cpp
@@ -46,17 +46,6 @@
 #include "util.h"
 #include <stdio.h>
 
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2 // 3.2
-#ifdef ISPC_NVPTX_ENABLED
-#include <llvm/Metadata.h>
-#endif /* ISPC_NVPTX_ENABLED */
-#include <llvm/DerivedTypes.h>
-#include <llvm/Instructions.h>
-#include <llvm/Intrinsics.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Module.h>
-#include <llvm/Type.h>
-#else
 #ifdef ISPC_NVPTX_ENABLED
 #include <llvm/IR/Metadata.h>
 #endif /* ISPC_NVPTX_ENABLED */
@@ -66,27 +55,18 @@
 #include <llvm/IR/LLVMContext.h>
 #include <llvm/IR/Module.h>
 #include <llvm/IR/Type.h>
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-#include "llvm/PassManager.h"
-#else // LLVM 3.7+
+
 #include "llvm/IR/LegacyPassManager.h"
-#endif
+#include <llvm/IR/CFG.h>
+#include <llvm/IR/IRPrintingPasses.h>
+#include <llvm/IR/Verifier.h>
 #include <llvm/PassRegistry.h>
 #include <llvm/Support/FileUtilities.h>
 #include <llvm/Support/FormattedStream.h>
 #include <llvm/Target/TargetMachine.h>
 #include <llvm/Target/TargetOptions.h>
 #include <llvm/Transforms/IPO.h>
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
-#include <llvm/IR/CFG.h>
-#include <llvm/IR/IRPrintingPasses.h>
-#include <llvm/IR/Verifier.h>
-#else
-#include <llvm/Analysis/Verifier.h>
-#include <llvm/Assembly/PrintModulePass.h>
-#include <llvm/Support/CFG.h>
-#endif
+
 #include <llvm/Support/ToolOutputFile.h>
 
 Function::Function(Symbol *s, Stmt *c) {
@@ -232,10 +212,8 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
     maskSymbol->pos = firstStmtPos;
     ctx->EmitVariableDebugInfo(maskSymbol);
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
     if (g->NoOmitFramePointer)
         function->addFnAttr("no-frame-pointer-elim", "true");
-#endif
     g->target->markFuncWithTargetAttr(function);
 #if 0
     llvm::BasicBlock *entryBBlock = ctx->GetCurrentBasicBlock();
@@ -251,19 +229,7 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
         // pointer to the structure that holds all of the arguments, the
         // thread index, and the thread count variables.
         llvm::Function::arg_iterator argIter = function->arg_begin();
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        llvm::Value *structParamPtr = argIter++;
-        llvm::Value *threadIndex = argIter++;
-        llvm::Value *threadCount = argIter++;
-        llvm::Value *taskIndex = argIter++;
-        llvm::Value *taskCount = argIter++;
-        llvm::Value *taskIndex0 = argIter++;
-        llvm::Value *taskIndex1 = argIter++;
-        llvm::Value *taskIndex2 = argIter++;
-        llvm::Value *taskCount0 = argIter++;
-        llvm::Value *taskCount1 = argIter++;
-        llvm::Value *taskCount2 = argIter++;
-#else /* LLVM 3.8+ */
+
         llvm::Value *structParamPtr = &*(argIter++);
         llvm::Value *threadIndex = &*(argIter++);
         llvm::Value *threadCount = &*(argIter++);
@@ -275,7 +241,6 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
         llvm::Value *taskCount0 = &*(argIter++);
         llvm::Value *taskCount1 = &*(argIter++);
         llvm::Value *taskCount2 = &*(argIter++);
-#endif
         // Copy the function parameter values from the structure into local
         // storage
         for (unsigned int i = 0; i < args.size(); ++i)
@@ -333,11 +298,8 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
             // Allocate stack storage for the parameter and emit code
             // to store the its value there.
             sym->storagePtr = ctx->AllocaInst(argIter->getType(), sym->name.c_str());
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-            ctx->StoreInst(argIter, sym->storagePtr);
-#else /* LLVM 3.8+ */
+
             ctx->StoreInst(&*argIter, sym->storagePtr);
-#endif
             ctx->EmitFunctionParameterDebugInfo(sym, i);
         }
 
@@ -355,29 +317,18 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
             // Otherwise use the mask to set the entry mask value
             argIter->setName("__mask");
             Assert(argIter->getType() == LLVMTypes::MaskType);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-            ctx->SetFunctionMask(argIter);
-#else /* LLVM 3.8+ */
+
             ctx->SetFunctionMask(&*argIter);
-#endif
             Assert(++argIter == function->arg_end());
         }
 #ifdef ISPC_NVPTX_ENABLED
         if (type->isTask == true && g->target->getISA() == Target::NVPTX) {
             llvm::NamedMDNode *annotations = m->module->getOrInsertNamedMetadata("nvvm.annotations");
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
             llvm::SmallVector<llvm::Metadata *, 3> av;
             av.push_back(llvm::ValueAsMetadata::get(function));
             av.push_back(llvm::MDString::get(*g->ctx, "kernel"));
             av.push_back(llvm::ConstantAsMetadata::get(LLVMInt32(1)));
             annotations->addOperand(llvm::MDNode::get(*g->ctx, llvm::ArrayRef<llvm::Metadata *>(av)));
-#else
-            llvm::SmallVector<llvm::Value *, 3> av;
-            av.push_back(function);
-            av.push_back(llvm::MDString::get(*g->ctx, "kernel"));
-            av.push_back(LLVMInt32(1));
-            annotations->addOperand(llvm::MDNode::get(*g->ctx, av));
-#endif
         }
 #endif /* ISPC_NVPTX_ENABLED */
     }
@@ -394,18 +345,10 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
         // entire thing inside code that tests to see if the mask is all
         // on, all off, or mixed.  If this is a simple function, then this
         // isn't worth the code bloat / overhead.
-        bool checkMask = (type->isTask == true) ||
-                         (
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2 // 3.2
-                             (function->getFnAttributes().hasAttribute(llvm::Attributes::AlwaysInline) == false)
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-                             (function->getAttributes().getFnAttributes().hasAttribute(
-                                  llvm::AttributeSet::FunctionIndex, llvm::Attribute::AlwaysInline) == false)
-#else // LLVM 5.0+
-                             (function->getAttributes().getFnAttributes().hasAttribute(llvm::Attribute::AlwaysInline) ==
-                              false)
-#endif
-                             && costEstimate > CHECK_MASK_AT_FUNCTION_START_COST);
+        bool checkMask =
+            (type->isTask == true) ||
+            ((function->getAttributes().getFnAttributes().hasAttribute(llvm::Attribute::AlwaysInline) == false) &&
+             costEstimate > CHECK_MASK_AT_FUNCTION_START_COST);
         checkMask &= (type->isUnmasked == false);
         checkMask &= (g->target->getMaskingIsFree() == false);
         checkMask &= (g->opt.disableCoherentControlFlow == false);
@@ -557,22 +500,11 @@ void Function::GenerateIR() {
                 llvm::Function *appFunction = llvm::Function::Create(ftype, linkage, functionName.c_str(), m->module);
                 appFunction->setDoesNotThrow();
 
-#if ISPC_LLVM_VERSION < ISPC_LLVM_5_0
-                // We should iterate from 1 because zero parameter is return.
-                // We should iterate till getNumParams instead of getNumParams+1 because new
-                // function is export function and doesn't contain the last parameter "mask".
-                for (int i = 1; i < function->getFunctionType()->getNumParams(); i++) {
-                    if (function->doesNotAlias(i)) {
-                        appFunction->setDoesNotAlias(i);
-                    }
-                }
-#else // LLVM 5.0+
                 for (int i = 0; i < function->getFunctionType()->getNumParams() - 1; i++) {
                     if (function->hasParamAttribute(i, llvm::Attribute::NoAlias)) {
                         appFunction->addParamAttr(i, llvm::Attribute::NoAlias);
                     }
                 }
-#endif
                 g->target->markFuncWithTargetAttr(appFunction);
 
                 if (appFunction->getName() != functionName) {
@@ -589,7 +521,6 @@ void Function::GenerateIR() {
 #ifdef ISPC_NVPTX_ENABLED
                     if (g->target->getISA() == Target::NVPTX) {
                         llvm::NamedMDNode *annotations = m->module->getOrInsertNamedMetadata("nvvm.annotations");
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
 
                         llvm::SmallVector<llvm::Metadata *, 3> av;
                         av.push_back(llvm::ValueAsMetadata::get(appFunction));
@@ -597,13 +528,6 @@ void Function::GenerateIR() {
                         av.push_back(llvm::ConstantAsMetadata::get(
                             llvm::ConstantInt::get(llvm::IntegerType::get(*g->ctx, 32), 1)));
                         annotations->addOperand(llvm::MDNode::get(*g->ctx, llvm::ArrayRef<llvm::Metadata *>(av)));
-#else
-                        llvm::SmallVector<llvm::Value *, 3> av;
-                        av.push_back(appFunction);
-                        av.push_back(llvm::MDString::get(*g->ctx, "kernel"));
-                        av.push_back(llvm::ConstantInt::get(llvm::IntegerType::get(*g->ctx, 32), 1));
-                        annotations->addOperand(llvm::MDNode::get(*g->ctx, av));
-#endif
                     }
 #endif /* ISPC_NVPTX_ENABLED */
                 }
diff --git a/src/ispc.cpp b/src/ispc.cpp
index 465b2e93..3cf5d888 100644
--- a/src/ispc.cpp
+++ b/src/ispc.cpp
@@ -46,57 +46,28 @@
 #include <direct.h>
 #include <windows.h>
 #define strcasecmp stricmp
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_7_0
 #include <intrin.h>
-#endif
 #else
 #include <sys/types.h>
 #include <unistd.h>
 #endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/Instructions.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Module.h>
-#else /* 3.3+ */
-#include <llvm/IR/Instructions.h>
-#include <llvm/IR/LLVMContext.h>
-#include <llvm/IR/Module.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_6_0
 #include <llvm/CodeGen/TargetLowering.h>
 #include <llvm/CodeGen/TargetSubtargetInfo.h>
-#else
-#include <llvm/Target/TargetSubtargetInfo.h>
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
-#include <llvm/Target/TargetLowering.h>
-#endif
-#endif
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
 #include <llvm/IR/DIBuilder.h>
 #include <llvm/IR/DebugInfo.h>
-#else // LLVM 3.2, 3.3, 3.4
-#include <llvm/DIBuilder.h>
-#include <llvm/DebugInfo.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_5_0 // LLVM 5.0+
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/Module.h>
+
 #include <llvm/BinaryFormat/Dwarf.h>
-#else // LLVM up to 4.x
-#include <llvm/Support/Dwarf.h>
-#endif
-#include <llvm/Target/TargetMachine.h>
-#include <llvm/Target/TargetOptions.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/DataLayout.h>
-#else // LLVM 3.3+
 #include <llvm/IR/Attributes.h>
 #include <llvm/IR/DataLayout.h>
-#endif
 #include <llvm/Support/CodeGen.h>
 #include <llvm/Support/Host.h>
 #include <llvm/Support/TargetRegistry.h>
 #include <llvm/Support/TargetSelect.h>
+#include <llvm/Target/TargetMachine.h>
+#include <llvm/Target/TargetOptions.h>
 
 Globals *g;
 Module *m;
@@ -266,21 +237,15 @@ typedef enum {
     // Haswell. Supports AVX 2.
     CPU_Haswell,
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
     // Broadwell. Supports AVX 2 + ADX/RDSEED/SMAP.
     CPU_Broadwell,
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
     // Knights Landing - Xeon Phi.
     // Supports AVX-512F: All the key AVX-512 features: masking, broadcast... ;
     //          AVX-512CDI: Conflict Detection;
     //          AVX-512ERI & PRI: 28-bit precision RCP, RSQRT and EXP transcendentals,
     //                            new prefetch instructions.
     CPU_KNL,
-#endif
-
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
     // Skylake Xeon.
     // Supports AVX-512F: All the key AVX-512 features: masking, broadcast... ;
     //          AVX-512CDI: Conflict Detection;
@@ -288,17 +253,14 @@ typedef enum {
     //          AVX-512DQ: New HPC ISA (vs AVX512F);
     //          AVX-512BW: Byte and Word Support.
     CPU_SKX,
-#endif
 
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_8_0
     // Icelake client
     CPU_ICL,
 #endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4 // LLVM 3.4+
     // Late Atom-like design. Supports SSE 4.2 + POPCNT/LZCNT.
     CPU_Silvermont,
-#endif
 
 // FIXME: LLVM supports a ton of different ARM CPU variants--not just
 // cortex-a9 and a15.  We should be able to handle any of them that also
@@ -360,10 +322,8 @@ class AllCPUs {
 
         names[CPU_Penryn].push_back("penryn");
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4 // LLVM 3.4+
         names[CPU_Silvermont].push_back("slm");
         names[CPU_Silvermont].push_back("silvermont");
-#endif
 
         names[CPU_Nehalem].push_back("corei7");
         names[CPU_Nehalem].push_back("nehalem");
@@ -380,17 +340,11 @@ class AllCPUs {
         names[CPU_Haswell].push_back("core-avx2");
         names[CPU_Haswell].push_back("haswell");
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6 // LLVM 3.6+
         names[CPU_Broadwell].push_back("broadwell");
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
         names[CPU_KNL].push_back("knl");
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
         names[CPU_SKX].push_back("skx");
-#endif
 
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_8_0 // LLVM 8.0+
         names[CPU_ICL].push_back("icl");
@@ -414,22 +368,14 @@ class AllCPUs {
 #endif
         Assert(names.size() == sizeofCPUtype);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3 // LLVM 3.2 or 3.3
-#define CPU_Silvermont CPU_Nehalem
-#else /* LLVM 3.4+ */
         compat[CPU_Silvermont] =
             Set(CPU_Generic, CPU_x86_64, CPU_Bonnell, CPU_Penryn, CPU_Core2, CPU_Nehalem, CPU_Silvermont, CPU_None);
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
         compat[CPU_KNL] = Set(CPU_KNL, CPU_Generic, CPU_x86_64, CPU_Bonnell, CPU_Penryn, CPU_Core2, CPU_Nehalem,
                               CPU_Silvermont, CPU_SandyBridge, CPU_IvyBridge, CPU_Haswell, CPU_Broadwell, CPU_None);
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
         compat[CPU_SKX] = Set(CPU_SKX, CPU_x86_64, CPU_Bonnell, CPU_Penryn, CPU_Core2, CPU_Nehalem, CPU_Silvermont,
                               CPU_SandyBridge, CPU_IvyBridge, CPU_Haswell, CPU_Broadwell, CPU_None);
-#endif
 
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_8_0 // LLVM 8.0+
         compat[CPU_ICL] = Set(CPU_ICL, CPU_SKX, CPU_x86_64, CPU_Bonnell, CPU_Penryn, CPU_Core2, CPU_Nehalem,
@@ -437,13 +383,9 @@ class AllCPUs {
         ;
 #endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // LLVM 3.2, 3.3, 3.4 or 3.5
-#define CPU_Broadwell CPU_Haswell
-#else /* LLVM 3.6+ */
         compat[CPU_Broadwell] =
             Set(CPU_Generic, CPU_x86_64, CPU_Bonnell, CPU_Penryn, CPU_Core2, CPU_Nehalem, CPU_Silvermont,
                 CPU_SandyBridge, CPU_IvyBridge, CPU_Haswell, CPU_Broadwell, CPU_None);
-#endif
         compat[CPU_Haswell] = Set(CPU_Generic, CPU_x86_64, CPU_Bonnell, CPU_Penryn, CPU_Core2, CPU_Nehalem,
                                   CPU_Silvermont, CPU_SandyBridge, CPU_IvyBridge, CPU_Haswell, CPU_Broadwell, CPU_None);
         compat[CPU_IvyBridge] = Set(CPU_Generic, CPU_x86_64, CPU_Bonnell, CPU_Penryn, CPU_Core2, CPU_Nehalem,
@@ -517,13 +459,10 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
                std::string genericAsSmth)
     : m_target(NULL), m_targetMachine(NULL), m_dataLayout(NULL), m_valid(false), m_isa(SSE2),
       m_treatGenericAsSmth(genericAsSmth), m_arch(""), m_is32Bit(true), m_cpu(""), m_attributes(""),
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3
-      m_tf_attributes(NULL),
-#endif
-      m_nativeVectorWidth(-1), m_nativeVectorAlignment(-1), m_dataTypeWidth(-1), m_vectorWidth(-1), m_generatePIC(pic),
-      m_maskingIsFree(false), m_maskBitCount(-1), m_hasHalf(false), m_hasRand(false), m_hasGather(false),
-      m_hasScatter(false), m_hasTranscendentals(false), m_hasTrigonometry(false), m_hasRsqrtd(false), m_hasRcpd(false),
-      m_hasVecPrefetch(false) {
+      m_tf_attributes(NULL), m_nativeVectorWidth(-1), m_nativeVectorAlignment(-1), m_dataTypeWidth(-1),
+      m_vectorWidth(-1), m_generatePIC(pic), m_maskingIsFree(false), m_maskBitCount(-1), m_hasHalf(false),
+      m_hasRand(false), m_hasGather(false), m_hasScatter(false), m_hasTranscendentals(false), m_hasTrigonometry(false),
+      m_hasRsqrtd(false), m_hasRcpd(false), m_hasVecPrefetch(false) {
     CPUtype CPUID = CPU_None, CPUfromISA = CPU_None;
     AllCPUs a;
     std::string featuresString;
@@ -573,24 +512,18 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
             break;
 #endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
         case CPU_KNL:
             isa = "avx512knl-i32x16";
             break;
-#endif
 
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_8_0 // LLVM 8.0
         case CPU_ICL:
 #endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
         case CPU_SKX:
             isa = "avx512skx-i32x16";
             break;
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6
         case CPU_Broadwell:
-#endif
         case CPU_Haswell:
             isa = "avx2-i32x8";
             break;
@@ -607,9 +540,7 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
         // Penryn is here because ISPC does not use SSE 4.2
         case CPU_Penryn:
         case CPU_Nehalem:
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4
         case CPU_Silvermont:
-#endif
             isa = "sse4-i32x4";
             break;
 
@@ -654,13 +585,8 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
 
     // Make sure the target architecture is a known one; print an error
     // with the valid ones otherwise.
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
     for (llvm::TargetRegistry::iterator iter = llvm::TargetRegistry::targets().begin();
          iter != llvm::TargetRegistry::targets().end(); ++iter) {
-#else
-    for (llvm::TargetRegistry::iterator iter = llvm::TargetRegistry::begin(); iter != llvm::TargetRegistry::end();
-         ++iter) {
-#endif
         if (std::string(arch) == iter->getName()) {
             this->m_target = &*iter;
             break;
@@ -669,11 +595,7 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
     if (this->m_target == NULL) {
         fprintf(stderr, "Invalid architecture \"%s\"\nOptions: ", arch);
         llvm::TargetRegistry::iterator iter;
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
         for (iter = llvm::TargetRegistry::targets().begin(); iter != llvm::TargetRegistry::targets().end(); ++iter)
-#else
-        for (iter = llvm::TargetRegistry::begin(); iter != llvm::TargetRegistry::end(); ++iter)
-#endif
             fprintf(stderr, "%s ", iter->getName());
         fprintf(stderr, "\n");
         error = true;
@@ -915,9 +837,7 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
         this->m_hasRand = true;
         this->m_hasGather = true;
         CPUfromISA = CPU_Haswell;
-    }
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
-    else if (!strcasecmp(isa, "avx512knl-i32x16")) {
+    } else if (!strcasecmp(isa, "avx512knl-i32x16")) {
         this->m_isa = Target::KNL_AVX512;
         this->m_nativeVectorWidth = 16;
         this->m_nativeVectorAlignment = 64;
@@ -934,10 +854,7 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
         this->m_hasRsqrtd = this->m_hasRcpd = false;
         this->m_hasVecPrefetch = false;
         CPUfromISA = CPU_KNL;
-    }
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
-    else if (!strcasecmp(isa, "avx512skx-i32x16")) {
+    } else if (!strcasecmp(isa, "avx512skx-i32x16")) {
         this->m_isa = Target::SKX_AVX512;
         this->m_nativeVectorWidth = 16;
         this->m_nativeVectorAlignment = 64;
@@ -955,7 +872,6 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
         this->m_hasVecPrefetch = false;
         CPUfromISA = CPU_SKX;
     }
-#endif
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_8_0 // LLVM 8.0+
     else if (!strcasecmp(isa, "avx512skx-i32x8")) {
         this->m_isa = Target::SKX_AVX512;
@@ -1064,14 +980,10 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
         // Create TargetMachine
         std::string triple = GetTripleString();
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_8
-        llvm::Reloc::Model relocModel = m_generatePIC ? llvm::Reloc::PIC_ : llvm::Reloc::Default;
-#else
         llvm::Optional<llvm::Reloc::Model> relocModel;
         if (m_generatePIC) {
             relocModel = llvm::Reloc::PIC_;
         }
-#endif
         llvm::TargetOptions options;
 #ifdef ISPC_ARM_ENABLED
         if (m_isa == Target::NEON8 || m_isa == Target::NEON16 || m_isa == Target::NEON32)
@@ -1086,17 +998,7 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
 #endif
         if (g->opt.disableFMA == false)
             options.AllowFPOpFusion = llvm::FPOpFusion::Fast;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        if (g->NoOmitFramePointer)
-            options.NoFramePointerElim = true;
-#ifdef ISPC_HOST_IS_WINDOWS
-        if (strcmp("x86", arch) == 0) {
-            // Workaround for issue #503 (LLVM issue 14646).
-            // It's Win32 specific.
-            options.NoFramePointerElim = true;
-        }
-#endif
-#endif
+
         m_targetMachine = m_target->createTargetMachine(triple, m_cpu, featuresString, options, relocModel);
         Assert(m_targetMachine != NULL);
 
@@ -1116,29 +1018,17 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
         }
         m_targetMachine->setOptLevel(cOptLevel);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        m_targetMachine->setAsmVerbosityDefault(true);
-#else /* LLVM 3.7+ */
         m_targetMachine->Options.MCOptions.AsmVerbose = true;
-#endif
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
         // Change default version of generated DWARF.
         if (g->generateDWARFVersion != 0) {
             m_targetMachine->Options.MCOptions.DwarfVersion = g->generateDWARFVersion;
         }
-#endif
 
         // Initialize TargetData/DataLayout in 3 steps.
         // 1. Get default data layout first
         std::string dl_string;
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_6
-        dl_string = m_targetMachine->getSubtargetImpl()->getDataLayout()->getStringRepresentation();
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
         dl_string = m_targetMachine->createDataLayout().getStringRepresentation();
-#else                                    // LLVM 3.5- or LLVM 3.7
-    dl_string = m_targetMachine->getDataLayout()->getStringRepresentation();
-#endif
         // 2. Adjust for generic
         if (m_isa == Target::GENERIC) {
             // <16 x i1> vectors only need 16 bit / 2 byte alignment, so add
@@ -1175,12 +1065,7 @@ Target::Target(const char *arch, const char *cpu, const char *isa, bool pic, boo
 #endif
         for (auto const &f_attr : m_funcAttributes)
             fattrBuilder.addAttribute(f_attr.first, f_attr.second);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        this->m_tf_attributes =
-            new llvm::AttributeSet(llvm::AttributeSet::get(*g->ctx, llvm::AttributeSet::FunctionIndex, fattrBuilder));
-#else // LLVM 5.0+
         this->m_tf_attributes = new llvm::AttrBuilder(fattrBuilder);
-#endif
 
         Assert(this->m_vectorWidth <= ISPC_MAX_NVEC);
     }
@@ -1215,12 +1100,8 @@ const char *Target::SupportedTargets() {
            "avx1-i32x4, "
            "avx1-i32x8, avx1-i32x16, avx1-i64x4, "
            "avx2-i32x4, avx2-i32x8, avx2-i32x16, avx2-i64x4, "
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
            "avx512knl-i32x16, "
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
            "avx512skx-i32x16, "
-#endif
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_8_0 // LLVM 8.0+
            "avx512skx-i32x8, "
 #endif
@@ -1379,14 +1260,10 @@ const char *Target::ISAToString(ISA isa) {
         return "avx";
     case Target::AVX2:
         return "avx2";
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
     case Target::KNL_AVX512:
         return "avx512knl";
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
     case Target::SKX_AVX512:
         return "avx512skx";
-#endif
     case Target::GENERIC:
         return "generic";
 #ifdef ISPC_NVPTX_ENABLED
@@ -1422,14 +1299,10 @@ const char *Target::ISAToTargetString(ISA isa) {
         return "avx1-i32x8";
     case Target::AVX2:
         return "avx2-i32x8";
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
     case Target::KNL_AVX512:
         return "avx512knl-i32x16";
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
     case Target::SKX_AVX512:
         return "avx512skx-i32x16";
-#endif
     case Target::GENERIC:
         return "generic-4";
 #ifdef ISPC_NVPTX_ENABLED
@@ -1478,12 +1351,8 @@ llvm::Value *Target::SizeOf(llvm::Type *type, llvm::BasicBlock *insertAtEnd) {
         llvm::PointerType *ptrType = llvm::PointerType::get(type, 0);
         llvm::Value *voidPtr = llvm::ConstantPointerNull::get(ptrType);
         llvm::ArrayRef<llvm::Value *> arrayRef(&index[0], &index[1]);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::Instruction *gep = llvm::GetElementPtrInst::Create(voidPtr, arrayRef, "sizeof_gep", insertAtEnd);
-#else /* LLVM 3.7+ */
         llvm::Instruction *gep =
             llvm::GetElementPtrInst::Create(PTYPE(voidPtr), voidPtr, arrayRef, "sizeof_gep", insertAtEnd);
-#endif
         if (m_is32Bit || g->opt.force32BitAddressing)
             return new llvm::PtrToIntInst(gep, LLVMTypes::Int32Type, "sizeof_int", insertAtEnd);
         else
@@ -1503,12 +1372,8 @@ llvm::Value *Target::StructOffset(llvm::Type *type, int element, llvm::BasicBloc
         llvm::PointerType *ptrType = llvm::PointerType::get(type, 0);
         llvm::Value *voidPtr = llvm::ConstantPointerNull::get(ptrType);
         llvm::ArrayRef<llvm::Value *> arrayRef(&indices[0], &indices[2]);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::Instruction *gep = llvm::GetElementPtrInst::Create(voidPtr, arrayRef, "offset_gep", insertAtEnd);
-#else /* LLVM 3.7+ */
         llvm::Instruction *gep =
             llvm::GetElementPtrInst::Create(PTYPE(voidPtr), voidPtr, arrayRef, "offset_gep", insertAtEnd);
-#endif
         if (m_is32Bit || g->opt.force32BitAddressing)
             return new llvm::PtrToIntInst(gep, LLVMTypes::Int32Type, "offset_int", insertAtEnd);
         else
@@ -1532,15 +1397,9 @@ llvm::Value *Target::StructOffset(llvm::Type *type, int element, llvm::BasicBloc
 }
 
 void Target::markFuncWithTargetAttr(llvm::Function *func) {
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3
     if (m_tf_attributes) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-        func->addAttributes(llvm::AttributeSet::FunctionIndex, *m_tf_attributes);
-#else // LLVM 5.0+
         func->addAttributes(llvm::AttributeList::FunctionIndex, *m_tf_attributes);
-#endif
     }
-#endif
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -1590,9 +1449,7 @@ Globals::Globals() {
     emitInstrumentation = false;
     noPragmaOnce = false;
     generateDebuggingSymbols = false;
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
     generateDWARFVersion = 3;
-#endif
     enableFuzzTest = false;
     fuzzTestSeed = -1;
     mangleFunctionsWithTarget = false;
@@ -1629,21 +1486,12 @@ SourcePos::SourcePos(const char *n, int fl, int fc, int ll, int lc) {
     last_column = lc != 0 ? lc : fc;
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIFile
-#else /* LLVM 3.7+ */
 llvm::DIFile *
 // llvm::MDFile*
-#endif
 SourcePos::GetDIFile() const {
     std::string directory, filename;
     GetDirectoryAndFileName(g->currentDirectory, name, &directory, &filename);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIFile ret = m->diBuilder->createFile(filename, directory);
-    Assert(ret.Verify());
-#else /* LLVM 3.7+ */
     llvm::DIFile *ret = m->diBuilder->createFile(filename, directory);
-#endif
     return ret;
 }
 
diff --git a/src/ispc.h b/src/ispc.h
index 5dcb9b77..42fb9794 100644
--- a/src/ispc.h
+++ b/src/ispc.h
@@ -41,7 +41,7 @@
 #include "ispc_version.h"
 
 #if ISPC_LLVM_VERSION < OLDEST_SUPPORTED_LLVM || ISPC_LLVM_VERSION > LATEST_SUPPORTED_LLVM
-#error "Only LLVM 3.2 - 8.0 and 9.0 development branch are supported"
+#error "Only LLVM 6.0 - 9.0 and 10.0 development branch are supported"
 #endif
 
 #if defined(_WIN32) || defined(_WIN64)
@@ -70,11 +70,8 @@
 
 // Forward declarations of a number of widely-used LLVM types
 namespace llvm {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-class AttributeSet;
-#else // LLVM 5.0+
+
 class AttrBuilder;
-#endif
 class BasicBlock;
 class Constant;
 class ConstantValue;
@@ -90,11 +87,8 @@ class Type;
 class Value;
 class DIFile;
 class DIType;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-class DIDescriptor;
-#else // LLVM 3.7+
+
 class DIScope;
-#endif
 } // namespace llvm
 
 class ArrayType;
@@ -140,13 +134,8 @@ struct SourcePos {
     /** Prints the filename and line/column range to standard output. */
     void Print() const;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    /** Returns a LLVM DIFile object that represents the SourcePos's file */
-    llvm::DIFile GetDIFile() const;
-#else
     /** Returns a LLVM DIFile object that represents the SourcePos's file */
     llvm::DIFile *GetDIFile() const;
-#endif
 
     bool operator==(const SourcePos &p2) const;
 };
@@ -342,16 +331,10 @@ class Target {
     /** Target-specific function attributes */
     std::vector<std::pair<std::string, std::string>> m_funcAttributes;
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3
     /** Target-specific LLVM attribute, which has to be attached to every
         function to ensure that it is generated for correct target architecture.
         This is requirement was introduced in LLVM 3.3 */
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_4_0
-    llvm::AttributeSet *m_tf_attributes;
-#else // LLVM 5.0+
     llvm::AttrBuilder *m_tf_attributes;
-#endif
-#endif
 
     /** Native vector width of the vector instruction set.  Note that this
         value is directly derived from the ISA being used (e.g. it's 4 for
@@ -625,9 +608,7 @@ struct Globals {
     // readelf --debug-dump=info object.o | grep -A 2 'Compilation Unit @'
     // on Mac:
     // xcrun dwarfdump -r0 object.o
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
     int generateDWARFVersion;
-#endif
 
     /** If true, function names are mangled by appending the target ISA and
         vector width to them. */
diff --git a/src/ispc_version.h b/src/ispc_version.h
index 04b1be11..008d15b8 100644
--- a/src/ispc_version.h
+++ b/src/ispc_version.h
@@ -45,16 +45,6 @@
 
 #define ISPC_LLVM_VERSION (LLVM_VERSION_MAJOR * 10000 + LLVM_VERSION_MINOR * 100)
 
-#define ISPC_LLVM_3_2 30200
-#define ISPC_LLVM_3_3 30300
-#define ISPC_LLVM_3_4 30400
-#define ISPC_LLVM_3_5 30500
-#define ISPC_LLVM_3_6 30600
-#define ISPC_LLVM_3_7 30700
-#define ISPC_LLVM_3_8 30800
-#define ISPC_LLVM_3_9 30900
-#define ISPC_LLVM_4_0 40000
-#define ISPC_LLVM_5_0 50000
 #define ISPC_LLVM_6_0 60000
 #define ISPC_LLVM_7_0 70000
 #define ISPC_LLVM_7_1 70100
@@ -62,7 +52,7 @@
 #define ISPC_LLVM_9_0 90000
 #define ISPC_LLVM_10_0 100000
 
-#define OLDEST_SUPPORTED_LLVM ISPC_LLVM_3_2
+#define OLDEST_SUPPORTED_LLVM ISPC_LLVM_6_0
 #define LATEST_SUPPORTED_LLVM ISPC_LLVM_10_0
 
 #ifdef __ispc__xstr
diff --git a/src/llvmutil.cpp b/src/llvmutil.cpp
index c6507e24..1654625c 100644
--- a/src/llvmutil.cpp
+++ b/src/llvmutil.cpp
@@ -38,13 +38,8 @@
 #include "llvmutil.h"
 #include "ispc.h"
 #include "type.h"
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/BasicBlock.h>
-#include <llvm/Instructions.h>
-#else
 #include <llvm/IR/BasicBlock.h>
 #include <llvm/IR/Instructions.h>
-#endif
 #include <map>
 #include <set>
 
@@ -1415,19 +1410,15 @@ static llvm::Value *lExtractFirstVectorElement(llvm::Value *v, std::map<llvm::PH
         if (phiMap.find(phi) != phiMap.end())
             return phiMap[phi];
 
-            // We need to create the new scalar PHI node immediately, though,
-            // and put it in the map<>, so that if we come back to this node
-            // via a recursive lExtractFirstVectorElement() call, then we can
-            // return the pointer and not get stuck in an infinite loop.
-            //
-            // The insertion point for the new phi node also has to be the
-            // start of the bblock of the original phi node.
+        // We need to create the new scalar PHI node immediately, though,
+        // and put it in the map<>, so that if we come back to this node
+        // via a recursive lExtractFirstVectorElement() call, then we can
+        // return the pointer and not get stuck in an infinite loop.
+        //
+        // The insertion point for the new phi node also has to be the
+        // start of the bblock of the original phi node.
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7 /* 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 */
-        llvm::Instruction *phiInsertPos = phi->getParent()->begin();
-#else /* LLVM 3.8+ */
         llvm::Instruction *phiInsertPos = &*(phi->getParent()->begin());
-#endif
         llvm::PHINode *scalarPhi =
             llvm::PHINode::Create(vt->getElementType(), phi->getNumIncomingValues(), newName, phiInsertPos);
         phiMap[phi] = scalarPhi;
diff --git a/src/llvmutil.h b/src/llvmutil.h
index 7a349d9b..d6592800 100644
--- a/src/llvmutil.h
+++ b/src/llvmutil.h
@@ -39,23 +39,13 @@
 #define ISPC_LLVMUTIL_H 1
 
 #include "ispc_version.h"
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/Constants.h>
-#include <llvm/DerivedTypes.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Type.h>
-#else // 3.3+
+
 #include <llvm/IR/Constants.h>
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/LLVMContext.h>
 #include <llvm/IR/Type.h>
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-#define PTYPE(p) (llvm::cast<llvm::SequentialType>((p)->getType()->getScalarType())->getElementType())
-#else // LLVM 4.0+
 #define PTYPE(p) (llvm::cast<llvm::PointerType>((p)->getType()->getScalarType())->getElementType())
-#endif
 
 namespace llvm {
 class PHINode;
diff --git a/src/main.cpp b/src/main.cpp
index 794dce9d..154206dc 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -106,10 +106,8 @@ static void usage(int ret) {
     printf("    [-D<foo>]\t\t\t\t#define given value when running preprocessor\n");
     printf("    [--dev-stub <filename>]\t\tEmit device-side offload stub functions to file\n");
     printf("    [--dllexport]\t\t\tMake non-static functions DLL exported.  Windows target only\n");
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
     printf("    [--dwarf-version={2,3,4}]\t\tGenerate source-level debug information with given DWARF version "
            "(triggers -g).  Ignored for Windows target\n");
-#endif
     printf("    [--emit-asm]\t\t\tGenerate assembly language file as output\n");
     printf("    [--x86-asm-syntax=<option>]\t\tSelect style of code if generating assembly\n");
     printf("        intel\t\t\t\tEmit Intel-style assembly\n");
@@ -199,9 +197,6 @@ static void devUsage(int ret) {
     printf("    [--debug-phase=<value>]\t\tSet optimization phases to dump. "
            "--debug-phase=first,210:220,300,305,310:last\n");
     printf("    [--dump-file]\t\t\tDump module IR to file(s) in current directory\n");
-#endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_4 || ISPC_LLVM_VERSION == ISPC_LLVM_3_5 // 3.4, 3.5
-    printf("    [--debug-ir=<value>]\t\tSet optimization phase to generate debugIR after it\n");
 #endif
     printf("    [--off-phase=<value>]\t\tSwitch off optimization phases. --off-phase=first,210:220,300,305,310:last\n");
     exit(ret);
@@ -539,7 +534,6 @@ int main(int Argc, char *Argv[]) {
             llvm::DebugFlag = true;
         else if (!strcmp(argv[i], "--dllexport"))
             g->dllExport = true;
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
         else if (!strncmp(argv[i], "--dwarf-version=", 16)) {
             int val = atoi(argv[i] + 16);
             if (2 <= val && val <= 4) {
@@ -552,9 +546,7 @@ int main(int Argc, char *Argv[]) {
                         argv[i] + 16);
                 usage(1);
             }
-        }
-#endif
-        else if (!strcmp(argv[i], "--print-target"))
+        } else if (!strcmp(argv[i], "--print-target"))
             g->printTarget = true;
         else if (!strcmp(argv[i], "--no-omit-frame-pointer"))
             g->NoOmitFramePointer = true;
@@ -758,11 +750,6 @@ int main(int Argc, char *Argv[]) {
             g->dumpFile = true;
 #endif
 
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_4 || ISPC_LLVM_VERSION == ISPC_LLVM_3_5 // 3.4, 3.5
-        else if (strncmp(argv[i], "--debug-ir=", 11) == 0) {
-            g->debugIR = ParsingPhaseName(argv[i] + strlen("--debug-ir="));
-        }
-#endif
         else if (strncmp(argv[i], "--off-phase=", 12) == 0) {
             g->off_stages = ParsingPhases(argv[i] + strlen("--off-phase="));
         } else if (!strcmp(argv[i], "-v") || !strcmp(argv[i], "--version")) {
diff --git a/src/module.cpp b/src/module.cpp
index 1be5ca45..05b0dcc6 100644
--- a/src/module.cpp
+++ b/src/module.cpp
@@ -66,17 +66,6 @@
 #include <windows.h>
 #define strcasecmp stricmp
 #endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/DerivedTypes.h>
-#include <llvm/Instructions.h>
-#include <llvm/Intrinsics.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Module.h>
-#include <llvm/Type.h>
-#ifdef ISPC_NVPTX_ENABLED
-#include "llvm/Assembly/AssemblyAnnotationWriter.h"
-#endif /* ISPC_NVPTX_ENABLED */
-#else
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/Instructions.h>
 #include <llvm/IR/Intrinsics.h>
@@ -84,42 +73,21 @@
 #include <llvm/IR/Module.h>
 #include <llvm/IR/Type.h>
 #ifdef ISPC_NVPTX_ENABLED
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 /* 3.5+ */
 #include <llvm/IR/AssemblyAnnotationWriter.h>
-#else
-#include <llvm/Assembly/AssemblyAnnotationWriter.h>
-#endif
 #endif /* ISPC_NVPTX_ENABLED */
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-#include "llvm/PassManager.h"
-#else // LLVM 3.7+
 #include "llvm/IR/LegacyPassManager.h"
-#endif
 #include <llvm/PassRegistry.h>
 #include <llvm/Support/FileUtilities.h>
 #include <llvm/Support/FormattedStream.h>
 #include <llvm/Target/TargetMachine.h>
 #include <llvm/Target/TargetOptions.h>
 #include <llvm/Transforms/IPO.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/DataLayout.h>
-#include <llvm/TargetTransformInfo.h>
-#else // LLVM 3.3+
 #include <llvm/Analysis/TargetTransformInfo.h>
 #include <llvm/IR/DataLayout.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
 #include <llvm/IR/CFG.h>
 #include <llvm/IR/IRPrintingPasses.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/Verifier.h>
-#else
-#include <llvm/Analysis/Verifier.h>
-#include <llvm/Assembly/PrintModulePass.h>
-#include <llvm/Support/CFG.h>
-#include <llvm/Support/InstIterator.h>
-#endif
 #include <clang/Basic/TargetInfo.h>
 #include <clang/Frontend/CompilerInstance.h>
 #include <clang/Frontend/TextDiagnosticPrinter.h>
@@ -128,11 +96,7 @@
 #include <llvm/Support/Host.h>
 #include <llvm/Support/ToolOutputFile.h>
 #include <llvm/Support/raw_ostream.h>
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-#include <llvm/Bitcode/ReaderWriter.h>
-#else
 #include <llvm/Bitcode/BitcodeWriter.h>
-#endif
 
 /*! list of files encountered by the parser. this allows emitting of
     the module file's dependencies via the -MMM option */
@@ -166,208 +130,7 @@ static void lDeclareSizeAndPtrIntTypes(SymbolTable *symbolTable) {
     and tries to strip out all of this extra stuff.
  */
 static void lStripUnusedDebugInfo(llvm::Module *module) {
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_9
-    // In LLVM 3.9 Global DCE is much more efficient than the LLVM 3.8's one.
-    // So, the fruitfulness of this function is negligible.
     return;
-#else
-    if (g->generateDebuggingSymbols == false)
-        return;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // <= 3.5
-    std::set<llvm::Value *> SPall;
-#else                                  // LLVM 3.6+
-    std::set<llvm::Metadata *> SPall;
-#endif
-    // OK, now we are to determine which functions actually survived the
-    // optimization. We will now read all IR instructions in the module.
-    //
-    // for every function in the module
-    for (llvm::Module::const_iterator f = module->begin(), fe = module->end(); f != fe; ++f) {
-        /// for every instruction in the function
-        for (llvm::const_inst_iterator i = llvm::inst_begin(&(*f)), ie = llvm::inst_end(&(*f)); i != ie; ++i) {
-            const llvm::Instruction *inst = &(*i);
-            // get the instruction`s debugging metadata
-            llvm::MDNode *node = inst->getMetadata(llvm::LLVMContext::MD_dbg);
-            while (node) {
-                // get the scope of the current instruction`s location
-                // node becomes NULL if this was the original location
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6 // <= 3.6
-                llvm::DILocation dloc(node);
-                llvm::DIScope scope = dloc.getScope();
-                node = dloc.getOrigLocation();
-                // now following a chain of nested scopes
-                while (!0) {
-                    if (scope.isLexicalBlockFile())
-                        scope = llvm::DILexicalBlockFile(scope).getScope();
-                    else if (scope.isLexicalBlock())
-                        scope = llvm::DILexicalBlock(scope).getContext();
-                    else if (scope.isNameSpace())
-                        scope = llvm::DINameSpace(scope).getContext();
-                    else
-                        break;
-                }
-                if (scope.isSubprogram()) {
-#else                                  // LLVM 3.7+
-                llvm::DILocation *dloc = llvm::cast<llvm::DILocation>(node);
-                llvm::DIScope *scope = dloc->getScope();
-                // llvm::MDLocation *dloc = llvm::cast<llvm::MDLocation>(node);
-                // llvm::MDScope *scope = dloc->getScope();
-                node = dloc->getInlinedAt();
-                // now following a chain of nested scopes
-                while (!0) {
-                    if (llvm::isa<llvm::DILexicalBlockFile>(scope))
-                        scope = llvm::cast<llvm::DILexicalBlockFile>(scope)->getScope();
-                    else if (llvm::isa<llvm::DILexicalBlockBase>(scope))
-                        scope = llvm::cast<llvm::DILexicalBlockBase>(scope)->getScope();
-                    else if (llvm::isa<llvm::DINamespace>(scope))
-                        scope = llvm::cast<llvm::DINamespace>(scope)->getScope();
-                    else
-                        break;
-                }
-                if (llvm::isa<llvm::DISubprogram>(scope)) {
-#endif
-                    // good, the chain ended with a function; adding
-                    SPall.insert(scope);
-                }
-            }
-        }
-    }
-    // loop over the compile units that contributed to the final module
-    if (llvm::NamedMDNode *cuNodes = module->getNamedMetadata("llvm.dbg.cu")) {
-        for (unsigned i = 0, ie = cuNodes->getNumOperands(); i != ie; ++i) {
-            llvm::MDNode *cuNode = cuNodes->getOperand(i);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-            llvm::DICompileUnit cu(cuNode);
-            llvm::DIArray subprograms = cu.getSubprograms();
-            if (subprograms.getNumElements() == 0) {
-#else /* LLVM 3.7+ */
-            llvm::DICompileUnit *cu = llvm::cast<llvm::DICompileUnit>(cuNode);
-            llvm::DISubprogramArray subprograms = cu->getSubprograms();
-            // llvm::MDCompileUnit *cu = llvm::cast<llvm::MDCompileUnit>(cuNode);
-            // llvm::MDSubprogramArray subprograms = cu->getSubprograms();
-            if (subprograms.size() == 0) {
-#endif
-                continue;
-            }
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-            std::set<llvm::Value *> SPset;
-            std::vector<llvm::Value *> usedSubprograms;
-#else /* LLVM 3.6+ */
-            std::set<llvm::Metadata *> SPset;
-            std::vector<llvm::Metadata *> usedSubprograms;
-#endif
-
-            // determine what functions of those extracted belong to the unit
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-            for (unsigned j = 0, je = subprograms.getNumElements(); j != je; ++j)
-#else /* LLVM 3.7+ */
-            for (unsigned j = 0, je = subprograms.size(); j != je; ++j)
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-                SPset.insert(subprograms->getOperand(j));
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_6
-                SPset.insert(subprograms.getElement(j));
-#else // LLVM 3.7+
-    SPset.insert(subprograms[j]);
-#endif
-
-            std::set_intersection(SPall.begin(), SPall.end(), SPset.begin(), SPset.end(),
-                                  std::back_inserter(usedSubprograms));
-
-            Debug(SourcePos(),
-                  "%d / %d functions left in module with debug "
-                  "info.",
-                  (int)usedSubprograms.size(),
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-                  (int)subprograms.getNumElements());
-#else /* LLVM 3.7+ */
-                  (int)subprograms.size());
-#endif
-
-            // We'd now like to replace the array of subprograms in the
-            // compile unit with only the ones that actually have function
-            // definitions present.  Unfortunately, llvm::DICompileUnit
-            // doesn't provide a method to set the subprograms.  Therefore,
-            // we end up needing to directly stuff a new array into the
-            // appropriate slot (number 12) in the MDNode for the compile
-            // unit.
-            //
-            // Because this is all so hard-coded and would break if the
-            // debugging metadata organization on the LLVM side changed,
-            // here is a bunch of asserting to make sure that element 12 of
-            // the compile unit's MDNode has the subprograms array....
-            //
-            // Update: This is not an approved way of working with debug info
-            // metadata. It's not supposed to be deleted. But in out use-case
-            // it's quite useful thing, as we link in bunch of unnecessary
-            // stuff and remove it later on. Removing it is useful, as it
-            // reduces size of the binary significantly (manyfold for small
-            // programs).
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2   // 3.2
-            llvm::MDNode *nodeSPMD = llvm::dyn_cast<llvm::MDNode>(cuNode->getOperand(12));
-            Assert(nodeSPMD != NULL);
-            llvm::MDNode *nodeSPMDArray = llvm::dyn_cast<llvm::MDNode>(nodeSPMD->getOperand(0));
-            llvm::DIArray nodeSPs(nodeSPMDArray);
-            Assert(nodeSPs.getNumElements() == subprograms.getNumElements());
-            for (int i = 0; i < (int)nodeSPs.getNumElements(); ++i)
-                Assert(nodeSPs.getElement(i) == subprograms.getElement(i));
-
-            // And now we can go and stuff it into the node with some
-            // confidence...
-            llvm::Value *usedSubprogramsArray =
-                m->diBuilder->getOrCreateArray(llvm::ArrayRef<llvm::Value *>(usedSubprograms));
-            llvm::MDNode *replNode = llvm::MDNode::get(*g->ctx, llvm::ArrayRef<llvm::Value *>(usedSubprogramsArray));
-            cuNode->replaceOperandWith(12, replNode);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // 3.3, 3.4, 3.5
-            llvm::MDNode *nodeSPMDArray = llvm::dyn_cast<llvm::MDNode>(cuNode->getOperand(9));
-            Assert(nodeSPMDArray != NULL);
-            llvm::DIArray nodeSPs(nodeSPMDArray);
-            Assert(nodeSPs.getNumElements() == subprograms.getNumElements());
-            for (int i = 0; i < (int)nodeSPs.getNumElements(); ++i)
-                Assert(nodeSPs.getElement(i) == subprograms.getElement(i));
-
-            // And now we can go and stuff it into the node with some
-            // confidence...
-            llvm::MDNode *replNode = m->diBuilder->getOrCreateArray(llvm::ArrayRef<llvm::Value *>(usedSubprograms));
-            cuNode->replaceOperandWith(9, replNode);
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_6 // 3.6
-            llvm::DIArray nodeSPs = cu.getSubprograms();
-            Assert(nodeSPs.getNumElements() == subprograms.getNumElements());
-            for (int i = 0; i < (int)nodeSPs.getNumElements(); ++i)
-                 Assert(nodeSPs.getElement(i) == subprograms.getElement(i));
-
-            // And now we can go and stuff it into the unit with some
-            // confidence...
-            llvm::MDNode *replNode = llvm::MDNode::get(module->getContext(),
-                                                       llvm::ArrayRef<llvm::Metadata *>(usedSubprograms));
-            cu.replaceSubprograms(llvm::DIArray(replNode));
-#else                                    // LLVM 3.7+
-            llvm::DISubprogramArray nodeSPs = cu->getSubprograms();
-            //llvm::MDSubprogramArray nodeSPs = cu->getSubprograms();
-            Assert(nodeSPs.size() == subprograms.size());
-            for (int i = 0; i < (int)nodeSPs.size(); ++i)
-                 Assert(nodeSPs [i] == subprograms [i]);
-
-            // And now we can go and stuff it into the unit with some
-            // confidence...
-            cu->replaceSubprograms(llvm::MDTuple::get(cu->getContext(),
-                                                      llvm::ArrayRef<llvm::Metadata *>(usedSubprograms)));
-#endif
-        }
-    }
-
-    // Also, erase a bunch of named metadata detrius; for each function
-    // there is sometimes named metadata llvm.dbg.lv.{funcname} that
-    // doesn't seem to be otherwise needed.
-    std::vector<llvm::NamedMDNode *> toErase;
-    llvm::Module::named_metadata_iterator iter = module->named_metadata_begin();
-    for (; iter != module->named_metadata_end(); ++iter) {
-        if (!strncmp(iter->getName().str().c_str(), "llvm.dbg.lv", 11))
-            toErase.push_back(&*iter);
-    }
-    for (int i = 0; i < (int)toErase.size(); ++i)
-        module->eraseNamedMetadata(toErase[i]);
-#endif
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -394,7 +157,6 @@ Module::Module(const char *fn) {
     module->setDataLayout(g->target->getDataLayout()->getStringRepresentation());
 
     if (g->generateDebuggingSymbols) {
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8
         // To enable debug information on Windows, we have to let llvm know, that
         // debug information should be emitted in CodeView format.
         if (g->target_os == OS_WINDOWS) {
@@ -402,7 +164,6 @@ Module::Module(const char *fn) {
         } else {
             module->addModuleFlag(llvm::Module::Warning, "Dwarf Version", g->generateDWARFVersion);
         }
-#endif
         diBuilder = new llvm::DIBuilder(*module);
 
         // Let the DIBuilder know that we're starting a new compilation
@@ -425,22 +186,6 @@ Module::Module(const char *fn) {
 #else
             snprintf(producerString, sizeof(producerString), "ispc version %s (built on %s)", ISPC_VERSION, __DATE__);
 #endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3
-            diBuilder->createCompileUnit(llvm::dwarf::DW_LANG_C99,                  /* lang */
-                                         name,                                      /* filename */
-                                         directory,                                 /* directory */
-                                         producerString,                            /* producer */
-                                         g->opt.level > 0 /* is optimized */, "-g", /* command line args */
-                                         0 /* run time version */);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // LLVM 3.4-3.9
-            diCompileUnit =
-                diBuilder->createCompileUnit(llvm::dwarf::DW_LANG_C99,                  /* lang */
-                                             name,                                      /* filename */
-                                             directory,                                 /* directory */
-                                             producerString,                            /* producer */
-                                             g->opt.level > 0 /* is optimized */, "-g", /* command line args */
-                                             0 /* run time version */);
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_4_0 // LLVM 4.0+
             auto srcFile = diBuilder->createFile(name, directory);
             diCompileUnit =
                 diBuilder->createCompileUnit(llvm::dwarf::DW_LANG_C99,                  /* lang */
@@ -448,7 +193,6 @@ Module::Module(const char *fn) {
                                              producerString,                            /* producer */
                                              g->opt.level > 0 /* is optimized */, "-g", /* command line args */
                                              0 /* run time version */);
-#endif
         }
     } else
         diBuilder = NULL;
@@ -510,11 +254,9 @@ int Module::CompileFile() {
         fclose(f);
     }
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
     if (g->NoOmitFramePointer)
         for (llvm::Function &f : *module)
             f.addFnAttr("no-frame-pointer-elim", "true");
-#endif
     for (llvm::Function &f : *module)
         g->target->markFuncWithTargetAttr(&f);
     ast->GenerateIR();
@@ -714,25 +456,6 @@ void Module::AddGlobalVariable(const std::string &name, const Type *type, Expr *
     }
 
     if (diBuilder) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5 // 3.2, 3.3, 3.4, 3.5
-        llvm::DIFile file = pos.GetDIFile();
-        llvm::DIGlobalVariable var = diBuilder->createGlobalVariable(
-            name, file, pos.first_line, sym->type->GetDIType(file), (sym->storageClass == SC_STATIC), sym->storagePtr);
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_6                                       // 3.6
-        llvm::DIFile file = pos.GetDIFile();
-        llvm::Constant *sym_const_storagePtr = llvm::dyn_cast<llvm::Constant>(sym->storagePtr);
-        Assert(sym_const_storagePtr);
-        llvm::DIGlobalVariable var =
-            diBuilder->createGlobalVariable(file, name, name, file, pos.first_line, sym->type->GetDIType(file),
-                                            (sym->storageClass == SC_STATIC), sym_const_storagePtr);
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_9 // LLVM 3.7 - 3.9
-        llvm::DIFile *file = pos.GetDIFile();
-        // llvm::MDFile *file = pos.GetDIFile();
-        llvm::Constant *sym_const_storagePtr = llvm::dyn_cast<llvm::Constant>(sym->storagePtr);
-        Assert(sym_const_storagePtr);
-        diBuilder->createGlobalVariable(file, name, name, file, pos.first_line, sym->type->GetDIType(file),
-                                        (sym->storageClass == SC_STATIC), sym_const_storagePtr);
-#else                                                                          // LLVM 4.0+
         llvm::DIFile *file = pos.GetDIFile();
         // llvm::MDFile *file = pos.GetDIFile();
         llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storagePtr);
@@ -740,12 +463,11 @@ void Module::AddGlobalVariable(const std::string &name, const Type *type, Expr *
         llvm::DIGlobalVariableExpression *var = diBuilder->createGlobalVariableExpression(
             file, name, name, file, pos.first_line, sym->type->GetDIType(file), (sym->storageClass == SC_STATIC));
         sym_GV_storagePtr->addDebugInfo(var);
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
+/*#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
         Assert(var.Verify());
 #else // LLVM 3.7+
       // comming soon
-#endif
+#endif*/
     }
 }
 
@@ -997,19 +720,13 @@ void Module::AddFunctionDeclaration(const std::string &name, const FunctionType
     }
     // Set function attributes: we never throw exceptions
     function->setDoesNotThrow();
-    if (storageClass != SC_EXTERN_C && isInline)
-#ifdef LLVM_3_2
-        function->addFnAttr(llvm::Attributes::AlwaysInline);
-#else // LLVM 3.3+
+    if (storageClass != SC_EXTERN_C && isInline) {
         function->addFnAttr(llvm::Attribute::AlwaysInline);
-#endif
+    }
 
-    if (isNoInline)
-#ifdef LLVM_3_2
-        function->addFnAttr(llvm::Attributes::NoInline);
-#else // LLVM 3.3+
+    if (isNoInline) {
         function->addFnAttr(llvm::Attribute::NoInline);
-#endif
+    }
 
     if (functionType->isTask) {
 #ifdef ISPC_NVPTX_ENABLED
@@ -1017,11 +733,7 @@ void Module::AddFunctionDeclaration(const std::string &name, const FunctionType
         if (g->target->getISA() != Target::NVPTX)
 #endif  /* ISPC_NVPTX_ENABLED */
         // This also applies transitively to members I think?
-#if ISPC_LLVM_VERSION < ISPC_LLVM_5_0
-            function->setDoesNotAlias(1);
-#else // LLVM 5.0+
         function->addParamAttr(0, llvm::Attribute::NoAlias);
-#endif
 
     g->target->markFuncWithTargetAttr(function);
 
@@ -1080,13 +792,7 @@ void Module::AddFunctionDeclaration(const std::string &name, const FunctionType
 
                                       CastType<ReferenceType>(argType) != NULL)) {
 
-#if ISPC_LLVM_VERSION < ISPC_LLVM_5_0
-            // NOTE: LLVM indexes function parameters starting from 1.
-            // This is unintuitive.
-            function->setDoesNotAlias(i + 1);
-#else // LLVM 5.0+
             function->addParamAttr(i, llvm::Attribute::NoAlias);
-#endif
 #if 0
             int align = 4 * RoundUpPow2(g->target->nativeVectorWidth);
             function->addAttribute(i+1, llvm::Attribute::constructAlignmentFromInt(align));
@@ -1166,14 +872,12 @@ bool Module::writeOutput(OutputType outputType, OutputFlags flags, const char *o
     if (diBuilder && (outputType != Header) && (outputType != Deps))
         lStripUnusedDebugInfo(module);
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4 /* 3.4+ */
     // In LLVM_3_4 after r195494 and r195504 revisions we should pass
     // "Debug Info Version" constant to the module. LLVM will ignore
     // our Debug Info metadata without it.
     if (g->generateDebuggingSymbols == true) {
         module->addModuleFlag(llvm::Module::Warning, "Debug Info Version", llvm::DEBUG_METADATA_VERSION);
     }
-#endif
 
     // SIC! (verifyModule() == TRUE) means "failed", see llvm-link code.
     if ((outputType != Header) && (outputType != Deps) && (outputType != HostStub) && (outputType != DevStub) &&
@@ -1384,11 +1088,7 @@ bool Module::writeBitcode(llvm::Module *module, const char *outFileName, OutputT
 
         std::string s;
         llvm::raw_string_ostream out(s);
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 /* 3.5+ */
         std::unique_ptr<llvm::AssemblyAnnotationWriter> Annotator;
-#else
-        llvm::OwningPtr<llvm::AssemblyAnnotationWriter> Annotator;
-#endif
         module->print(out, Annotator.get());
         std::istringstream iss(s);
 
@@ -1397,10 +1097,8 @@ bool Module::writeBitcode(llvm::Module *module, const char *outFileName, OutputT
             input.push_back(s);
         output = input;
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3 /* 3.3+ */
         /* do not fix attributed with LLVM 3.2, everything is fine there */
         lFixAttributes(input, output);
-#endif
 
         for (vecString_t::iterator it = output.begin(); it != output.end(); it++) {
             *it += "\n";
@@ -1432,61 +1130,22 @@ bool Module::writeObjectFileOrAssembly(llvm::TargetMachine *targetMachine, llvm:
     llvm::TargetMachine::CodeGenFileType fileType =
         (outputType == Object) ? llvm::TargetMachine::CGFT_ObjectFile : llvm::TargetMachine::CGFT_AssemblyFile;
     bool binary = (fileType == llvm::TargetMachine::CGFT_ObjectFile);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3 // 3.2, 3.3
-    unsigned int flags = binary ? llvm::raw_fd_ostream::F_Binary : 0;
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_4 // 3.4
-    llvm::sys::fs::OpenFlags flags = binary ? llvm::sys::fs::F_Binary : llvm::sys::fs::F_None;
-#else                                    // LLVM 3.5+
     llvm::sys::fs::OpenFlags flags = binary ? llvm::sys::fs::F_None : llvm::sys::fs::F_Text;
 
-#endif
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    std::string error;
-#else // LLVM 3.6+
     std::error_code error;
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::tool_output_file *of = new llvm::tool_output_file(outFileName, error, flags);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_5_0 // LLVM 3.7-5.0
-    std::unique_ptr<llvm::tool_output_file> of(new llvm::tool_output_file(outFileName, error, flags));
-#else                                    // LLVM 6.0+
     std::unique_ptr<llvm::ToolOutputFile> of(new llvm::ToolOutputFile(outFileName, error, flags));
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    if (error.size()) {
-#else // LLVM 3.6+
     if (error) {
-#endif
-
         fprintf(stderr, "Error opening output file \"%s\".\n", outFileName);
         return false;
     }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::PassManager pm;
-#else // LLVM 3.7+
     llvm::legacy::PassManager pm;
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.2, 3.3, 3.4
-    pm.add(new llvm::DataLayout(*g->target->getDataLayout()));
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_5 // 3.5
-    pm.add(new llvm::DataLayoutPass(*g->target->getDataLayout()));
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_6 // 3.6
-llvm::DataLayoutPass *dlp = new llvm::DataLayoutPass();
-dlp->doInitialization(*module);
-pm.add(dlp);
-#endif                                   // LLVM 3.7+ doesn't have DataLayoutPass anymore.
 
     {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::formatted_raw_ostream fos(of->os());
-#else // LLVM 3.7+
         llvm::raw_fd_ostream &fos(of->os());
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_6_0
+#if ISPC_LLVM_VERSION == ISPC_LLVM_6_0
         if (targetMachine->addPassesToEmitFile(pm, fos, fileType)) {
             fprintf(stderr, "Fatal error adding passes to emit object file!");
             exit(1);
@@ -1506,9 +1165,6 @@ pm.add(dlp);
         // Success; tell tool_output_file to keep the final output file.
         of->keep();
     }
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    delete of;
-#endif // LLVM 3.7+
     return true;
 }
 
@@ -2421,48 +2077,27 @@ void Module::execPreprocessor(const char *infilename, llvm::raw_string_ostream *
 
     inst.createFileManager();
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.2, 3.3, 3.4
-    clang::TargetOptions &options = inst.getTargetOpts();
-#else // LLVM 3.5+
     const std::shared_ptr<clang::TargetOptions> &options = std::make_shared<clang::TargetOptions>(inst.getTargetOpts());
-#endif
 
     llvm::Triple triple(module->getTargetTriple());
     if (triple.getTriple().empty()) {
         triple.setTriple(llvm::sys::getDefaultTargetTriple());
     }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.2, 3.3, 3.4
-    options.Triple = triple.getTriple();
-#else // LLVM 3.5+
     options->Triple = triple.getTriple();
-#endif
 
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2 // 3.2
     clang::TargetInfo *target = clang::TargetInfo::CreateTargetInfo(inst.getDiagnostics(), options);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_4 // 3.3, 3.4
-    clang::TargetInfo *target = clang::TargetInfo::CreateTargetInfo(inst.getDiagnostics(), &options);
-#else                                    // LLVM 3.5+
-    clang::TargetInfo *target = clang::TargetInfo::CreateTargetInfo(inst.getDiagnostics(), options);
-#endif
-
     inst.setTarget(target);
     inst.createSourceManager(inst.getFileManager());
-#if ISPC_LLVM_VERSION < ISPC_LLVM_5_0
-    clang::FrontendInputFile inputFile(infilename, clang::IK_None);
-#else // LLVM 5.0+
+
     clang::FrontendInputFile inputFile(infilename, clang::InputKind::Unknown);
-#endif
     inst.InitializeSourceManager(inputFile);
 
     // Don't remove comments in the preprocessor, so that we can accurately
     // track the source file position by handling them ourselves.
     inst.getPreprocessorOutputOpts().ShowComments = 1;
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3 // LLVM 3.3+
     inst.getPreprocessorOutputOpts().ShowCPP = 1;
-#endif
-
     clang::HeaderSearchOptions &headerOpts = inst.getHeaderSearchOpts();
     headerOpts.UseBuiltinIncludes = 0;
     headerOpts.UseStandardSystemIncludes = 0;
@@ -2473,9 +2108,6 @@ void Module::execPreprocessor(const char *infilename, llvm::raw_string_ostream *
 #endif
     for (int i = 0; i < (int)g->includePath.size(); ++i) {
         headerOpts.AddPath(g->includePath[i], clang::frontend::Angled,
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-                           true /* is user supplied */,
-#endif
                            false /* not a framework */, true /* ignore sys root */);
     }
 
@@ -2564,11 +2196,7 @@ void Module::execPreprocessor(const char *infilename, llvm::raw_string_ostream *
 
     inst.getLangOpts().LineComment = 1;
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 /* 3.5+ */
     inst.createPreprocessor(clang::TU_Complete);
-#else
-    inst.createPreprocessor();
-#endif
 
     diagPrinter->BeginSourceFile(inst.getLangOpts(), &inst.getPreprocessor());
     clang::DoPrintPreprocessedInput(inst.getPreprocessor(), ostream, inst.getPreprocessorOutputOpts());
@@ -2879,11 +2507,7 @@ static void lEmitDispatchModule(llvm::Module *module, std::map<std::string, Func
 
         // Do some rudimentary cleanup of the final result and make sure that
         // the module is all ok.
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::PassManager optPM;
-#else // LLVM 3.7+
     llvm::legacy::PassManager optPM;
-#endif
     optPM.add(llvm::createGlobalDCEPass());
     optPM.add(llvm::createVerifierPass());
     optPM.run(*module);
diff --git a/src/module.h b/src/module.h
index 80556b63..0c5d3633 100644
--- a/src/module.h
+++ b/src/module.h
@@ -41,11 +41,7 @@
 
 #include "ast.h"
 #include "ispc.h"
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_4
-#include <llvm/DebugInfo.h>
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_5
 #include <llvm/IR/DebugInfo.h>
-#endif
 
 namespace llvm {
 class raw_string_ostream;
@@ -158,11 +154,7 @@ class Module {
     /** The diBuilder manages generating debugging information */
     llvm::DIBuilder *diBuilder;
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DICompileUnit diCompileUnit;
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7
     llvm::DICompileUnit *diCompileUnit;
-#endif // LLVM_3_4+
 
   private:
     const char *filename;
diff --git a/src/opt.cpp b/src/opt.cpp
index 3241e802..dfa10da6 100644
--- a/src/opt.cpp
+++ b/src/opt.cpp
@@ -47,89 +47,55 @@
 #include <set>
 #include <stdio.h>
 
-#include <llvm/Pass.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/BasicBlock.h>
-#include <llvm/Constants.h>
-#include <llvm/Function.h>
-#include <llvm/Instructions.h>
-#include <llvm/Intrinsics.h>
-#include <llvm/Module.h>
-#ifdef ISPC_NVPTX_ENABLED
-#include <llvm/InlineAsm.h>
-#endif /* ISPC_NVPTX_ENABLED */
-#else  // LLVM 3.3+
 #include <llvm/IR/BasicBlock.h>
 #include <llvm/IR/Constants.h>
 #include <llvm/IR/Function.h>
 #include <llvm/IR/Instructions.h>
 #include <llvm/IR/Intrinsics.h>
 #include <llvm/IR/Module.h>
+#include <llvm/Pass.h>
 #ifdef ISPC_NVPTX_ENABLED
 #include <llvm/IR/InlineAsm.h>
 #endif /* ISPC_NVPTX_ENABLED */
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_4 // LLVM 3.4+
+
 #include <llvm/Transforms/Instrumentation.h>
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-#include "llvm/PassManager.h"
-#else // LLVM 3.7+
+
 #include "llvm/IR/LegacyPassManager.h"
-#endif
+
 #include <llvm/PassRegistry.h>
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
+
 #include <llvm/IR/DebugInfo.h>
 #include <llvm/IR/IRPrintingPasses.h>
 #include <llvm/IR/PatternMatch.h>
 #include <llvm/IR/Verifier.h>
-#else // < 3.5
-#include <llvm/Analysis/Verifier.h>
-#include <llvm/Assembly/PrintModulePass.h>
-#include <llvm/DebugInfo.h>
-#include <llvm/Support/PatternMatch.h>
-#endif
+
 #include <llvm/Analysis/ConstantFolding.h>
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-#include <llvm/Target/TargetLibraryInfo.h>
-#else // LLVM 3.7+
+
 #include <llvm/Analysis/TargetLibraryInfo.h>
-#endif
-#include <llvm/ADT/SmallSet.h>
-#include <llvm/ADT/Triple.h>
-#include <llvm/Transforms/IPO.h>
-#include <llvm/Transforms/Scalar.h>
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_7_0
 #include "llvm/Transforms/InstCombine/InstCombine.h"
 #include "llvm/Transforms/Utils.h"
 #endif
+#include <llvm/ADT/SmallSet.h>
+#include <llvm/ADT/Triple.h>
 #include <llvm/Target/TargetOptions.h>
+#include <llvm/Transforms/IPO.h>
+#include <llvm/Transforms/Scalar.h>
 #include <llvm/Transforms/Utils/BasicBlockUtils.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/DataLayout.h>
-#else // LLVM 3.3+
+
 #include <llvm/Analysis/TargetTransformInfo.h>
 #include <llvm/IR/DataLayout.h>
-#endif
-#include <llvm/Target/TargetMachine.h>
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_8 // LLVM 3.8+
+
 #include "llvm/Analysis/TypeBasedAliasAnalysis.h"
-#include <llvm/Analysis/BasicAliasAnalysis.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_9 // LLVM 3.9+
 #include "llvm/Transforms/IPO/FunctionAttrs.h"
 #include "llvm/Transforms/Scalar/GVN.h"
-#endif
+#include <llvm/Analysis/BasicAliasAnalysis.h>
 #include <llvm/Analysis/Passes.h>
-#include <llvm/Support/raw_ostream.h>
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_5_0 // LLVM 5.0+
 #include <llvm/BinaryFormat/Dwarf.h>
-#else // LLVM up to 4.x
-#include <llvm/Support/Dwarf.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_6
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/Target/TargetMachine.h>
+
 #include <llvm/IR/IntrinsicInst.h>
-#endif
 #ifdef ISPC_HOST_IS_LINUX
 #include <alloca.h>
 #elif defined(ISPC_HOST_IS_WINDOWS)
@@ -258,35 +224,21 @@ static bool lGetSourcePosFromMetadata(const llvm::Instruction *inst, SourcePos *
     llvm::MDString *str = llvm::dyn_cast<llvm::MDString>(filename->getOperand(0));
     Assert(str);
     llvm::ConstantInt *first_lnum =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::dyn_cast<llvm::ConstantInt>(first_line->getOperand(0));
-#else /* LLVN 3.6+ */
+
         llvm::mdconst::extract<llvm::ConstantInt>(first_line->getOperand(0));
-#endif
     Assert(first_lnum);
 
     llvm::ConstantInt *first_colnum =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::dyn_cast<llvm::ConstantInt>(first_column->getOperand(0));
-#else /* LLVN 3.6+ */
+
         llvm::mdconst::extract<llvm::ConstantInt>(first_column->getOperand(0));
-#endif
     Assert(first_column);
 
     llvm::ConstantInt *last_lnum =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::dyn_cast<llvm::ConstantInt>(last_line->getOperand(0));
-#else /* LLVN 3.6+ */
+
         llvm::mdconst::extract<llvm::ConstantInt>(last_line->getOperand(0));
-#endif
     Assert(last_lnum);
 
-    llvm::ConstantInt *last_colnum =
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::dyn_cast<llvm::ConstantInt>(last_column->getOperand(0));
-#else /* LLVN 3.6+ */
-        llvm::mdconst::extract<llvm::ConstantInt>(last_column->getOperand(0));
-#endif
+    llvm::ConstantInt *last_colnum = llvm::mdconst::extract<llvm::ConstantInt>(last_column->getOperand(0));
     Assert(last_column);
 
     *pos = SourcePos(str->getString().data(), (int)first_lnum->getZExtValue(), (int)first_colnum->getZExtValue(),
@@ -335,11 +287,8 @@ static llvm::Instruction *lGEPInst(llvm::Value *ptr, llvm::Value *offset, const
                                    llvm::Instruction *insertBefore) {
     llvm::Value *index[1] = {offset};
     llvm::ArrayRef<llvm::Value *> arrayRef(&index[0], &index[1]);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    return llvm::GetElementPtrInst::Create(ptr, arrayRef, name, insertBefore);
-#else // LLVM 3.7+
+
     return llvm::GetElementPtrInst::Create(PTYPE(ptr), ptr, arrayRef, name, insertBefore);
-#endif
 }
 
 /** Given a vector of constant values (int, float, or bool) representing an
@@ -457,17 +406,10 @@ class DebugPassManager {
     DebugPassManager() : number(0) {}
     void add(llvm::Pass *P, int stage);
     bool run(llvm::Module &M) { return PM.run(M); }
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::PassManager &getPM() { return PM; }
-#else /* LLVM 3.7+ */
     llvm::legacy::PassManager &getPM() { return PM; }
-#endif
+
   private:
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::PassManager PM;
-#else /* LLVM 3.7+ */
     llvm::legacy::PassManager PM;
-#endif
     int number;
 };
 
@@ -488,25 +430,12 @@ void DebugPassManager::add(llvm::Pass *P, int stage = -1) {
                 PM.add(CreateDebugPassFile(number, P->getPassName()));
             } else {
                 char buf[100];
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-                snprintf(buf, sizeof(buf), "\n\n*****LLVM IR after phase %d: %s*****\n\n", number, P->getPassName());
-#else // LLVM 4.0+
                 snprintf(buf, sizeof(buf), "\n\n*****LLVM IR after phase %d: %s*****\n\n", number,
                          P->getPassName().data());
-#endif
                 PM.add(CreateDebugPass(buf));
             }
         }
 #endif
-
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_4 || ISPC_LLVM_VERSION == ISPC_LLVM_3_5 // only 3.4 and 3.5
-        if (g->debugIR == number) {
-            // adding generating of LLVM IR debug after optimization
-            char buf[100];
-            snprintf(buf, sizeof(buf), "Debug_IR_after_%d_phase.bc", number);
-            PM.add(llvm::createDebugIRPass(true, true, ".", buf));
-        }
-#endif
     }
 }
 ///////////////////////////////////////////////////////////////////////////
@@ -521,33 +450,11 @@ void Optimize(llvm::Module *module, int optLevel) {
     DebugPassManager optPM;
     optPM.add(llvm::createVerifierPass(), 0);
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::TargetLibraryInfo *targetLibraryInfo = new llvm::TargetLibraryInfo(llvm::Triple(module->getTargetTriple()));
-    optPM.add(targetLibraryInfo);
-#else // LLVM 3.7+
     optPM.add(new llvm::TargetLibraryInfoWrapperPass(llvm::Triple(module->getTargetTriple())));
-#endif
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_4
-    optPM.add(new llvm::DataLayout(*g->target->getDataLayout()));
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_5
-    optPM.add(new llvm::DataLayoutPass(*g->target->getDataLayout()));
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_6
-    llvm::DataLayoutPass *dlp = new llvm::DataLayoutPass();
-    dlp->doInitialization(*module);
-    optPM.add(dlp);
-#endif // LLVM 3.7+ doesn't have DataLayoutPass anymore.
 
     llvm::TargetMachine *targetMachine = g->target->GetTargetMachine();
 
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-    optPM.add(new llvm::TargetTransformInfo(targetMachine->getScalarTargetTransformInfo(),
-                                            targetMachine->getVectorTargetTransformInfo()));
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    targetMachine->addAnalysisPasses(optPM.getPM());
-#else // LLVM 3.7+
     optPM.getPM().add(createTargetTransformInfoWrapperPass(targetMachine->getTargetIRAnalysis()));
-#endif
 
     optPM.add(llvm::createIndVarSimplifyPass());
 
@@ -578,9 +485,6 @@ void Optimize(llvm::Module *module, int optLevel) {
         llvm::initializeScalarOpts(*registry);
         llvm::initializeIPO(*registry);
         llvm::initializeAnalysis(*registry);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7
-        llvm::initializeIPA(*registry);
-#endif
         llvm::initializeTransformUtils(*registry);
         llvm::initializeInstCombine(*registry);
         llvm::initializeInstrumentation(*registry);
@@ -597,19 +501,12 @@ void Optimize(llvm::Module *module, int optLevel) {
         // so we explicitly enable them here.
         // Need to keep sync with future LLVM change
         // An alternative is to call populateFunctionPassManager()
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_7
-        optPM.add(llvm::createTypeBasedAliasAnalysisPass(), 190);
-        optPM.add(llvm::createBasicAliasAnalysisPass());
-#else
         optPM.add(llvm::createTypeBasedAAWrapperPass(), 190);
         optPM.add(llvm::createBasicAAWrapperPass());
-#endif
         optPM.add(llvm::createCFGSimplificationPass());
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        optPM.add(llvm::createScalarReplAggregatesPass());
-#else
+
         optPM.add(llvm::createSROAPass());
-#endif
+
         optPM.add(llvm::createEarlyCSEPass());
         optPM.add(llvm::createLowerExpectIntrinsicPass());
 
@@ -633,20 +530,8 @@ void Optimize(llvm::Module *module, int optLevel) {
         }
         optPM.add(llvm::createDeadInstEliminationPass(), 220);
 
-        // Max struct size threshold for scalar replacement is
-        //    1) 4 fields (r,g,b,w)
-        //    2) field size: vectorWidth * sizeof(float)
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        const int field_limit = 4;
-        int sr_threshold = g->target->getVectorWidth() * sizeof(float) * field_limit;
-#endif
-
         // On to more serious optimizations
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        optPM.add(llvm::createScalarReplAggregatesPass(sr_threshold));
-#else
         optPM.add(llvm::createSROAPass());
-#endif
         optPM.add(llvm::createInstructionCombiningPass());
         optPM.add(llvm::createCFGSimplificationPass());
         optPM.add(llvm::createPromoteMemoryToRegisterPass());
@@ -663,35 +548,23 @@ void Optimize(llvm::Module *module, int optLevel) {
         optPM.add(llvm::createInstructionCombiningPass());
         optPM.add(llvm::createCFGSimplificationPass());
         optPM.add(llvm::createPruneEHPass());
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_9 // 3.9+
         optPM.add(llvm::createPostOrderFunctionAttrsLegacyPass());
         optPM.add(llvm::createReversePostOrderFunctionAttrsPass());
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_8 // 3.8
-        optPM.add(llvm::createPostOrderFunctionAttrsPass());
-        optPM.add(llvm::createReversePostOrderFunctionAttrsPass());
-#else                                    // 3.7 and earlier
-        optPM.add(llvm::createFunctionAttrsPass());
-#endif
+
         optPM.add(llvm::createFunctionInliningPass());
         optPM.add(llvm::createConstantPropagationPass());
         optPM.add(llvm::createDeadInstEliminationPass());
         optPM.add(llvm::createCFGSimplificationPass());
 
         optPM.add(llvm::createArgumentPromotionPass());
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3
-        // Starting from 3.4 this functionality was moved to
-        // InstructionCombiningPass. See r184459 for details.
-        optPM.add(llvm::createSimplifyLibCallsPass(), 240);
-#endif
+
         optPM.add(llvm::createAggressiveDCEPass());
         optPM.add(llvm::createInstructionCombiningPass(), 241);
         optPM.add(llvm::createJumpThreadingPass());
         optPM.add(llvm::createCFGSimplificationPass());
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        optPM.add(llvm::createScalarReplAggregatesPass(sr_threshold));
-#else
+
         optPM.add(llvm::createSROAPass());
-#endif
+
         optPM.add(llvm::createInstructionCombiningPass());
         optPM.add(llvm::createTailCallEliminationPass());
 
@@ -736,11 +609,9 @@ void Optimize(llvm::Module *module, int optLevel) {
 
         optPM.add(llvm::createFunctionInliningPass());
         optPM.add(llvm::createArgumentPromotionPass());
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        optPM.add(llvm::createScalarReplAggregatesPass(sr_threshold, false));
-#else
+
         optPM.add(llvm::createSROAPass());
-#endif
+
         optPM.add(llvm::createInstructionCombiningPass());
         optPM.add(CreateInstructionSimplifyPass());
         optPM.add(llvm::createCFGSimplificationPass());
@@ -793,11 +664,7 @@ void Optimize(llvm::Module *module, int optLevel) {
             optPM.add(llvm::createCFGSimplificationPass());
             // Here clang has an experimental pass SROAPass instead of
             // ScalarReplAggregatesPass. We should add it in the future.
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-            optPM.add(llvm::createScalarReplAggregatesPass());
-#else
             optPM.add(llvm::createSROAPass());
-#endif
             optPM.add(llvm::createEarlyCSEPass());
             optPM.add(llvm::createLowerExpectIntrinsicPass());
             optPM.add(llvm::createTypeBasedAliasAnalysisPass());
@@ -835,11 +702,7 @@ void Optimize(llvm::Module *module, int optLevel) {
             optPM.add(llvm::createCFGSimplificationPass());
 
             optPM.add(llvm::createArgumentPromotionPass());
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3
-            // Starting from 3.4 this functionality was moved to
-            // InstructionCombiningPass. See r184459 for details.
-            optPM.add(llvm::createSimplifyLibCallsPass());
-#endif
+
             optPM.add(llvm::createAggressiveDCEPass());
             optPM.add(llvm::createInstructionCombiningPass());
             optPM.add(llvm::createJumpThreadingPass());
@@ -924,11 +787,8 @@ class IntrinsicsOpt : public llvm::BasicBlockPass {
   public:
     IntrinsicsOpt() : BasicBlockPass(ID){};
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Intrinsics Cleanup Optimization"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Intrinsics Cleanup Optimization"; }
-#endif
+
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
     static char ID;
@@ -1203,11 +1063,7 @@ class InstructionSimplifyPass : public llvm::BasicBlockPass {
   public:
     InstructionSimplifyPass() : BasicBlockPass(ID) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Vector Select Optimization"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Vector Select Optimization"; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
     static char ID;
@@ -1353,11 +1209,8 @@ class ImproveMemoryOpsPass : public llvm::BasicBlockPass {
     static char ID;
     ImproveMemoryOpsPass() : BasicBlockPass(ID) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Improve Memory Ops"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Improve Memory Ops"; }
-#endif
+
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 };
 
@@ -1380,7 +1233,6 @@ static llvm::Value *lCheckForActualPointer(llvm::Value *v) {
     } else if (llvm::isa<llvm::PtrToIntInst>(v)) {
         return v;
     }
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_7
     // This one is tricky, as it's heuristic tuned for LLVM 3.7+, which may
     // optimize loading double* with consequent ptr2int to straight load of i64.
     // This heuristic should be good enough to catch all the cases we should
@@ -1388,7 +1240,7 @@ static llvm::Value *lCheckForActualPointer(llvm::Value *v) {
     else if (llvm::isa<llvm::LoadInst>(v)) {
         return v;
     }
-#endif
+
     else if (llvm::CastInst *ci = llvm::dyn_cast<llvm::CastInst>(v)) {
         llvm::Value *t = lCheckForActualPointer(ci->getOperand(0));
         if (t == NULL) {
@@ -3030,11 +2882,7 @@ class GatherCoalescePass : public llvm::BasicBlockPass {
     static char ID;
     GatherCoalescePass() : BasicBlockPass(ID) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Gather Coalescing"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Gather Coalescing"; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 };
 
@@ -4003,11 +3851,7 @@ class ReplacePseudoMemoryOpsPass : public llvm::BasicBlockPass {
     static char ID;
     ReplacePseudoMemoryOpsPass() : BasicBlockPass(ID) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Replace Pseudo Memory Ops"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Replace Pseudo Memory Ops"; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 };
 
@@ -4301,11 +4145,7 @@ class IsCompileTimeConstantPass : public llvm::BasicBlockPass {
     static char ID;
     IsCompileTimeConstantPass(bool last = false) : BasicBlockPass(ID) { isLastTry = last; }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Resolve \"is compile time constant\""; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Resolve \"is compile time constant\""; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
     bool isLastTry;
@@ -4390,11 +4230,7 @@ class DebugPass : public llvm::ModulePass {
     static char ID;
     DebugPass(char *output) : ModulePass(ID) { snprintf(str_output, sizeof(str_output), "%s", output); }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Dump LLVM IR"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Dump LLVM IR"; }
-#endif
     bool runOnModule(llvm::Module &m);
 
   private:
@@ -4425,11 +4261,7 @@ class DebugPassFile : public llvm::ModulePass {
     static char ID;
     DebugPassFile(int number, llvm::StringRef name) : ModulePass(ID), pnum(number), pname(name) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Dump LLVM IR"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Dump LLVM IR"; }
-#endif
     bool runOnModule(llvm::Module &m);
     bool doInitialization(llvm::Module &m);
 
@@ -4494,11 +4326,7 @@ class MakeInternalFuncsStaticPass : public llvm::ModulePass {
 
     void getAnalysisUsage(llvm::AnalysisUsage &AU) const { AU.setPreservesCFG(); }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Make internal funcs \"static\""; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Make internal funcs \"static\""; }
-#endif
     bool runOnModule(llvm::Module &m);
 };
 
@@ -4658,11 +4486,7 @@ class PeepholePass : public llvm::BasicBlockPass {
   public:
     PeepholePass();
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Peephole Optimizations"; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Peephole Optimizations"; }
-#endif
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
     static char ID;
@@ -4672,8 +4496,6 @@ char PeepholePass::ID = 0;
 
 PeepholePass::PeepholePass() : BasicBlockPass(ID) {}
 
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3
-
 using namespace llvm::PatternMatch;
 
 template <typename Op_t, unsigned Opcode> struct CastClassTypes_match {
@@ -4910,7 +4732,6 @@ static llvm::Instruction *lMatchAvgDownInt16(llvm::Value *inst) {
     }
     return NULL;
 }
-#endif // !LLVM_3_2
 
 bool PeepholePass::runOnBasicBlock(llvm::BasicBlock &bb) {
     DEBUG_START_PASS("PeepholePass");
@@ -4921,7 +4742,6 @@ bool PeepholePass::runOnBasicBlock(llvm::BasicBlock &bb) {
         llvm::Instruction *inst = &*iter;
 
         llvm::Instruction *builtinCall = NULL;
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3
         if (!builtinCall)
             builtinCall = lMatchAvgUpUInt8(inst);
         if (!builtinCall)
@@ -4938,7 +4758,6 @@ bool PeepholePass::runOnBasicBlock(llvm::BasicBlock &bb) {
             builtinCall = lMatchAvgDownInt8(inst);
         if (!builtinCall)
             builtinCall = lMatchAvgDownInt16(inst);
-#endif // !LLVM_3_2
         if (builtinCall != NULL) {
             llvm::ReplaceInstWithInst(inst, builtinCall);
             modifiedAny = true;
@@ -4970,11 +4789,8 @@ class ReplaceStdlibShiftPass : public llvm::BasicBlockPass {
     static char ID;
     ReplaceStdlibShiftPass() : BasicBlockPass(ID) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Resolve \"replace extract insert chains\""; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Resolve \"replace extract insert chains\""; }
-#endif
+
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 };
 
@@ -5071,11 +4887,7 @@ class FixBooleanSelectPass : public llvm::FunctionPass {
     static char ID;
     FixBooleanSelectPass() : FunctionPass(ID) {}
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-    const char *getPassName() const { return "Resolve \"replace extract insert chains\""; }
-#else // LLVM 4.0+
     llvm::StringRef getPassName() const { return "Resolve \"replace extract insert chains\""; }
-#endif
     bool runOnFunction(llvm::Function &F);
 
   private:
@@ -5132,78 +4944,6 @@ llvm::Instruction *FixBooleanSelectPass::fixSelect(llvm::SelectInst *sel, llvm::
 
 bool FixBooleanSelectPass::runOnFunction(llvm::Function &F) {
     bool modifiedAny = false;
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_3 // LLVM 3.3 only
-
-    // Don't optimize generic targets.
-    if (g->target->getISA() == Target::GENERIC) {
-        return false;
-    }
-
-    for (llvm::Function::iterator I = F.begin(), E = F.end(); I != E; ++I) {
-        llvm::BasicBlock *bb = &*I;
-        for (llvm::BasicBlock::iterator iter = bb->begin(), e = bb->end(); iter != e; ++iter) {
-            llvm::Instruction *inst = &*iter;
-
-            llvm::CmpInst *cmp = llvm::dyn_cast<llvm::CmpInst>(inst);
-
-            if (cmp && cmp->getType()->isVectorTy() && cmp->getType()->getVectorElementType()->isIntegerTy(1)) {
-
-                // Search for select instruction uses.
-                int selects = 0;
-                llvm::VectorType *sext_type = 0;
-                for (llvm::Instruction::use_iterator it = cmp->use_begin(); it != cmp->use_end(); ++it) {
-                    llvm::SelectInst *sel = llvm::dyn_cast<llvm::SelectInst>(*it);
-                    if (sel && sel->getType()->isVectorTy() && sel->getType()->getScalarSizeInBits() > 1) {
-                        selects++;
-                        // We pick the first one, but typical case when all select types are the same.
-                        sext_type = llvm::dyn_cast<llvm::VectorType>(sel->getType());
-                        break;
-                    }
-                }
-                if (selects == 0) {
-                    continue;
-                }
-                // Get an integer equivalent, if it's not yet an integer.
-                sext_type = llvm::VectorType::getInteger(sext_type);
-
-                // Do transformation
-                llvm::BasicBlock::iterator iter_copy = iter;
-                llvm::Instruction *next_inst = &*(++iter_copy);
-                // Create or reuse sext
-                llvm::SExtInst *sext = llvm::dyn_cast<llvm::SExtInst>(next_inst);
-                if (sext && sext->getOperand(0) == cmp && sext->getDestTy() == sext_type) {
-                    // This sext can be reused
-                } else {
-                    if (next_inst) {
-                        sext = new llvm::SExtInst(cmp, sext_type, "sext_cmp", next_inst);
-                    } else {
-                        sext = new llvm::SExtInst(cmp, sext_type, "sext_cmp", bb);
-                    }
-                }
-
-                // Walk and fix selects
-                std::vector<llvm::SelectInst *> sel_uses;
-                for (llvm::Instruction::use_iterator it = cmp->use_begin(); it != cmp->use_end(); ++it) {
-                    llvm::SelectInst *sel = llvm::dyn_cast<llvm::SelectInst>(*it);
-                    if (sel && sel->getType()->getScalarSizeInBits() == sext_type->getScalarSizeInBits()) {
-
-                        // Check that second operand is zero.
-                        llvm::Constant *false_cond = llvm::dyn_cast<llvm::Constant>(sel->getFalseValue());
-                        if (false_cond && false_cond->isZeroValue()) {
-                            sel_uses.push_back(sel);
-                            modifiedAny = true;
-                        }
-                    }
-                }
-
-                for (int i = 0; i < sel_uses.size(); i++) {
-                    fixSelect(sel_uses[i], sext);
-                }
-            }
-        }
-    }
-
-#endif // LLVM 3.3
 
     return modifiedAny;
 }
diff --git a/src/parse.yy b/src/parse.yy
index eb2a5a7a..7d3dfaed 100644
--- a/src/parse.yy
+++ b/src/parse.yy
@@ -83,11 +83,7 @@ struct ForeachDimension;
 #include "util.h"
 
 #include <stdio.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-  #include <llvm/Constants.h>
-#else
-  #include <llvm/IR/Constants.h>
-#endif
+#include <llvm/IR/Constants.h>
 
 #define UNIMPLEMENTED \
         Error(yylloc, "Unimplemented parser functionality %s:%d", \
diff --git a/src/stmt.cpp b/src/stmt.cpp
index 6fd64fbb..2a988bda 100644
--- a/src/stmt.cpp
+++ b/src/stmt.cpp
@@ -48,16 +48,6 @@
 #include <map>
 #include <stdio.h>
 
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/CallingConv.h>
-#include <llvm/DerivedTypes.h>
-#include <llvm/Function.h>
-#include <llvm/Instructions.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Metadata.h>
-#include <llvm/Module.h>
-#include <llvm/Type.h>
-#else
 #include <llvm/IR/CallingConv.h>
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/Function.h>
@@ -66,7 +56,6 @@
 #include <llvm/IR/Metadata.h>
 #include <llvm/IR/Module.h>
 #include <llvm/IR/Type.h>
-#endif
 #include <llvm/Support/raw_ostream.h>
 
 ///////////////////////////////////////////////////////////////////////////
@@ -167,11 +156,7 @@ static llvm::Value *lConvertToGenericPtr(FunctionEmitContext *ctx, llvm::Value *
         llvm::Function *func_warp_index = m->module->getFunction("__warp_index");
         llvm::Value *warpId = ctx->CallInst(func_warp_index, NULL, std::vector<llvm::Value *>(), "gep2gen_warp_index");
         llvm::Value *offset = ctx->BinaryOperator(llvm::Instruction::Mul, warpId, LLVMInt32(numEl), "gep2gen_offset");
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        value = llvm::GetElementPtrInst::Create(value, offset, "gep2gen_offset", ctx->GetCurrentBasicBlock());
-#else
         value = llvm::GetElementPtrInst::Create(NULL, value, offset, "gep2gen_offset", ctx->GetCurrentBasicBlock());
-#endif
     }
 
     /* convert arrElTy* to elTy* */
@@ -1407,13 +1392,8 @@ static llvm::Value *lUpdateVaryingCounter(int dim, int nDims, FunctionEmitContex
         ptr_arrayidx_indices.push_back(LLVMInt32(0));
         ptr_arrayidx_indices.push_back(laneIdx);
 #if 1
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::Instruction *ptr_arrayidx =
-            llvm::GetElementPtrInst::Create(globalDelta, ptr_arrayidx_indices, "arrayidx", ctx->GetCurrentBasicBlock());
-#else
         llvm::Instruction *ptr_arrayidx = llvm::GetElementPtrInst::Create(NULL, globalDelta, ptr_arrayidx_indices,
                                                                           "arrayidx", ctx->GetCurrentBasicBlock());
-#endif
         llvm::LoadInst *int8_39 = new llvm::LoadInst(ptr_arrayidx, "", false, ctx->GetCurrentBasicBlock());
         llvm::Value *int32_39 = ctx->ZExtInst(int8_39, LLVMTypes::Int32Type);
 
diff --git a/src/type.cpp b/src/type.cpp
index ab421444..d30fc4ad 100644
--- a/src/type.cpp
+++ b/src/type.cpp
@@ -41,28 +41,14 @@
 #include "module.h"
 #include "sym.h"
 
-#include <map>
-#include <stdio.h>
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/Module.h>
-#include <llvm/Value.h>
-#else
-#include <llvm/IR/Module.h>
-#include <llvm/IR/Value.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_5 // LLVM 3.5+
+#include <llvm/BinaryFormat/Dwarf.h>
 #include <llvm/IR/DIBuilder.h>
 #include <llvm/IR/DebugInfo.h>
-#else
-#include <llvm/DIBuilder.h>
-#include <llvm/DebugInfo.h>
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_5_0 // LLVM 5.0+
-#include <llvm/BinaryFormat/Dwarf.h>
-#else // LLVM up to 4.x
-#include <llvm/Support/Dwarf.h>
-#endif
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Value.h>
 #include <llvm/Support/MathExtras.h>
+#include <map>
+#include <stdio.h>
 
 /** Utility routine used in code that prints out declarations; returns true
     if the given name should be printed, false otherwise.  This allows us
@@ -81,43 +67,14 @@ static bool lShouldPrintName(const std::string &name) {
 
 /** Utility routine to create a llvm array type of the given number of
     the given element type. */
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-static llvm::DIType lCreateDIArray(llvm::DIType eltType, int count) {
-#else // LLVM 3.7++
 static llvm::DIType *lCreateDIArray(llvm::DIType *eltType, int count) {
-#endif
-
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-    int lowerBound = 0, upperBound = count - 1;
-
-    if (count == 0) {
-        // unsized array -> indicate with low > high
-        lowerBound = 1;
-        upperBound = 0;
-    }
 
-    llvm::Value *sub = m->diBuilder->getOrCreateSubrange(lowerBound, upperBound);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    llvm::Value *sub = m->diBuilder->getOrCreateSubrange(0, count);
-#endif
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    std::vector<llvm::Value *> subs;
-#else // LLVM 3.6++
     llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, count);
     std::vector<llvm::Metadata *> subs;
-#endif
     subs.push_back(sub);
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIArray subArray = m->diBuilder->getOrCreateArray(subs);
-    uint64_t size = eltType.getSizeInBits() * count;
-    uint64_t align = eltType.getAlignInBits();
-#else // LLVM 3.7++
     llvm::DINodeArray subArray = m->diBuilder->getOrCreateArray(subs);
     uint64_t size = eltType->getSizeInBits() * count;
     uint64_t align = eltType->getAlignInBits();
-#endif
 
     return m->diBuilder->createArrayType(size, align, eltType, subArray);
 }
@@ -517,57 +474,14 @@ llvm::Type *AtomicType::LLVMType(llvm::LLVMContext *ctx) const {
     }
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType AtomicType::GetDIType(llvm::DIDescriptor scope) const {
-#else // LLVM 3.7++
 llvm::DIType *AtomicType::GetDIType(llvm::DIScope *scope) const {
-#endif
     Assert(variability.type != Variability::Unbound);
 
     if (variability.type == Variability::Uniform) {
         switch (basicType) {
         case TYPE_VOID:
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-            return llvm::DIType();
-#else // LLVM 3.7++
             return NULL;
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-        case TYPE_BOOL:
-            return m->diBuilder->createBasicType("bool", 32 /* size */, 32 /* align */, llvm::dwarf::DW_ATE_unsigned);
-            break;
-        case TYPE_INT8:
-            return m->diBuilder->createBasicType("int8", 8 /* size */, 8 /* align */, llvm::dwarf::DW_ATE_signed);
-            break;
-        case TYPE_UINT8:
-            return m->diBuilder->createBasicType("uint8", 8 /* size */, 8 /* align */, llvm::dwarf::DW_ATE_unsigned);
-            break;
-        case TYPE_INT16:
-            return m->diBuilder->createBasicType("int16", 16 /* size */, 16 /* align */, llvm::dwarf::DW_ATE_signed);
-            break;
-        case TYPE_UINT16:
-            return m->diBuilder->createBasicType("uint16", 16 /* size */, 16 /* align */, llvm::dwarf::DW_ATE_unsigned);
-            break;
-        case TYPE_INT32:
-            return m->diBuilder->createBasicType("int32", 32 /* size */, 32 /* align */, llvm::dwarf::DW_ATE_signed);
-            break;
-        case TYPE_UINT32:
-            return m->diBuilder->createBasicType("uint32", 32 /* size */, 32 /* align */, llvm::dwarf::DW_ATE_unsigned);
-            break;
-        case TYPE_FLOAT:
-            return m->diBuilder->createBasicType("float", 32 /* size */, 32 /* align */, llvm::dwarf::DW_ATE_float);
-            break;
-        case TYPE_DOUBLE:
-            return m->diBuilder->createBasicType("double", 64 /* size */, 64 /* align */, llvm::dwarf::DW_ATE_float);
-            break;
-        case TYPE_INT64:
-            return m->diBuilder->createBasicType("int64", 64 /* size */, 64 /* align */, llvm::dwarf::DW_ATE_signed);
-            break;
-        case TYPE_UINT64:
-            return m->diBuilder->createBasicType("uint64", 64 /* size */, 64 /* align */, llvm::dwarf::DW_ATE_unsigned);
-            break;
-#else // LLVM 4.0+
         case TYPE_BOOL:
             return m->diBuilder->createBasicType("bool", 32 /* size */, llvm::dwarf::DW_ATE_unsigned);
             break;
@@ -601,35 +515,20 @@ llvm::DIType *AtomicType::GetDIType(llvm::DIScope *scope) const {
         case TYPE_UINT64:
             return m->diBuilder->createBasicType("uint64", 64 /* size */, llvm::dwarf::DW_ATE_unsigned);
             break;
-#endif
 
         default:
             FATAL("unhandled basic type in AtomicType::GetDIType()");
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-            return llvm::DIType();
-#else // LLVM 3.7+
+
             return NULL;
-#endif
         }
     } else if (variability == Variability::Varying) {
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-        llvm::Value *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth() - 1);
-#elif ISPC_LLVM_VERSION > ISPC_VERSION_3_2 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::Value *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth());
-#else // LLVM 3.6+
-    llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth());
-#endif
-#if ISPC_LLVM_VERSION > ISPC_VERSION_3_2 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::DIArray subArray = m->diBuilder->getOrCreateArray(sub);
-        llvm::DIType unifType = GetAsUniformType()->GetDIType(scope);
-        uint64_t size = unifType.getSizeInBits() * g->target->getVectorWidth();
-        uint64_t align = unifType.getAlignInBits() * g->target->getVectorWidth();
-#else // LLVM 3.7+
+
+        llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth());
+
         llvm::DINodeArray subArray = m->diBuilder->getOrCreateArray(sub);
         llvm::DIType *unifType = GetAsUniformType()->GetDIType(scope);
         uint64_t size = unifType->getSizeInBits() * g->target->getVectorWidth();
         uint64_t align = unifType->getAlignInBits() * g->target->getVectorWidth();
-#endif
         return m->diBuilder->createVectorType(size, align, unifType, subArray);
     } else {
         Assert(variability == Variability::SOA);
@@ -806,65 +705,35 @@ llvm::Type *EnumType::LLVMType(llvm::LLVMContext *ctx) const {
     }
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType EnumType::GetDIType(llvm::DIDescriptor scope) const {
-#else // LLVM 3.7+
 llvm::DIType *EnumType::GetDIType(llvm::DIScope *scope) const {
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    std::vector<llvm::Value *> enumeratorDescriptors;
-#else // LLVM 3.6+
     std::vector<llvm::Metadata *> enumeratorDescriptors;
-#endif
     for (unsigned int i = 0; i < enumerators.size(); ++i) {
         unsigned int enumeratorValue;
         Assert(enumerators[i]->constValue != NULL);
         int count = enumerators[i]->constValue->GetValues(&enumeratorValue);
         Assert(count == 1);
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::Value *descriptor =
-#else // LLVM 3.6+
-        llvm::Metadata *descriptor =
-#endif
-            m->diBuilder->createEnumerator(enumerators[i]->name, enumeratorValue);
+
+        llvm::Metadata *descriptor = m->diBuilder->createEnumerator(enumerators[i]->name, enumeratorValue);
         enumeratorDescriptors.push_back(descriptor);
     }
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIArray elementArray = m->diBuilder->getOrCreateArray(enumeratorDescriptors);
-    llvm::DIFile diFile = pos.GetDIFile();
-    llvm::DIType diType =
-        m->diBuilder->createEnumerationType(diFile, name, diFile, pos.first_line, 32 /* size in bits */,
-                                            32 /* align in bits */, elementArray, llvm::DIType());
-#else // LLVM 3.7+
+
     llvm::DINodeArray elementArray = m->diBuilder->getOrCreateArray(enumeratorDescriptors);
     llvm::DIFile *diFile = pos.GetDIFile();
     llvm::DIType *underlyingType = AtomicType::UniformInt32->GetDIType(scope);
     llvm::DIType *diType =
         m->diBuilder->createEnumerationType(diFile, name, diFile, pos.first_line, 32 /* size in bits */,
                                             32 /* align in bits */, elementArray, underlyingType, name);
-#endif
     switch (variability.type) {
     case Variability::Uniform:
         return diType;
     case Variability::Varying: {
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-        llvm::Value *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth() - 1);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-        llvm::Value *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth());
-#else // LLVM 3.6++
-    llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth());
-#endif
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::DIArray subArray = m->diBuilder->getOrCreateArray(sub);
-        uint64_t size = diType.getSizeInBits() * g->target->getVectorWidth();
-        uint64_t align = diType.getAlignInBits() * g->target->getVectorWidth();
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7 // LLVM 3.7+
+        llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, g->target->getVectorWidth());
+
         llvm::DINodeArray subArray = m->diBuilder->getOrCreateArray(sub);
         // llvm::DebugNodeArray subArray = m->diBuilder->getOrCreateArray(sub);
         uint64_t size = diType->getSizeInBits() * g->target->getVectorWidth();
         uint64_t align = diType->getAlignInBits() * g->target->getVectorWidth();
-#endif
         return m->diBuilder->createVectorType(size, align, diType, subArray);
     }
     case Variability::SOA: {
@@ -872,11 +741,7 @@ llvm::DIType *EnumType::GetDIType(llvm::DIScope *scope) const {
     }
     default:
         FATAL("Unexpected variability in EnumType::GetDIType()");
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        return llvm::DIType();
-#else // LLVM 3.7++
         return NULL;
-#endif
     }
 }
 
@@ -1137,21 +1002,12 @@ llvm::Type *PointerType::LLVMType(llvm::LLVMContext *ctx) const {
     }
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType PointerType::GetDIType(llvm::DIDescriptor scope) const {
-    if (baseType == NULL) {
-        Assert(m->errorCount > 0);
-        return llvm::DIType();
-    }
-    llvm::DIType diTargetType = baseType->GetDIType(scope);
-#else // LLVM 3.7++
 llvm::DIType *PointerType::GetDIType(llvm::DIScope *scope) const {
     if (baseType == NULL) {
         Assert(m->errorCount > 0);
         return NULL;
     }
     llvm::DIType *diTargetType = baseType->GetDIType(scope);
-#endif
     int bitsSize = g->target->is32Bit() ? 32 : 64;
     int ptrAlignBits = bitsSize;
     switch (variability.type) {
@@ -1159,12 +1015,7 @@ llvm::DIType *PointerType::GetDIType(llvm::DIScope *scope) const {
         return m->diBuilder->createPointerType(diTargetType, bitsSize, ptrAlignBits);
     case Variability::Varying: {
         // emit them as an array of pointers
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::DIType eltType =
-#else // LLVM 3.7++
-        llvm::DIDerivedType *eltType =
-#endif
-            m->diBuilder->createPointerType(diTargetType, bitsSize, ptrAlignBits);
+        llvm::DIDerivedType *eltType = m->diBuilder->createPointerType(diTargetType, bitsSize, ptrAlignBits);
         return lCreateDIArray(eltType, g->target->getVectorWidth());
     }
     case Variability::SOA: {
@@ -1173,11 +1024,7 @@ llvm::DIType *PointerType::GetDIType(llvm::DIScope *scope) const {
     }
     default:
         FATAL("Unexpected variability in PointerType::GetDIType()");
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        return llvm::DIType();
-#else // LLVM 3.7++
         return NULL;
-#endif
     }
 }
 
@@ -1387,21 +1234,12 @@ int ArrayType::TotalElementCount() const {
         return numElements;
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType ArrayType::GetDIType(llvm::DIDescriptor scope) const {
-    if (child == NULL) {
-        Assert(m->errorCount > 0);
-        return llvm::DIType();
-    }
-    llvm::DIType eltType = child->GetDIType(scope);
-#else // LLVM 3.7++
 llvm::DIType *ArrayType::GetDIType(llvm::DIScope *scope) const {
     if (child == NULL) {
         Assert(m->errorCount > 0);
         return NULL;
     }
     llvm::DIType *eltType = child->GetDIType(scope);
-#endif
     return lCreateDIArray(eltType, numElements);
 }
 
@@ -1572,33 +1410,18 @@ llvm::Type *VectorType::LLVMType(llvm::LLVMContext *ctx) const {
     }
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType VectorType::GetDIType(llvm::DIDescriptor scope) const {
-    llvm::DIType eltType = base->GetDIType(scope);
-#else // LLVM 3.7++
 llvm::DIType *VectorType::GetDIType(llvm::DIScope *scope) const {
     llvm::DIType *eltType = base->GetDIType(scope);
-#endif
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-    llvm::Value *sub = m->diBuilder->getOrCreateSubrange(0, numElements - 1);
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    llvm::Value *sub = m->diBuilder->getOrCreateSubrange(0, numElements);
-#else // LLVM 3.6++
-llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, numElements);
-#endif
+
+    llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, numElements);
 
     // vectors of varying types are already naturally aligned to the
     // machine's vector width, but arrays of uniform types need to be
     // explicitly aligned to the machines natural vector alignment.
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIArray subArray = m->diBuilder->getOrCreateArray(sub);
-    uint64_t sizeBits = eltType.getSizeInBits() * numElements;
-    uint64_t align = eltType.getAlignInBits();
-#else // LLVM 3.7++
+
     llvm::DINodeArray subArray = m->diBuilder->getOrCreateArray(sub);
     uint64_t sizeBits = eltType->getSizeInBits() * numElements;
     uint64_t align = eltType->getAlignInBits();
-#endif
 
     if (IsUniformType()) {
         llvm::Type *ty = this->LLVMType(g->ctx);
@@ -1612,11 +1435,7 @@ llvm::Metadata *sub = m->diBuilder->getOrCreateSubrange(0, numElements);
         return at.GetDIType(scope);
     } else {
         FATAL("Unexpected variability in VectorType::GetDIType()");
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        return llvm::DIType();
-#else // LLVM 3.7++
         return NULL;
-#endif
     }
 }
 
@@ -1949,86 +1768,6 @@ llvm::Type *StructType::LLVMType(llvm::LLVMContext *ctx) const {
 }
 
 // Versioning of this function becomes really messy, so versioning the whole function.
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType StructType::GetDIType(llvm::DIDescriptor scope) const {
-#else // LLVM 3.7++
-llvm::DIType *StructType::GetDIType(llvm::DIScope *scope) const {
-#endif
-    uint64_t currentSize = 0, align = 0;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    std::vector<llvm::Value *> elementLLVMTypes;
-#else // LLVM 3.6++
-    std::vector<llvm::Metadata *> elementLLVMTypes;
-#endif
-    // Walk through the elements of the struct; for each one figure out its
-    // alignment and size, using that to figure out its offset w.r.t. the
-    // start of the structure.
-    for (unsigned int i = 0; i < elementTypes.size(); ++i) {
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::DIType eltType = GetElementType(i)->GetDIType(scope);
-        uint64_t eltAlign = eltType.getAlignInBits();
-        uint64_t eltSize = eltType.getSizeInBits();
-#else // LLVM 3.7+
-        llvm::DIType *eltType = GetElementType(i)->GetDIType(scope);
-        uint64_t eltAlign = eltType->getAlignInBits();
-        uint64_t eltSize = eltType->getSizeInBits();
-#endif
-        Assert(eltAlign != 0);
-
-        // The alignment for the entire structure is the maximum of the
-        // required alignments of its elements
-        align = std::max(align, eltAlign);
-
-        // Move the current size forward if needed so that the current
-        // element starts at an offset that's the correct alignment.
-        if (currentSize > 0 && (currentSize % eltAlign))
-            currentSize += eltAlign - (currentSize % eltAlign);
-        Assert((currentSize == 0) || (currentSize % eltAlign) == 0);
-
-        int line = elementPositions[i].first_line;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-        llvm::DIFile diFile = elementPositions[i].GetDIFile();
-        llvm::DIType fieldType =
-#else // LLVM 3.7++
-        llvm::DIFile *diFile = elementPositions[i].GetDIFile();
-        llvm::DIDerivedType *fieldType =
-#endif
-            m->diBuilder->createMemberType(scope, elementNames[i], diFile, line, eltSize, eltAlign, currentSize, 0,
-                                           eltType);
-        elementLLVMTypes.push_back(fieldType);
-
-        currentSize += eltSize;
-    }
-
-    // Round up the struct's entire size so that it's a multiple of the
-    // required alignment that we figured out along the way...
-    if (currentSize > 0 && (currentSize % align))
-        currentSize += align - (currentSize % align);
-
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIArray elements = m->diBuilder->getOrCreateArray(elementLLVMTypes);
-    llvm::DIFile diFile = pos.GetDIFile();
-#else // LLVM 3.7++
-    llvm::DINodeArray elements = m->diBuilder->getOrCreateArray(elementLLVMTypes);
-    llvm::DIFile *diFile = pos.GetDIFile();
-#endif
-    return m->diBuilder->createStructType(diFile, name, diFile,
-                                          pos.first_line, // Line number
-                                          currentSize,    // Size in bits
-                                          align,          // Alignment in bits
-                                          0,              // Flags
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-                                          llvm::DIType(), // DerivedFrom
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7                  // LLVM 3.7++
-                                          NULL,
-#endif
-                                          elements);
-}
-
-#else // LLVM 4.0+
-
 llvm::DIType *StructType::GetDIType(llvm::DIScope *scope) const {
     llvm::Type *llvm_type = LLVMType(g->ctx);
     auto &dataLayout = m->module->getDataLayout();
@@ -2064,8 +1803,6 @@ llvm::DIType *StructType::GetDIType(llvm::DIScope *scope) const {
                                           NULL, elements);
 }
 
-#endif
-
 const Type *StructType::GetElementType(int i) const {
     Assert(variability != Variability::Unbound);
     Assert(i < (int)elementTypes.size());
@@ -2230,30 +1967,15 @@ llvm::Type *UndefinedStructType::LLVMType(llvm::LLVMContext *ctx) const {
     return lStructTypeMap[mname];
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType UndefinedStructType::GetDIType(llvm::DIDescriptor scope) const {
-    llvm::DIFile diFile = pos.GetDIFile();
-    llvm::DIArray elements;
-#else // LLVM 3.7++
 llvm::DIType *UndefinedStructType::GetDIType(llvm::DIScope *scope) const {
     llvm::DIFile *diFile = pos.GetDIFile();
     llvm::DINodeArray elements;
-#endif
     return m->diBuilder->createStructType(diFile, name, diFile,
-                                          pos.first_line, // Line number
-                                          0,              // Size
-                                          0,              // Align
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_9
-                                          0, // Flags
-#else                                        // LLVM 4.0+
+                                          pos.first_line,         // Line number
+                                          0,                      // Size
+                                          0,                      // Align
                                           llvm::DINode::FlagZero, // Flags
-#endif
-#if ISPC_LLVM_VERSION >= ISPC_LLVM_3_3 && ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-                                          llvm::DIType(), // DerivedFrom
-#elif ISPC_LLVM_VERSION >= ISPC_LLVM_3_7                  // LLVM 3.7+
-                                          NULL,
-#endif
-                                          elements);
+                                          NULL, elements);
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -2457,21 +2179,12 @@ llvm::Type *ReferenceType::LLVMType(llvm::LLVMContext *ctx) const {
     return llvm::PointerType::get(t, 0);
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType ReferenceType::GetDIType(llvm::DIDescriptor scope) const {
-    if (targetType == NULL) {
-        Assert(m->errorCount > 0);
-        return llvm::DIType();
-    }
-    llvm::DIType diTargetType = targetType->GetDIType(scope);
-#else // LLVM 3.7++
 llvm::DIType *ReferenceType::GetDIType(llvm::DIScope *scope) const {
     if (targetType == NULL) {
         Assert(m->errorCount > 0);
         return NULL;
     }
     llvm::DIType *diTargetType = targetType->GetDIType(scope);
-#endif
     return m->diBuilder->createReferenceType(llvm::dwarf::DW_TAG_reference_type, diTargetType);
 }
 
@@ -2666,48 +2379,20 @@ llvm::Type *FunctionType::LLVMType(llvm::LLVMContext *ctx) const {
     return NULL;
 }
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-llvm::DIType FunctionType::GetDIType(llvm::DIDescriptor scope) const {
-#else // LLVM 3.7++
 llvm::DIType *FunctionType::GetDIType(llvm::DIScope *scope) const {
-#endif
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    std::vector<llvm::Value *> retArgTypes;
-#else // LLVM 3.6++
     std::vector<llvm::Metadata *> retArgTypes;
-#endif
     retArgTypes.push_back(returnType->GetDIType(scope));
     for (int i = 0; i < GetNumParameters(); ++i) {
         const Type *t = GetParameterType(i);
         if (t == NULL)
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_3
-            return llvm::DIType();
-#elif ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-            return llvm::DICompositeType();
-#else // LLVM 3.7++
-        return NULL;
-#endif
+            return NULL;
         retArgTypes.push_back(t->GetDIType(scope));
     }
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_5
-    llvm::DIArray retArgTypesArray = m->diBuilder->getOrCreateArray(llvm::ArrayRef<llvm::Value *>(retArgTypes));
-    llvm::DIType diType =
-        // FIXME: DIFile
-        m->diBuilder->createSubroutineType(llvm::DIFile(), retArgTypesArray);
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_6
-    llvm::DITypeArray retArgTypesArray = m->diBuilder->getOrCreateTypeArray(retArgTypes);
-    llvm::DIType diType =
-        // FIXME: DIFile
-        m->diBuilder->createSubroutineType(llvm::DIFile(), retArgTypesArray);
-#elif ISPC_LLVM_VERSION == ISPC_LLVM_3_7 // LLVM 3.7
-llvm::DITypeRefArray retArgTypesArray = m->diBuilder->getOrCreateTypeArray(retArgTypes);
-llvm::DIType *diType = m->diBuilder->createSubroutineType(NULL, retArgTypesArray);
-#else                                    // LLVM 3.8+
-llvm::DITypeRefArray retArgTypesArray = m->diBuilder->getOrCreateTypeArray(retArgTypes);
-llvm::DIType *diType = m->diBuilder->createSubroutineType(retArgTypesArray);
-#endif
+
+    llvm::DITypeRefArray retArgTypesArray = m->diBuilder->getOrCreateTypeArray(retArgTypes);
+    llvm::DIType *diType = m->diBuilder->createSubroutineType(retArgTypesArray);
     return diType;
 }
 
diff --git a/src/type.h b/src/type.h
index 47796a1a..5cc021c9 100644
--- a/src/type.h
+++ b/src/type.h
@@ -40,14 +40,10 @@
 
 #include "ispc.h"
 #include "util.h"
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/DerivedTypes.h>
-#include <llvm/Type.h>
-#else // >= 3.3
+
+#include <llvm/ADT/SmallVector.h>
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/Type.h>
-#endif
-#include <llvm/ADT/SmallVector.h>
 
 class ConstExpr;
 class StructType;
@@ -210,15 +206,9 @@ class Type {
     /** Returns the LLVM type corresponding to this ispc type */
     virtual llvm::Type *LLVMType(llvm::LLVMContext *ctx) const = 0;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    /** Returns the DIType (LLVM's debugging information structure),
-        corresponding to this type. */
-    virtual llvm::DIType GetDIType(llvm::DIDescriptor scope) const = 0;
-#else
     /** Returns the DIType (LLVM's debugging information structure),
         corresponding to this type. */
     virtual llvm::DIType *GetDIType(llvm::DIScope *scope) const = 0;
-#endif
 
     /** Checks two types for equality.  Returns true if they are exactly
         the same, false otherwise. */
@@ -303,11 +293,8 @@ class AtomicType : public Type {
     std::string GetCDeclaration(const std::string &name) const;
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
     /** This enumerator records the basic types that AtomicTypes can be
         built from.  */
@@ -385,11 +372,8 @@ class EnumType : public Type {
     const std::string &GetEnumName() const { return name; }
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
     /** Provides the enumerators defined in the enum definition. */
     void SetEnumerators(const std::vector<Symbol *> &enumerators);
@@ -468,11 +452,8 @@ class PointerType : public Type {
     std::string GetCDeclaration(const std::string &name) const;
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
     static PointerType *Void;
 
@@ -571,11 +552,7 @@ class ArrayType : public SequentialType {
     std::string Mangle() const;
     std::string GetCDeclaration(const std::string &name) const;
 
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
     llvm::ArrayType *LLVMType(llvm::LLVMContext *ctx) const;
 
     /** This method returns the total number of elements in the array,
@@ -643,11 +620,8 @@ class VectorType : public SequentialType {
     std::string GetCDeclaration(const std::string &name) const;
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
     int GetElementCount() const;
     const AtomicType *GetElementType() const;
@@ -697,11 +671,8 @@ class StructType : public CollectionType {
     std::string GetCDeclaration(const std::string &name) const;
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
     /** Returns the type of the structure element with the given name (if any).
         Returns NULL if there is no such named element. */
@@ -787,11 +758,8 @@ class UndefinedStructType : public Type {
     std::string GetCDeclaration(const std::string &name) const;
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
     /** Returns the name of the structure type.  (e.g. struct Foo -> "Foo".) */
     const std::string &GetStructName() const { return name; }
@@ -833,11 +801,8 @@ class ReferenceType : public Type {
     std::string GetCDeclaration(const std::string &name) const;
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
   private:
     const Type *const targetType;
@@ -887,11 +852,8 @@ class FunctionType : public Type {
     std::string GetCDeclarationForDispatch(const std::string &fname) const;
 
     llvm::Type *LLVMType(llvm::LLVMContext *ctx) const;
-#if ISPC_LLVM_VERSION <= ISPC_LLVM_3_6
-    llvm::DIType GetDIType(llvm::DIDescriptor scope) const;
-#else // LLVM 3.7++
+
     llvm::DIType *GetDIType(llvm::DIScope *scope) const;
-#endif
 
     const Type *GetReturnType() const { return returnType; }
 
diff --git a/src/util.cpp b/src/util.cpp
index 3734b3b6..d5764c11 100644
--- a/src/util.cpp
+++ b/src/util.cpp
@@ -65,11 +65,7 @@
 #include <algorithm>
 #include <set>
 
-#if ISPC_LLVM_VERSION == ISPC_LLVM_3_2
-#include <llvm/DataLayout.h>
-#else // LLVM 3.3+
 #include <llvm/IR/DataLayout.h>
-#endif
 
 /** Returns the width of the terminal where the compiler is running.
     Finding this out may fail in a variety of reasonable situations (piping
