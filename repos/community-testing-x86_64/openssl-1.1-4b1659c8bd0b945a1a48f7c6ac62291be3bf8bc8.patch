From 4b1659c8bd0b945a1a48f7c6ac62291be3bf8bc8 Mon Sep 17 00:00:00 2001
From: Riccardo Magliocchetti <riccardo.magliocchetti@gmail.com>
Date: Sun, 6 Nov 2016 14:36:32 +0100
Subject: [PATCH] Cope with openssl 1.1 API changes

Since OpenSSL 1.1.0 made some structs opaque and this we cannot
poke with the internals anymore. Because of that we have to
disable the ssl session cache.

Ref #1395
---
 core/legion.c                 |  8 ++++++++
 core/ssl.c                    | 14 ++++++++++++--
 core/uwsgi.c                  |  2 ++
 plugins/http/spdy3.c          |  2 ++
 plugins/logcrypto/logcrypto.c |  4 ++++
 uwsgi.h                       |  8 ++++++--
 6 files changed, 34 insertions(+), 4 deletions(-)

diff --git a/core/legion.c b/core/legion.c
index da24158..c2bff5a 100644
--- a/core/legion.c
+++ b/core/legion.c
@@ -1074,8 +1074,12 @@ struct uwsgi_legion *uwsgi_legion_register(char *legion, char *addr, char *valor
 		uwsgi_ssl_init();
 	}
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 	EVP_CIPHER_CTX *ctx = uwsgi_malloc(sizeof(EVP_CIPHER_CTX));
 	EVP_CIPHER_CTX_init(ctx);
+#else
+	EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
+#endif
 
 	const EVP_CIPHER *cipher = EVP_get_cipherbyname(algo);
 	if (!cipher) {
@@ -1109,8 +1113,12 @@ struct uwsgi_legion *uwsgi_legion_register(char *legion, char *addr, char *valor
 		exit(1);
 	}
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 	EVP_CIPHER_CTX *ctx2 = uwsgi_malloc(sizeof(EVP_CIPHER_CTX));
 	EVP_CIPHER_CTX_init(ctx2);
+#else
+	EVP_CIPHER_CTX *ctx2 = EVP_CIPHER_CTX_new();
+#endif
 
 	if (EVP_DecryptInit_ex(ctx2, cipher, NULL, (const unsigned char *) secret, (const unsigned char *) iv) <= 0) {
 		uwsgi_error("EVP_DecryptInit_ex()");
diff --git a/core/ssl.c b/core/ssl.c
index 89f3a49..29778eb 100644
--- a/core/ssl.c
+++ b/core/ssl.c
@@ -14,20 +14,24 @@ set data in it with SSL_CTX_set_ex_data
 */
 
 void uwsgi_ssl_init(void) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         OPENSSL_config(NULL);
+#endif
         SSL_library_init();
         SSL_load_error_strings();
         OpenSSL_add_all_algorithms();
         uwsgi.ssl_initialized = 1;
 }
 
-void uwsgi_ssl_info_cb(SSL const *ssl, int where, int ret) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+void uwsgi_ssl_info_cb(const SSL *ssl, int where, int ret) {
         if (where & SSL_CB_HANDSHAKE_DONE) {
                 if (ssl->s3) {
                         ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;
                 }
         }
 }
+#endif
 
 int uwsgi_ssl_verify_callback(int ok, X509_STORE_CTX * x509_store) {
         if (!ok && uwsgi.ssl_verbose) {
@@ -44,6 +48,7 @@ int uwsgi_ssl_verify_callback(int ok, X509_STORE_CTX * x509_store) {
         return ok;
 }
 
+#ifdef UWSGI_SSL_SESSION_CACHE
 int uwsgi_ssl_session_new_cb(SSL *ssl, SSL_SESSION *sess) {
         char session_blob[4096];
         int len = i2d_SSL_SESSION(sess, NULL);
@@ -68,7 +73,7 @@ int uwsgi_ssl_session_new_cb(SSL *ssl, SSL_SESSION *sess) {
         return 0;
 }
 
-SSL_SESSION *uwsgi_ssl_session_get_cb(SSL *ssl, unsigned char *key, int keylen, int *copy) {
+SSL_SESSION *uwsgi_ssl_session_get_cb(SSL *ssl, const unsigned char *key, int keylen, int *copy) {
 
         uint64_t valsize = 0;
 
@@ -100,6 +105,7 @@ void uwsgi_ssl_session_remove_cb(SSL_CTX *ctx, SSL_SESSION *sess) {
         }
         uwsgi_rwunlock(uwsgi.ssl_sessions_cache->lock);
 }
+#endif
 
 #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
 static int uwsgi_sni_cb(SSL *ssl, int *ad, void *arg) {
@@ -356,7 +362,9 @@ SSL_CTX *uwsgi_ssl_new_server_context(char *name, char *crt, char *key, char *ci
         }
 
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         SSL_CTX_set_info_callback(ctx, uwsgi_ssl_info_cb);
+#endif
 #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
         SSL_CTX_set_tlsext_servername_callback(ctx, uwsgi_sni_cb);
 #endif
@@ -364,6 +372,7 @@ SSL_CTX *uwsgi_ssl_new_server_context(char *name, char *crt, char *key, char *ci
         // disable session caching by default
         SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
 
+#ifdef UWSGI_SSL_SESSION_CACHE
 	if (uwsgi.ssl_sessions_use_cache) {
 
 		// we need to early initialize locking and caching
@@ -408,6 +417,7 @@ SSL_CTX *uwsgi_ssl_new_server_context(char *name, char *crt, char *key, char *ci
                 SSL_CTX_sess_set_get_cb(ctx, uwsgi_ssl_session_get_cb);
                 SSL_CTX_sess_set_remove_cb(ctx, uwsgi_ssl_session_remove_cb);
         }
+#endif
 
         SSL_CTX_set_timeout(ctx, uwsgi.ssl_sessions_timeout);
 
diff --git a/core/uwsgi.c b/core/uwsgi.c
index f0b8aa8..430d8fb 100755
--- a/core/uwsgi.c
+++ b/core/uwsgi.c
@@ -693,11 +693,13 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"snmp-community", required_argument, 0, "set the snmp community string", uwsgi_opt_snmp_community, NULL, 0},
 #ifdef UWSGI_SSL
 	{"ssl-verbose", no_argument, 0, "be verbose about SSL errors", uwsgi_opt_true, &uwsgi.ssl_verbose, 0},
+#if UWSGI_SSL_SESSION_CACHE
 	// force master, as ssl sessions caching initialize locking early
 	{"ssl-sessions-use-cache", optional_argument, 0, "use uWSGI cache for ssl sessions storage", uwsgi_opt_set_str, &uwsgi.ssl_sessions_use_cache, UWSGI_OPT_MASTER},
 	{"ssl-session-use-cache", optional_argument, 0, "use uWSGI cache for ssl sessions storage", uwsgi_opt_set_str, &uwsgi.ssl_sessions_use_cache, UWSGI_OPT_MASTER},
 	{"ssl-sessions-timeout", required_argument, 0, "set SSL sessions timeout (default: 300 seconds)", uwsgi_opt_set_int, &uwsgi.ssl_sessions_timeout, 0},
 	{"ssl-session-timeout", required_argument, 0, "set SSL sessions timeout (default: 300 seconds)", uwsgi_opt_set_int, &uwsgi.ssl_sessions_timeout, 0},
+#endif
 	{"sni", required_argument, 0, "add an SNI-governed SSL context", uwsgi_opt_sni, NULL, 0},
 	{"sni-dir", required_argument, 0, "check for cert/key/client_ca file in the specified directory and create a sni/ssl context on demand", uwsgi_opt_set_str, &uwsgi.sni_dir, 0},
 	{"sni-dir-ciphers", required_argument, 0, "set ssl ciphers for sni-dir option", uwsgi_opt_set_str, &uwsgi.sni_dir_ciphers, 0},
diff --git a/plugins/http/spdy3.c b/plugins/http/spdy3.c
index 858a2fc..8c80f82 100644
--- a/plugins/http/spdy3.c
+++ b/plugins/http/spdy3.c
@@ -840,9 +840,11 @@ void uwsgi_spdy_info_cb(SSL const *ssl, int where, int ret) {
 				//hr->spdy_hook = hr_recv_spdy_control_frame;
 			}
 		}
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
                 if (ssl->s3) {
                         ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;
                 }
+#endif
         }
 }
 
diff --git a/plugins/logcrypto/logcrypto.c b/plugins/logcrypto/logcrypto.c
index 34417ee..3362fcc 100644
--- a/plugins/logcrypto/logcrypto.c
+++ b/plugins/logcrypto/logcrypto.c
@@ -32,8 +32,12 @@ static void uwsgi_crypto_logger_setup_encryption(struct uwsgi_crypto_logger_conf
                 uwsgi_ssl_init();
         }
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         uclc->encrypt_ctx = uwsgi_malloc(sizeof(EVP_CIPHER_CTX));
         EVP_CIPHER_CTX_init(uclc->encrypt_ctx);
+#else
+        uclc->encrypt_ctx = EVP_CIPHER_CTX_new();
+#endif
 
         const EVP_CIPHER *cipher = EVP_get_cipherbyname(uclc->algo);
         if (!cipher) {
diff --git a/uwsgi.h b/uwsgi.h
index c5a3f3e..121c3d7 100755
--- a/uwsgi.h
+++ b/uwsgi.h
@@ -364,9 +364,13 @@ extern int pivot_root(const char *new_root, const char *put_old);
 #define UWSGI_CACHE_FLAG_FIXEXPIRE	1 << 9
 
 #ifdef UWSGI_SSL
-#include "openssl/conf.h"
-#include "openssl/ssl.h"
+#include <openssl/conf.h>
+#include <openssl/ssl.h>
 #include <openssl/err.h>
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#define UWSGI_SSL_SESSION_CACHE
+#endif
 #endif
 
 #include <glob.h>
