--- ipynb-0.1/test/roundtrip.hs.orig	2020-04-26 07:02:19.792033245 +0800
+++ ipynb-0.1/test/roundtrip.hs	2020-04-26 07:02:34.438786334 +0800
@@ -49,7 +49,7 @@
        case Base64.decode (TE.encodeUtf8 (T.filter (/='\n') t)) of
             Left _  -> String t  -- textual
             Right b -> String $
-              TE.decodeUtf8 . Base64.joinWith "\n" 76 . Base64.encode $ b
+              TE.decodeUtf8 . joinWith "\n" 76 . Base64.encode $ b
      go v = v

 rtTest :: FilePath -> TestTree
--- ipynb-0.1/src/Data/Ipynb.hs.orig	2020-04-26 07:00:34.408032416 +0800
+++ ipynb-0.1/src/Data/Ipynb.hs	2020-04-26 07:47:18.956882066 +0800
@@ -1,3 +1,4 @@
+{-# LANGUAGE BangPatterns               #-}
 {-# LANGUAGE CPP                        #-}
 {-# LANGUAGE DeriveGeneric              #-}
 {-# LANGUAGE FlexibleContexts           #-}
@@ -38,13 +39,17 @@
                   , MimeData(..)
                   , MimeBundle(..)
                   , breakLines
+                  , joinWith
                   )
 where
 import Control.Applicative ((<|>))
+import Control.Exception (assert)
 import Control.Monad (when)
 import Data.Aeson as Aeson
 import qualified Data.Aeson.Types as Aeson
 import Data.ByteString (ByteString)
+import qualified Data.ByteString as B
+import Data.ByteString.Internal
 import qualified Data.ByteString.Base64 as Base64
 import Data.Char (isSpace)
 import qualified Data.HashMap.Strict as HM
@@ -54,6 +59,8 @@
 import Data.Text (Text)
 import qualified Data.Text as T
 import qualified Data.Text.Encoding as TE
+import Foreign.ForeignPtr (withForeignPtr)
+import Foreign.Ptr (minusPtr, plusPtr)
 import GHC.Generics
 import Prelude
 #if MIN_VERSION_base(4,11,0)
@@ -480,10 +487,52 @@
             Left _  -> return (mt, TextualData t)
             Right b -> return (mt, BinaryData b)
 
+-- | Efficiently intersperse a terminator string into another at
+-- regular intervals, and terminate the input with it.
+--
+-- Examples:
+--
+-- > joinWith "|" 2 "----" = "--|--|"
+--
+-- > joinWith "\r\n" 3 "foobarbaz" = "foo\r\nbar\r\nbaz\r\n"
+-- > joinWith "x" 3 "fo" = "fox"
+joinWith :: ByteString  -- ^ String to intersperse and end with
+         -> Int         -- ^ Interval at which to intersperse, in bytes
+         -> ByteString  -- ^ String to transform
+         -> ByteString
+joinWith brk@(PS bfp boff blen) every' bs@(PS sfp soff slen)
+    | every' <= 0 = error "invalid interval"
+    | blen <= 0  = bs
+    | B.null bs = brk
+    | otherwise =
+  unsafeCreate dlen $ \dptr ->
+    withForeignPtr bfp $ \bptr -> do
+      withForeignPtr sfp $ \sptr -> do
+          let bp = bptr `plusPtr` boff
+              sp0 = sptr `plusPtr` soff
+              sEnd = sp0 `plusPtr` slen
+              dLast = dptr `plusPtr` dlen
+              loop !dp !sp !written
+                  | dp == dLast = return ()
+                  | otherwise = do
+                let chunkSize = min every (sEnd `minusPtr` sp)
+                memcpy dp sp (fromIntegral chunkSize)
+                let dp' = dp `plusPtr` chunkSize
+                memcpy dp' bp (fromIntegral blen)
+                let written' = written + chunkSize + blen
+                assert (written' <= dlen) $
+                  loop (dp' `plusPtr` blen) (sp `plusPtr` chunkSize) written'
+          loop dptr sp0 0
+  where dlast = slen + blen * numBreaks
+        every = min slen every'
+        dlen | rmndr > 0   = dlast + blen
+             | otherwise   = dlast
+        (numBreaks, rmndr) = slen `divMod` every
+
 instance ToJSON MimeBundle where
   toJSON (MimeBundle m) =
     let mimeBundleToValue (BinaryData bs) =
-          toJSON $ TE.decodeUtf8 . Base64.joinWith "\n" 76 . Base64.encode $ bs
+          toJSON $ TE.decodeUtf8 . joinWith "\n" 76 . Base64.encode $ bs
         mimeBundleToValue (JsonData v) = v
         mimeBundleToValue (TextualData t) = toJSON (breakLines t)
     in  toJSON $ M.map mimeBundleToValue m
