diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -167,6 +167,6 @@ endif()
 set(CLANG_LIBRARY_LIST clangFrontend clangDriver clangSerialization clangParse clangSema clangAnalysis clangAST clangBasic clangEdit clangLex)
-set(LLVM_COMPONENTS engine ipo bitreader bitwriter instrumentation linker option)
+set(LLVM_COMPONENTS engine ipo bitreader bitwriter instrumentation linker option frontendopenmp)
 
 list(APPEND LLVM_COMPONENTS x86)
 if (ARM_ENABLED)
     list(APPEND LLVM_COMPONENTS arm aarch64)
diff --git a/src/cbackend.cpp b/src/cbackend.cpp
index 89c9c581..ea2f9b9b 100644
--- a/src/cbackend.cpp
+++ b/src/cbackend.cpp
@@ -54,6 +54,7 @@
 #include "llvm/IR/Module.h"
 #include "llvm/IR/TypeFinder.h"
 #include "llvm/IR/Verifier.h"
+#include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/FileSystem.h"
 #include <llvm/IR/IRPrintingPasses.h>
@@ -84,6 +85,10 @@
 #if ISPC_LLVM_VERSION >= ISPC_LLVM_8_0
 #include "llvm/IR/PatternMatch.h"
 #endif
+#if ISPC_LLVM_VERSION >= ISPC_LLVM_10_0
+#include "llvm/IR/IntrinsicsPowerPC.h"
+#include "llvm/IR/IntrinsicsX86.h"
+#endif
 #include <algorithm>
 // Some ms header decided to define setjmp as _setjmp, undo this for this file.
 #ifdef _MSC_VER
@@ -3983,8 +3988,6 @@ void CWriter::lowerIntrinsics(llvm::Function &F) {
                     case llvm::Intrinsic::vaend:
                     case llvm::Intrinsic::returnaddress:
                     case llvm::Intrinsic::frameaddress:
-                    case llvm::Intrinsic::setjmp:
-                    case llvm::Intrinsic::longjmp:
                     case llvm::Intrinsic::memset:
                     case llvm::Intrinsic::prefetch:
                     case llvm::Intrinsic::powi:
@@ -4282,18 +4285,6 @@ bool CWriter::visitBuiltinCall(llvm::CallInst &I, llvm::Intrinsic::ID ID, bool &
         writeOperand(I.getArgOperand(0));
         Out << ')';
         return true;
-    case llvm::Intrinsic::setjmp:
-        Out << "setjmp(*(jmp_buf*)";
-        writeOperand(I.getArgOperand(0));
-        Out << ')';
-        return true;
-    case llvm::Intrinsic::longjmp:
-        Out << "longjmp(*(jmp_buf*)";
-        writeOperand(I.getArgOperand(0));
-        Out << ", ";
-        writeOperand(I.getArgOperand(1));
-        Out << ')';
-        return true;
     case llvm::Intrinsic::memset:
         Out << "Memset(";
         writeOperand(I.getArgOperand(0));
@@ -4784,15 +4775,16 @@ void CWriter::visitAtomicCmpXchgInst(llvm::AtomicCmpXchgInst &ACXI) {
 ///////////////////////////////////////////////////////////////////////////
 // SmearCleanupPass
 
-class SmearCleanupPass : public llvm::BasicBlockPass {
+class SmearCleanupPass : public llvm::FunctionPass {
   public:
-    SmearCleanupPass(llvm::Module *m, int width) : BasicBlockPass(ID) {
+    SmearCleanupPass(llvm::Module *m, int width) : FunctionPass(ID) {
         module = m;
         vectorWidth = width;
     }
 
     llvm::StringRef getPassName() const { return "Smear Cleanup Pass"; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 
     static char ID;
     llvm::Module *module;
@@ -4967,15 +4959,25 @@ bool SmearCleanupPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool SmearCleanupPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 ///////////////////////////////////////////////////////////////////////////
 // AndCmpCleanupPass
 
-class AndCmpCleanupPass : public llvm::BasicBlockPass {
+class AndCmpCleanupPass : public llvm::FunctionPass {
   public:
-    AndCmpCleanupPass() : BasicBlockPass(ID) {}
+    AndCmpCleanupPass() : FunctionPass(ID) {}
 
     llvm::StringRef getPassName() const { return "AndCmp Cleanup Pass"; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 
     static char ID;
 };
@@ -5064,6 +5066,15 @@ bool AndCmpCleanupPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool AndCmpCleanupPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 ///////////////////////////////////////////////////////////////////////////
 // MaskOpsCleanupPass
 
@@ -5073,9 +5084,9 @@ bool AndCmpCleanupPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     __and_not1(a, b) (and similarly if the second operand has not applied
     to it...)
  */
-class MaskOpsCleanupPass : public llvm::BasicBlockPass {
+class MaskOpsCleanupPass : public llvm::FunctionPass {
   public:
-    MaskOpsCleanupPass(llvm::Module *m) : BasicBlockPass(ID) {
+    MaskOpsCleanupPass(llvm::Module *m) : FunctionPass(ID) {
         llvm::Type *mt = LLVMTypes::MaskType;
 
         // Declare the __not, __and_not1, and __and_not2 functions that we
@@ -5112,6 +5123,7 @@ class MaskOpsCleanupPass : public llvm::BasicBlockPass {
 
     llvm::StringRef getPassName() const { return "MaskOps Cleanup Pass"; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 
   private:
     llvm::Value *lGetNotOperand(llvm::Value *v) const;
@@ -5211,6 +5223,15 @@ bool MaskOpsCleanupPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool MaskOpsCleanupPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 //===----------------------------------------------------------------------===//
 //                       External Interface declaration
 //===----------------------------------------------------------------------===//
diff --git a/src/ctx.cpp b/src/ctx.cpp
index 5824194c..80913564 100644
--- a/src/ctx.cpp
+++ b/src/ctx.cpp
@@ -280,7 +280,11 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
             llvm::BasicBlock *offBB = llvm::BasicBlock::Create(*g->ctx, "entry", (llvm::Function *)offFunc, 0);
             llvm::StoreInst *inst = new llvm::StoreInst(LLVMMaskAllOff, globalAllOnMaskPtr, offBB);
             if (g->opt.forceAlignedMemory) {
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
                 inst->setAlignment(g->target->getNativeVectorAlignment());
+#else // LLVM 10.0+
+                inst->setAlignment(llvm::MaybeAlign(g->target->getNativeVectorAlignment()));
+#endif
             }
             llvm::ReturnInst::Create(*g->ctx, offBB);
         }
@@ -2133,7 +2137,11 @@ llvm::Value *FunctionEmitContext::LoadInst(llvm::Value *ptr, const char *name) {
     llvm::LoadInst *inst = new llvm::LoadInst(ptr, name, bblock);
 
     if (g->opt.forceAlignedMemory && llvm::dyn_cast<llvm::VectorType>(pt->getElementType())) {
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
         inst->setAlignment(g->target->getNativeVectorAlignment());
+#else // LLVM 10.0+
+        inst->setAlignment(llvm::MaybeAlign(g->target->getNativeVectorAlignment()));
+#endif
     }
 
     AddDebugPos(inst);
@@ -2247,7 +2255,12 @@ llvm::Value *FunctionEmitContext::LoadInst(llvm::Value *ptr, llvm::Value *mask,
                 // it's totally unaligned.  (This shouldn't make any difference
                 // vs the proper alignment in practice.)
                 align = 1;
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
             llvm::Instruction *inst = new llvm::LoadInst(ptr, name, false /* not volatile */, align, bblock);
+#else // LLVM 10.0+
+            llvm::Instruction *inst =
+                new llvm::LoadInst(ptr, name, false /* not volatile */, llvm::MaybeAlign(align), bblock);
+#endif
             AddDebugPos(inst);
             return inst;
         }
@@ -2424,8 +2437,13 @@ llvm::Value *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, const char *n
     if (align == 0 && arrayType != NULL && !llvm::isa<llvm::VectorType>(arrayType->getElementType()))
         align = g->target->getNativeVectorAlignment();
 
-    if (align != 0)
+    if (align != 0) {
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
         inst->setAlignment(align);
+#else // LLVM 10.0+
+        inst->setAlignment(llvm::MaybeAlign(align));
+#endif
+    }
     // Don't add debugging info to alloca instructions
     return inst;
 }
@@ -2647,7 +2665,11 @@ void FunctionEmitContext::StoreInst(llvm::Value *value, llvm::Value *ptr) {
     llvm::StoreInst *inst = new llvm::StoreInst(value, ptr, bblock);
 
     if (g->opt.forceAlignedMemory && llvm::dyn_cast<llvm::VectorType>(pt->getElementType())) {
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
         inst->setAlignment(g->target->getNativeVectorAlignment());
+#else // LLVM 10.0+
+        inst->setAlignment(llvm::MaybeAlign(g->target->getNativeVectorAlignment()));
+#endif
     }
 
     AddDebugPos(inst);
diff --git a/src/ispc_version.h b/src/ispc_version.h
index ca53b3af..4aa6fe86 100644
--- a/src/ispc_version.h
+++ b/src/ispc_version.h
@@ -51,9 +51,10 @@
 #define ISPC_LLVM_8_0 80000
 #define ISPC_LLVM_9_0 90000
 #define ISPC_LLVM_10_0 100000
+#define ISPC_LLVM_11_0 110000
 
 #define OLDEST_SUPPORTED_LLVM ISPC_LLVM_6_0
-#define LATEST_SUPPORTED_LLVM ISPC_LLVM_10_0
+#define LATEST_SUPPORTED_LLVM ISPC_LLVM_11_0
 
 #ifdef __ispc__xstr
 #undef __ispc__xstr
diff --git a/src/main.cpp b/src/main.cpp
index 1ea1213c..b2dc6223 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -46,6 +46,7 @@
 #else
 #include <unistd.h>
 #endif // ISPC_HOST_IS_WINDOWS
+#include <llvm/Support/CommandLine.h>
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/Signals.h>
 #include <llvm/Support/TargetRegistry.h>
diff --git a/src/module.cpp b/src/module.cpp
index 1b44513d..de32a3d0 100644
--- a/src/module.cpp
+++ b/src/module.cpp
@@ -1127,9 +1127,15 @@ bool Module::writeObjectFileOrAssembly(llvm::TargetMachine *targetMachine, llvm:
                                        const char *outFileName) {
     // Figure out if we're generating object file or assembly output, and
     // set binary output for object files
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
     llvm::TargetMachine::CodeGenFileType fileType =
         (outputType == Object) ? llvm::TargetMachine::CGFT_ObjectFile : llvm::TargetMachine::CGFT_AssemblyFile;
     bool binary = (fileType == llvm::TargetMachine::CGFT_ObjectFile);
+#else // LLVM 10.0+
+    llvm::CodeGenFileType fileType = (outputType == Object) ? llvm::CGFT_ObjectFile : llvm::CGFT_AssemblyFile;
+    bool binary = (fileType == llvm::CGFT_ObjectFile);
+#endif
+
     llvm::sys::fs::OpenFlags flags = binary ? llvm::sys::fs::F_None : llvm::sys::fs::F_Text;
 
     std::error_code error;
@@ -2090,7 +2096,12 @@ void Module::execPreprocessor(const char *infilename, llvm::raw_string_ostream *
     inst.setTarget(target);
     inst.createSourceManager(inst.getFileManager());
 
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
     clang::FrontendInputFile inputFile(infilename, clang::InputKind::Unknown);
+#else // LLVM 10.0+
+    clang::FrontendInputFile inputFile(infilename, clang::InputKind());
+#endif
+
     inst.InitializeSourceManager(inputFile);
 
     // Don't remove comments in the preprocessor, so that we can accurately
diff --git a/src/opt.cpp b/src/opt.cpp
index 2281a461..58355668 100644
--- a/src/opt.cpp
+++ b/src/opt.cpp
@@ -47,6 +47,7 @@
 #include <set>
 #include <stdio.h>
 
+#include "llvm/InitializePasses.h"
 #include <llvm/IR/BasicBlock.h>
 #include <llvm/IR/Constants.h>
 #include <llvm/IR/Function.h>
@@ -94,6 +95,9 @@
 #include <llvm/BinaryFormat/Dwarf.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Target/TargetMachine.h>
+#if ISPC_LLVM_VERSION >= ISPC_LLVM_10_0
+#include "llvm/IR/IntrinsicsX86.h"
+#endif
 
 #include <llvm/IR/IntrinsicInst.h>
 #ifdef ISPC_HOST_IS_LINUX
@@ -783,14 +787,16 @@ void Optimize(llvm::Module *module, int optLevel) {
     @todo The better thing to do would be to submit a patch to LLVM to get
     these; they're presumably pretty simple patterns to match.
 */
-class IntrinsicsOpt : public llvm::BasicBlockPass {
+class IntrinsicsOpt : public llvm::FunctionPass {
   public:
-    IntrinsicsOpt() : BasicBlockPass(ID){};
+    IntrinsicsOpt() : FunctionPass(ID){};
 
     llvm::StringRef getPassName() const { return "Intrinsics Cleanup Optimization"; }
 
     bool runOnBasicBlock(llvm::BasicBlock &BB);
 
+    bool runOnFunction(llvm::Function &F);
+
     static char ID;
 
   private:
@@ -981,7 +987,12 @@ bool IntrinsicsOpt::runOnBasicBlock(llvm::BasicBlock &bb) {
                         align = callInst->getCalledFunction() == avxMaskedLoad32 ? 4 : 8;
                     name = LLVMGetName(callInst->getArgOperand(0), "_load");
                     llvm::Instruction *loadInst =
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
                         new llvm::LoadInst(castPtr, name, false /* not volatile */, align, (llvm::Instruction *)NULL);
+#else // LLVM 10.0+
+                        new llvm::LoadInst(castPtr, name, false /* not volatile */, llvm::MaybeAlign(align),
+                                           (llvm::Instruction *)NULL);
+#endif
                     lCopyMetadata(loadInst, callInst);
                     llvm::ReplaceInstWithInst(callInst, loadInst);
                     modifiedAny = true;
@@ -1014,7 +1025,11 @@ bool IntrinsicsOpt::runOnBasicBlock(llvm::BasicBlock &bb) {
                         align = g->target->getNativeVectorAlignment();
                     else
                         align = callInst->getCalledFunction() == avxMaskedStore32 ? 4 : 8;
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
                     storeInst->setAlignment(align);
+#else // LLVM 10.0+
+                    storeInst->setAlignment(llvm::MaybeAlign(align));
+#endif
                     lCopyMetadata(storeInst, callInst);
                     llvm::ReplaceInstWithInst(callInst, storeInst);
 
@@ -1030,6 +1045,15 @@ bool IntrinsicsOpt::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool IntrinsicsOpt::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 bool IntrinsicsOpt::matchesMaskInstruction(llvm::Function *function) {
     for (unsigned int i = 0; i < maskInstructions.size(); ++i) {
         if (maskInstructions[i].function != NULL && function == maskInstructions[i].function) {
@@ -1059,12 +1083,13 @@ static llvm::Pass *CreateIntrinsicsOptPass() { return new IntrinsicsOpt; }
     @todo The better thing to do would be to submit a patch to LLVM to get
     these; they're presumably pretty simple patterns to match.
 */
-class InstructionSimplifyPass : public llvm::BasicBlockPass {
+class InstructionSimplifyPass : public llvm::FunctionPass {
   public:
-    InstructionSimplifyPass() : BasicBlockPass(ID) {}
+    InstructionSimplifyPass() : FunctionPass(ID) {}
 
     llvm::StringRef getPassName() const { return "Vector Select Optimization"; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 
     static char ID;
 
@@ -1189,6 +1214,15 @@ bool InstructionSimplifyPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool InstructionSimplifyPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 static llvm::Pass *CreateInstructionSimplifyPass() { return new InstructionSimplifyPass; }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -1204,14 +1238,16 @@ static llvm::Pass *CreateInstructionSimplifyPass() { return new InstructionSimpl
     See for example the comments discussing the __pseudo_gather functions
     in builtins.cpp for more information about this.
  */
-class ImproveMemoryOpsPass : public llvm::BasicBlockPass {
+class ImproveMemoryOpsPass : public llvm::FunctionPass {
   public:
     static char ID;
-    ImproveMemoryOpsPass() : BasicBlockPass(ID) {}
+    ImproveMemoryOpsPass() : FunctionPass(ID) {}
 
     llvm::StringRef getPassName() const { return "Improve Memory Ops"; }
 
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+
+    bool runOnFunction(llvm::Function &F);
 };
 
 char ImproveMemoryOpsPass::ID = 0;
@@ -2753,7 +2789,12 @@ static bool lImproveMaskedStore(llvm::CallInst *callInst) {
         lCopyMetadata(lvalue, callInst);
         llvm::Instruction *store =
             new llvm::StoreInst(rvalue, lvalue, false /* not volatile */,
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
                                 g->opt.forceAlignedMemory ? g->target->getNativeVectorAlignment() : info->align);
+#else // LLVM 10.0+
+                                llvm::MaybeAlign(g->opt.forceAlignedMemory ? g->target->getNativeVectorAlignment()
+                                                                           : info->align));
+#endif
         lCopyMetadata(store, callInst);
         llvm::ReplaceInstWithInst(callInst, store);
         return true;
@@ -2804,7 +2845,12 @@ static bool lImproveMaskedLoad(llvm::CallInst *callInst, llvm::BasicBlock::itera
         ptr = new llvm::BitCastInst(ptr, ptrType, "ptr_cast_for_load", callInst);
         llvm::Instruction *load = new llvm::LoadInst(
             ptr, callInst->getName(), false /* not volatile */,
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
             g->opt.forceAlignedMemory ? g->target->getNativeVectorAlignment() : info->align, (llvm::Instruction *)NULL);
+#else // LLVM 10.0+
+            llvm::MaybeAlign(g->opt.forceAlignedMemory ? g->target->getNativeVectorAlignment() : info->align),
+            (llvm::Instruction *)NULL);
+#endif
         lCopyMetadata(load, callInst);
         llvm::ReplaceInstWithInst(callInst, load);
         return true;
@@ -2853,6 +2899,15 @@ bool ImproveMemoryOpsPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool ImproveMemoryOpsPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 static llvm::Pass *CreateImproveMemoryOpsPass() { return new ImproveMemoryOpsPass; }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -2877,13 +2932,14 @@ static llvm::Pass *CreateImproveMemoryOpsPass() { return new ImproveMemoryOpsPas
 //  in this case, we're often able to generate wide vector loads and
 //  appropriate shuffles automatically.
 
-class GatherCoalescePass : public llvm::BasicBlockPass {
+class GatherCoalescePass : public llvm::FunctionPass {
   public:
     static char ID;
-    GatherCoalescePass() : BasicBlockPass(ID) {}
+    GatherCoalescePass() : FunctionPass(ID) {}
 
     llvm::StringRef getPassName() const { return "Gather Coalescing"; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 };
 
 char GatherCoalescePass::ID = 0;
@@ -3137,7 +3193,11 @@ llvm::Value *lGEPAndLoad(llvm::Value *basePtr, int64_t offset, int align, llvm::
                          llvm::Type *type) {
     llvm::Value *ptr = lGEPInst(basePtr, LLVMInt64(offset), "new_base", insertBefore);
     ptr = new llvm::BitCastInst(ptr, llvm::PointerType::get(type, 0), "ptr_cast", insertBefore);
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
     return new llvm::LoadInst(ptr, "gather_load", false /* not volatile */, align, insertBefore);
+#else // LLVM 10.0+
+    return new llvm::LoadInst(ptr, "gather_load", false /* not volatile */, llvm::MaybeAlign(align), insertBefore);
+#endif
 }
 
 /* Having decided that we're doing to emit a series of loads, as encoded in
@@ -3837,6 +3897,15 @@ bool GatherCoalescePass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool GatherCoalescePass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 static llvm::Pass *CreateGatherCoalescePass() { return new GatherCoalescePass; }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -3846,13 +3915,14 @@ static llvm::Pass *CreateGatherCoalescePass() { return new GatherCoalescePass; }
     runs, we need to turn them into actual native gathers and scatters.
     This task is handled by the ReplacePseudoMemoryOpsPass here.
  */
-class ReplacePseudoMemoryOpsPass : public llvm::BasicBlockPass {
+class ReplacePseudoMemoryOpsPass : public llvm::FunctionPass {
   public:
     static char ID;
-    ReplacePseudoMemoryOpsPass() : BasicBlockPass(ID) {}
+    ReplacePseudoMemoryOpsPass() : FunctionPass(ID) {}
 
     llvm::StringRef getPassName() const { return "Replace Pseudo Memory Ops"; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 };
 
 char ReplacePseudoMemoryOpsPass::ID = 0;
@@ -4122,6 +4192,15 @@ bool ReplacePseudoMemoryOpsPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool ReplacePseudoMemoryOpsPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 static llvm::Pass *CreateReplacePseudoMemoryOpsPass() { return new ReplacePseudoMemoryOpsPass; }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -4140,13 +4219,14 @@ static llvm::Pass *CreateReplacePseudoMemoryOpsPass() { return new ReplacePseudo
     See stdlib.m4 for a number of uses of this idiom.
  */
 
-class IsCompileTimeConstantPass : public llvm::BasicBlockPass {
+class IsCompileTimeConstantPass : public llvm::FunctionPass {
   public:
     static char ID;
-    IsCompileTimeConstantPass(bool last = false) : BasicBlockPass(ID) { isLastTry = last; }
+    IsCompileTimeConstantPass(bool last = false) : FunctionPass(ID) { isLastTry = last; }
 
     llvm::StringRef getPassName() const { return "Resolve \"is compile time constant\""; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 
     bool isLastTry;
 };
@@ -4215,6 +4295,15 @@ bool IsCompileTimeConstantPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool IsCompileTimeConstantPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 static llvm::Pass *CreateIsCompileTimeConstantPass(bool isLastTry) { return new IsCompileTimeConstantPass(isLastTry); }
 
 //////////////////////////////////////////////////////////////////////////
@@ -4482,19 +4571,20 @@ static llvm::Pass *CreateMakeInternalFuncsStaticPass() { return new MakeInternal
 ///////////////////////////////////////////////////////////////////////////
 // PeepholePass
 
-class PeepholePass : public llvm::BasicBlockPass {
+class PeepholePass : public llvm::FunctionPass {
   public:
     PeepholePass();
 
     llvm::StringRef getPassName() const { return "Peephole Optimizations"; }
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+    bool runOnFunction(llvm::Function &F);
 
     static char ID;
 };
 
 char PeepholePass::ID = 0;
 
-PeepholePass::PeepholePass() : BasicBlockPass(ID) {}
+PeepholePass::PeepholePass() : FunctionPass(ID) {}
 
 using namespace llvm::PatternMatch;
 
@@ -4770,6 +4860,15 @@ bool PeepholePass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool PeepholePass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 static llvm::Pass *CreatePeepholePass() { return new PeepholePass; }
 
 /** Given an llvm::Value known to be an integer, return its value as
@@ -4784,14 +4883,16 @@ static int64_t lGetIntValue(llvm::Value *offset) {
 ///////////////////////////////////////////////////////////////////////////
 // ReplaceStdlibShiftPass
 
-class ReplaceStdlibShiftPass : public llvm::BasicBlockPass {
+class ReplaceStdlibShiftPass : public llvm::FunctionPass {
   public:
     static char ID;
-    ReplaceStdlibShiftPass() : BasicBlockPass(ID) {}
+    ReplaceStdlibShiftPass() : FunctionPass(ID) {}
 
     llvm::StringRef getPassName() const { return "Resolve \"replace extract insert chains\""; }
 
     bool runOnBasicBlock(llvm::BasicBlock &BB);
+
+    bool runOnFunction(llvm::Function &F);
 };
 
 char ReplaceStdlibShiftPass::ID = 0;
@@ -4854,6 +4955,15 @@ bool ReplaceStdlibShiftPass::runOnBasicBlock(llvm::BasicBlock &bb) {
     return modifiedAny;
 }
 
+bool ReplaceStdlibShiftPass::runOnFunction(llvm::Function &F) {
+
+    bool modifiedAny = false;
+    for (llvm::BasicBlock &BB : F) {
+        modifiedAny |= runOnBasicBlock(BB);
+    }
+    return modifiedAny;
+}
+
 static llvm::Pass *CreateReplaceStdlibShiftPass() { return new ReplaceStdlibShiftPass(); }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/src/type.cpp b/src/type.cpp
index b90063a3..9678692c 100644
--- a/src/type.cpp
+++ b/src/type.cpp
@@ -1796,10 +1796,14 @@ llvm::DIType *StructType::GetDIType(llvm::DIScope *scope) const {
     llvm::DINodeArray elements = m->diBuilder->getOrCreateArray(elementLLVMTypes);
     llvm::DIFile *diFile = pos.GetDIFile();
     return m->diBuilder->createStructType(diFile, name, diFile,
-                                          pos.first_line,             // Line number
-                                          layout->getSizeInBits(),    // Size in bits
+                                          pos.first_line,          // Line number
+                                          layout->getSizeInBits(), // Size in bits
+#if ISPC_LLVM_VERSION <= ISPC_LLVM_9_0
                                           layout->getAlignment() * 8, // Alignment in bits
-                                          llvm::DINode::FlagZero,     // Flags
+#else                                                                 // LLVM 10.0+
+                                          layout->getAlignment().value() * 8, // Alignment in bits
+#endif
+                                          llvm::DINode::FlagZero, // Flags
                                           NULL, elements);
 }
 
