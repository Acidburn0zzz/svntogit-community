diff --git a/binaries/convert_encoded_to_raw_leveldb.cc b/binaries/convert_encoded_to_raw_leveldb.cc
index c8ad32015..dea93d75a 100644
--- a/binaries/convert_encoded_to_raw_leveldb.cc
+++ b/binaries/convert_encoded_to_raw_leveldb.cc
@@ -109,7 +109,7 @@ void ConvertToRawDataset(
     cv::Mat img = cv::imdecode(
         cv::Mat(1, &encoded_size, CV_8UC1,
         const_cast<char*>(encoded_image.data())),
-        caffe2::FLAGS_color ? CV_LOAD_IMAGE_COLOR : CV_LOAD_IMAGE_GRAYSCALE);
+        caffe2::FLAGS_color ? cv::IMREAD_COLOR : cv::IMREAD_GRAYSCALE);
     cv::Mat resized_img;
     int scaled_width, scaled_height;
     if (caffe2::FLAGS_warp) {
diff --git a/binaries/make_image_db.cc b/binaries/make_image_db.cc
index 196000308..c47b52d99 100644
--- a/binaries/make_image_db.cc
+++ b/binaries/make_image_db.cc
@@ -140,8 +140,8 @@ class Converter {
         // Load image
         cv::Mat img = cv::imread(
             input_folder + pair.first,
-            caffe2::FLAGS_color ? CV_LOAD_IMAGE_COLOR
-                                : CV_LOAD_IMAGE_GRAYSCALE);
+            caffe2::FLAGS_color ? cv::IMREAD_COLOR
+                                : cv::IMREAD_GRAYSCALE);
 
         // Resize image
         cv::Mat resized_img;
diff --git a/caffe2/contrib/cuda-convnet2/make-data/pyext/src/pyext.cpp b/caffe2/contrib/cuda-convnet2/make-data/pyext/src/pyext.cpp
index 0e3c0c772..720339287 100644
--- a/caffe2/contrib/cuda-convnet2/make-data/pyext/src/pyext.cpp
+++ b/caffe2/contrib/cuda-convnet2/make-data/pyext/src/pyext.cpp
@@ -93,7 +93,7 @@ void DecoderThread::makeJPEG(int idx) {
     size_t src_len = PyString_GET_SIZE(pySrc);
     vector<uchar> src_vec(src, src + src_len);
 
-    cv::Mat decoded_mat = cv::imdecode(cv::Mat(src_vec), CV_LOAD_IMAGE_COLOR);
+    cv::Mat decoded_mat = cv::imdecode(cv::Mat(src_vec), cv::IMREAD_COLOR);
     assert(decoded_mat.channels() == 3);
 
     /*
diff --git a/caffe2/image/image_input_op.h b/caffe2/image/image_input_op.h
index 2ce313758..9deb7ed2c 100644
--- a/caffe2/image/image_input_op.h
+++ b/caffe2/image/image_input_op.h
@@ -465,7 +465,7 @@ bool ImageInputOp<Context>::GetImageAndLabelAndInfoFromDBValue(
                 datum.data().size(),
                 CV_8UC1,
                 const_cast<char*>(datum.data().data())),
-            color_ ? CV_LOAD_IMAGE_COLOR : CV_LOAD_IMAGE_GRAYSCALE);
+            color_ ? cv::IMREAD_COLOR : cv::IMREAD_GRAYSCALE);
         if (src.rows == 0 or src.cols == 0) {
           num_decode_errors_in_batch_++;
           src = cv::Mat::zeros(cv::Size(224, 224), CV_8UC3);
@@ -540,7 +540,7 @@ bool ImageInputOp<Context>::GetImageAndLabelAndInfoFromDBValue(
                 &encoded_size,
                 CV_8UC1,
                 const_cast<char*>(encoded_image_str.data())),
-            color_ ? CV_LOAD_IMAGE_COLOR : CV_LOAD_IMAGE_GRAYSCALE);
+            color_ ? cv::IMREAD_COLOR : cv::IMREAD_GRAYSCALE);
         if (src.rows == 0 or src.cols == 0) {
           num_decode_errors_in_batch_++;
           src = cv::Mat::zeros(cv::Size(224, 224), CV_8UC3);
@@ -681,7 +681,7 @@ bool ImageInputOp<Context>::GetImageAndLabelAndInfoFromDBValue(
   if (out_c == src.channels()) {
     *img = src;
   } else {
-    cv::cvtColor(src, *img, (out_c == 1) ? CV_BGR2GRAY : CV_GRAY2BGR);
+    cv::cvtColor(src, *img, (out_c == 1) ? cv::COLOR_BGR2GRAY : cv::COLOR_GRAY2BGR);
   }
 
   // Note(Yangqing): I believe that the mat should be created continuous.
