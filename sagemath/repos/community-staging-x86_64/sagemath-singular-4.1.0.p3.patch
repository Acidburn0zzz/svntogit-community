diff --git a/src/sage/libs/singular/decl.pxd b/src/sage/libs/singular/decl.pxd
index 2dec5d8..676544a 100644
--- a/src/sage/libs/singular/decl.pxd
+++ b/src/sage/libs/singular/decl.pxd
@@ -534,6 +534,9 @@ cdef extern from "singular/Singular/libsingular.h":
 
     int rRing_has_Comp(ring *r)
 
+    int rHasGlobalOrdering(ring *r)
+    int rHasLocalOrMixedOrdering(ring *r)
+
     # return new empty monomial
 
     poly *p_Init(ring *r)
@@ -598,7 +601,7 @@ cdef extern from "singular/Singular/libsingular.h":
 
     # homogenizes p by multiplying certain powers of the varnum-th variable
 
-    poly *pHomogen (poly *p, int varnum)
+    poly *p_Homogen (poly *p, int varnum, ring *r)
 
     # return whether a polynomial is homogenous
 
@@ -710,7 +713,7 @@ cdef extern from "singular/Singular/libsingular.h":
 
     # inverse of poly, if possible
 
-    poly *pInvers(int n, poly *, intvec *)
+    poly *p_Series(int n, poly *, poly *, intvec *, ring *r)
 
     # gcd of f and g
 
@@ -766,6 +769,10 @@ cdef extern from "singular/Singular/libsingular.h":
     # Copy this number
     number *n_Copy(number *n, ring* r)
 
+    # Invert this number
+    int n_IsUnit(number *n, const n_Procs_s *cf)
+    number *n_Invers(number *n, const n_Procs_s *cf)
+
     # rational number from int
 
     number *nlInit(int)
diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index ffc6787..656acc9 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -186,12 +186,13 @@ from sage.libs.singular.decl cimport n_unknown,  n_Zp,  n_Q,   n_R,   n_GF,  n_l
 # singular functions
 from sage.libs.singular.decl cimport (
     errorreported,
+    n_IsUnit, n_Invers,
     p_ISet, rChangeCurrRing, p_Copy, p_Init, p_SetCoeff, p_Setm, p_SetExp, p_Add_q,
     p_NSet, p_GetCoeff, p_Delete, p_GetExp, pNext, rRingVar, omAlloc0, omStrDup,
     omFree, pDivide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
     pDivide, p_IsConstant, p_ExpVectorEqual, p_String, p_LmInit, n_Copy,
-    p_IsUnit, pInvers, p_Head, idInit, fast_map_common_subexp, id_Delete,
-    p_IsHomogeneous, pHomogen, p_Totaldegree,pLDeg1_Totaldegree, singclap_pdivide, singclap_factorize,
+    p_IsUnit, p_Series, p_Head, idInit, fast_map_common_subexp, id_Delete,
+    p_IsHomogeneous, p_Homogen, p_Totaldegree,pLDeg1_Totaldegree, singclap_pdivide, singclap_factorize,
     idLift, IDELEMS, On, Off, SW_USE_CHINREM_GCD, SW_USE_EZGCD,
     p_LmIsConstant, pTakeOutComp1, singclap_gcd, pp_Mult_qq, p_GetMaxExp,
     pLength, kNF, p_Neg, p_Minus_mm_Mult_qq, p_Plus_mm_Mult_qq,
@@ -1353,7 +1354,7 @@ cdef class MPolynomialRing_libsingular(MPolynomialRing_generic):
             sage: R = IntegerModRing(1024)['x,y']
             sage: singular(R)
             polynomial ring, over a ring (with zero-divisors), global ordering
-            //   coefficients: Z/2^10
+            //   coefficients: ZZ/(2^10)
             //   number of vars : 2
             //        block   1 : ordering dp
             //                  : names    x y
@@ -3112,11 +3113,11 @@ cdef class MPolynomial_libsingular(sage.rings.polynomial.multi_polynomial.MPolyn
         cdef ring *_ring = self._parent_ring
         if(_ring != currRing): rChangeCurrRing(_ring)
 
-        if not p_IsUnit(self._poly, _ring):
+        if not (p_IsUnit(self._poly,_ring)):
             raise ArithmeticError("Element is not a unit.")
 
         sig_on()
-        cdef MPolynomial_libsingular r = new_MP(self._parent, pInvers(0, self._poly, NULL))
+        cdef MPolynomial_libsingular r = new_MP(self._parent, p_NSet(n_Invers(p_GetCoeff(self._poly, _ring),_ring.cf),_ring))
         sig_off()
         return r
 
@@ -3171,14 +3172,17 @@ cdef class MPolynomial_libsingular(sage.rings.polynomial.multi_polynomial.MPolyn
 
         SEE: ``self.homogenize``
         """
+        cdef ring *_ring = self._parent_ring
         cdef MPolynomialRing_libsingular parent = self._parent
         cdef MPolynomial_libsingular f
 
         if self.is_homogeneous():
             return self
 
+        if(_ring != currRing): rChangeCurrRing(_ring)
+
         if var < parent._ring.N:
-            return new_MP(parent, pHomogen(p_Copy(self._poly, self._parent_ring), var+1))
+            return new_MP(parent, p_Homogen(self._poly, var+1, _ring))
         else:
             raise TypeError("var must be < self.parent().ngens()")
 
diff --git a/src/sage/rings/polynomial/polynomial_singular_interface.py b/src/sage/rings/polynomial/polynomial_singular_interface.py
index 1230a5e..1eb2566 100644
--- a/src/sage/rings/polynomial/polynomial_singular_interface.py
+++ b/src/sage/rings/polynomial/polynomial_singular_interface.py
@@ -154,7 +154,7 @@ class PolynomialRing_singular_repr:
             sage: R = IntegerModRing(1024)['x,y']
             sage: singular(R)
             polynomial ring, over a ring (with zero-divisors), global ordering
-            //   coefficients: Z/2^10
+            //   coefficients: ZZ/(2^10)
             //   number of vars : 2
             //        block   1 : ordering dp
             //                  : names    x y
