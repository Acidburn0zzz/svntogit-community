diff --git a/src/sage/misc/cachefunc.pyx b/src/sage/misc/cachefunc.pyx
index a9faca6..0c808dc 100644
--- a/src/sage/misc/cachefunc.pyx
+++ b/src/sage/misc/cachefunc.pyx
@@ -472,10 +472,17 @@ the parent as its first argument::
 #
 #                  http://www.gnu.org/licenses/
 ########################################################################
+from cpython cimport PyObject
+
+cdef extern from "methodobject.h":
+    cdef int METH_NOARGS, METH_O
+    cdef int PyCFunction_GetFlags(object op) except -1
+
 from function_mangling import ArgumentFixer
 import os
 from os.path import relpath,normpath,commonprefix
 from sage.misc.sageinspect import sage_getfile, sage_getsourcelines, sage_getargspec
+from inspect import isfunction
 
 import sage.misc.weak_dict
 from sage.misc.weak_dict import WeakValueDictionary
@@ -2678,18 +2685,22 @@ cdef class CachedMethod(object):
         # Since we have an optimized version for functions that do not accept arguments,
         # we need to analyse the argspec
         f = (<CachedFunction>self._cachedfunc).f
-        if self.nargs==0:
-            args, varargs, keywords, defaults = sage_getargspec(f)
-            if varargs is None and keywords is None and len(args)<=1:
-                self.nargs = 1
-                Caller = CachedMethodCallerNoArgs(inst, f, name=name)
-            else:
-                self.nargs = 2 # don't need the exact number
-                Caller = CachedMethodCaller(self, inst,
-                                            cache=self._get_instance_cache(inst),
-                                            name=name,
-                                            key=self._cachedfunc.key)
-        elif self.nargs==1:
+        if self.nargs == 0:
+            if isinstance(f, object) and not isfunction(f):
+                try:
+                    if METH_NOARGS&PyCFunction_GetFlags(f.__get__(inst,cls)):
+                        self.nargs = 1
+                    else:
+                        self.nargs = 2
+                except:
+                    pass
+            if self.nargs == 0:
+                args, varargs, keywords, defaults = sage_getargspec(f)
+                if varargs is None and keywords is None and len(args)<=1:
+                    self.nargs = 1
+                else:
+                    self.nargs = 2  # don't need the exact number
+        if self.nargs == 1:
             Caller = CachedMethodCallerNoArgs(inst, f, name=name)
         else:
             Caller = CachedMethodCaller(self, inst,
diff --git a/src/sage/misc/function_mangling.pyx b/src/sage/misc/function_mangling.pyx
index 97a3d0f..83ab48b 100644
--- a/src/sage/misc/function_mangling.pyx
+++ b/src/sage/misc/function_mangling.pyx
@@ -121,7 +121,21 @@ cdef class ArgumentFixer:
     cdef dict _defaults
     cdef public tuple _default_tuple
     def __init__(self, f, classmethod = False):
-        arg_names, varargs, varkw, defaults = sage_getargspec(f)
+        try:
+            arg_names, varargs, varkw, defaults = sage_getargspec(f)
+        except AttributeError:
+            # This error occurs if f is defined in a Cython file and the
+            # source file has gone.
+            if classmethod:
+                arg_names = ['self']
+                varargs = 'args'
+                varkws = 'kwds'
+                defaults = None
+            else:
+                arg_names = []
+                varargs = 'args'
+                varkws = 'kwds'
+                defaults = None
         if defaults is None:
             self._default_tuple = defaults = ()
         else:
diff --git a/src/sage/misc/nested_class.pyx b/src/sage/misc/nested_class.pyx
index ad45c09..e05930d 100644
--- a/src/sage/misc/nested_class.pyx
+++ b/src/sage/misc/nested_class.pyx
@@ -311,7 +311,24 @@ class MainClass(object):
                 sage: MainClass.NestedClass.NestedSubClass.__name__
                 'MainClass.NestedClass.NestedSubClass'
             """
-            pass
+            def dummy(self, x, *args, r=(1,2,3.4), **kwds):
+                """
+                A dummy method to demonstrate the embedding of
+                method signature for nested classes.
+
+                TESTS::
+
+                    sage: from sage.misc.nested_class import MainClass
+                    sage: print MainClass.NestedClass.NestedSubClass.dummy.__doc__
+                    NestedSubClass.dummy(self, x, *args, r=(1, 2, 3.4), **kwds)
+                    File: sage/misc/nested_class.pyx (starting at line 314)
+                    <BLANKLINE>
+                                    A dummy method to demonstrate the embedding of
+                                    method signature for nested classes.
+                    ...
+
+                """
+                pass
 
 class SubClass(MainClass):
     r"""
diff --git a/src/sage/misc/sageinspect.py b/src/sage/misc/sageinspect.py
index 889ec42..395bcc4 100644
--- a/src/sage/misc/sageinspect.py
+++ b/src/sage/misc/sageinspect.py
@@ -229,6 +229,48 @@ def _extract_embedded_position(docstring):
     original = res.group('ORIGINAL')
     return (original, filename, lineno)
 
+def _extract_embedded_signature(docstring, name):
+    r"""
+    If docstring starts with the embedded of a method called ``name``, return
+    a tuple (original_docstring, argspec).  If not, return (docstring, None).
+
+    See :trac:`17814`.
+
+    INPUT: ``docstring`` (string)
+
+    AUTHORS:
+
+    - Simon King
+
+    EXAMPLES::
+
+        sage: from sage.misc.sageinspect import _extract_embedded_signature
+        sage: from sage.misc.nested_class import MainClass
+        sage: print _extract_embedded_signature(MainClass.NestedClass.NestedSubClass.dummy.__doc__, 'dummy')[0]
+        File: sage/misc/nested_class.pyx (starting at line 314)
+        ...
+        sage: _extract_embedded_signature(MainClass.NestedClass.NestedSubClass.dummy.__doc__, 'dummy')[1]
+        ArgSpec(args=['self', 'x', 'r'], varargs='args', keywords='kwds', defaults=((1, 2, 3.4),))
+        sage: _extract_embedded_signature(range.__call__.__doc__, '__call__')
+        ('x.__call__(...) <==> x(...)', None)
+
+    """
+    # If there is an embedded signature, it is in the first line
+    L = docstring.split(os.linesep, 1)
+    firstline = L[0]
+    # It is possible that the signature is of the form ClassName.method_name,
+    # and thus we need to do the following:
+    if name not in firstline:
+        return docstring, None
+    signature = firstline.split(name, 1)[-1]
+    if signature.startswith("(") and signature.endswith(")"):
+        docstring = L[1] if len(L)>1 else '' # Remove first line, keep the rest
+        def_string = "def "+name+signature+": pass"
+        try:
+            return docstring, inspect.ArgSpec(*_sage_getargspec_cython(def_string))
+        except SyntaxError:
+            docstring = os.linesep.join(L)
+    return docstring, None
 
 class BlockFinder:
     """
@@ -1342,6 +1384,13 @@ def sage_getargspec(obj):
         sage: sage_getargspec(gap)
         ArgSpec(args=['self', 'x', 'name'], varargs=None, keywords=None, defaults=(None,))
 
+    By :trac:`17814`, the following gives the correct answer (previously, the
+    defaults would have been found ``None``)::
+
+        sage: from sage.misc.nested_class import MainClass
+        sage: sage_getargspec(MainClass.NestedClass.NestedSubClass.dummy)
+        ArgSpec(args=['self', 'x', 'r'], varargs='args', keywords='kwds', defaults=((1, 2, 3.4),))
+
 
     AUTHORS:
 
@@ -1352,6 +1401,8 @@ def sage_getargspec(obj):
     """
     from sage.misc.lazy_attribute import lazy_attribute
     from sage.misc.abstract_method import AbstractMethod
+    if inspect.isclass(obj):
+        return sage_getargspec(obj.__call__)
     if isinstance(obj, (lazy_attribute, AbstractMethod)):
         source = sage_getsource(obj)
         return inspect.ArgSpec(*_sage_getargspec_cython(source))
@@ -1361,7 +1412,14 @@ def sage_getargspec(obj):
         return inspect.ArgSpec(*obj._sage_argspec_())
     except (AttributeError, TypeError):
         pass
+    # If we are lucky, the function signature is embedded in the docstring.
+    docstring = _sage_getdoc_unformatted(obj)
+    name = obj.__name__ if hasattr(obj,'__name__') else type(obj).__name__
+    argspec = _extract_embedded_signature(docstring, name)[1]
+    if argspec is not None:
+        return argspec
     if hasattr(obj, 'func_code'):
+        # Note that this may give a wrong result for the constants!
         try:
             args, varargs, varkw = inspect.getargs(obj.func_code)
             return inspect.ArgSpec(args, varargs, varkw, obj.func_defaults)
@@ -1381,15 +1439,16 @@ def sage_getargspec(obj):
             base_spec = sage_getargspec(obj.func)
             return base_spec
         return sage_getargspec(obj.__class__.__call__)
-    elif inspect.isclass(obj):
-        return sage_getargspec(obj.__call__)
     elif (hasattr(obj, '__objclass__') and hasattr(obj, '__name__') and
           obj.__name__ == 'next'):
         # Handle sage.rings.ring.FiniteFieldIterator.next and similar
         # slot wrappers.  This is mainly to suppress Sphinx warnings.
         return ['self'], None, None, None
     else:
-        # Perhaps it is binary and defined in a Cython file
+        # We try to get the argspec by reading the source, which may be
+        # expensive, but should only be needed for functions defined outside
+        # of the Sage library (since otherwise the signature should be
+        # embedded in the docstring)
         source = sage_getsource(obj)
         if source:
             return inspect.ArgSpec(*_sage_getargspec_cython(source))
@@ -1405,7 +1464,6 @@ def sage_getargspec(obj):
         except TypeError: # arg is not a code object
         # The above "hopefully" was wishful thinking:
             return inspect.ArgSpec(*_sage_getargspec_cython(sage_getsource(obj)))
-            #return _sage_getargspec_from_ast(sage_getsource(obj))
     try:
         defaults = func_obj.__defaults__
     except AttributeError:
@@ -1607,23 +1665,10 @@ def sage_getdoc_original(obj):
     else:
         typ = type(obj)
 
-    s = _sage_getdoc_unformatted(obj)
+    s,argspec = _extract_embedded_signature(_sage_getdoc_unformatted(obj), typ.__name__)
     if s:
         pos = _extract_embedded_position(s)
-        if pos is None:
-            # It can still be that the doc starts with the signature of the
-            # class' __init__ method, but does not contain embedding
-            # information. This is particularly critical if it contains * or
-            # **, which would be misinterpreted by sphinx.
-            name = typ.__name__.split('.')[-1]
-            if s.startswith(name + "("):
-                L = s.split(os.linesep, 1)
-                if L[0].endswith(")"):
-                    if len(L) < 2:
-                        s = ""    # The doc was just one line with the signature
-                    else:
-                        s = L[1]  # Remove first line, keep the rest
-        else:
+        if pos is not None:
             s = pos[0]
     if not s:
         try:

