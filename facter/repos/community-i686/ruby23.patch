diff -uprb facter-3.1.3.orig/lib/src/ruby/aggregate_resolution.cc facter-3.1.3/lib/src/ruby/aggregate_resolution.cc
--- facter-3.1.3.orig/lib/src/ruby/aggregate_resolution.cc	2015-11-25 02:13:58.000000000 +0200
+++ facter-3.1.3/lib/src/ruby/aggregate_resolution.cc	2015-12-29 02:03:30.735361627 +0200
@@ -138,7 +138,7 @@ namespace facter { namespace ruby {
 
         // Create a resolution and wrap with a Ruby data object
         unique_ptr<aggregate_resolution> r(new aggregate_resolution());
-        VALUE self = r->_self = ruby.rb_data_object_alloc(klass, r.get(), mark, free);
+        VALUE self = r->_self = ruby.rb_data_object_wrap(klass, r.get(), mark, free);
         ruby.register_data_object(self);
 
         // Release the smart pointer; ownership is now with Ruby's GC
diff -uprb facter-3.1.3.orig/lib/src/ruby/fact.cc facter-3.1.3/lib/src/ruby/fact.cc
--- facter-3.1.3.orig/lib/src/ruby/fact.cc	2015-11-25 02:13:58.000000000 +0200
+++ facter-3.1.3/lib/src/ruby/fact.cc	2015-12-29 02:03:30.738695043 +0200
@@ -285,7 +285,7 @@ namespace facter { namespace ruby {
 
         // Create a fact and wrap with a Ruby data object
         unique_ptr<fact> f(new fact());
-        VALUE self = f->_self = ruby.rb_data_object_alloc(klass, f.get(), mark, free);
+        VALUE self = f->_self = ruby.rb_data_object_wrap(klass, f.get(), mark, free);
         ruby.register_data_object(self);
 
         // Release the smart pointer; ownership is now with Ruby's GC
diff -uprb facter-3.1.3.orig/lib/src/ruby/module.cc facter-3.1.3/lib/src/ruby/module.cc
--- facter-3.1.3.orig/lib/src/ruby/module.cc	2015-11-25 02:13:58.000000000 +0200
+++ facter-3.1.3/lib/src/ruby/module.cc	2015-12-29 02:03:30.738695043 +0200
@@ -50,7 +50,7 @@ namespace facter { namespace ruby {
             // The easiest way to get notified is to have a global data object that never gets collected
             // until the VM shuts down
             auto const& ruby = api::instance();
-            _canary = ruby.rb_data_object_alloc(*ruby.rb_cObject, this, nullptr, cleanup);
+            _canary = ruby.rb_data_object_wrap(*ruby.rb_cObject, this, nullptr, cleanup);
             ruby.rb_gc_register_address(&_canary);
             ruby.register_data_object(_canary);
         }
diff -uprb facter-3.1.3.orig/lib/src/ruby/simple_resolution.cc facter-3.1.3/lib/src/ruby/simple_resolution.cc
--- facter-3.1.3.orig/lib/src/ruby/simple_resolution.cc	2015-11-25 02:13:58.000000000 +0200
+++ facter-3.1.3/lib/src/ruby/simple_resolution.cc	2015-12-29 02:03:30.738695043 +0200
@@ -74,7 +74,7 @@ namespace facter { namespace ruby {
 
         // Create a resolution and wrap with a Ruby data object
         unique_ptr<simple_resolution> r(new simple_resolution());
-        VALUE self = r->_self = ruby.rb_data_object_alloc(klass, r.get(), mark, free);
+        VALUE self = r->_self = ruby.rb_data_object_wrap(klass, r.get(), mark, free);
         ruby.register_data_object(self);
 
         // Release the smart pointer; ownership is now with Ruby's GC
diff -uprb facter-3.1.3.orig/vendor/leatherman/ruby/inc/leatherman/ruby/api.hpp facter-3.1.3/vendor/leatherman/ruby/inc/leatherman/ruby/api.hpp
--- facter-3.1.3.orig/vendor/leatherman/ruby/inc/leatherman/ruby/api.hpp	2015-11-25 02:14:00.000000000 +0200
+++ facter-3.1.3/vendor/leatherman/ruby/inc/leatherman/ruby/api.hpp	2015-12-29 02:03:30.738695043 +0200
@@ -341,7 +341,7 @@ namespace leatherman {  namespace ruby {
         /**
          * See MRI documentation.
          */
-        VALUE (* const rb_data_object_alloc)(VALUE, void*, RUBY_DATA_FUNC, RUBY_DATA_FUNC);
+        VALUE (* const rb_data_object_wrap)(VALUE, void*, RUBY_DATA_FUNC, RUBY_DATA_FUNC);
         /**
          * See MRI documentation.
          */
@@ -621,7 +621,7 @@ namespace leatherman {  namespace ruby {
 
         /**
          * Gets the underlying native instance from a Ruby data object.
-         * The Ruby object must have been allocated with rb_data_object_alloc.
+         * The Ruby object must have been allocated with rb_data_object_wrap.
          * @tparam T The underlying native type.
          * @param obj The Ruby data object to get the native instance for.
          * @return Returns a pointer to the underlying native type.
@@ -634,7 +634,7 @@ namespace leatherman {  namespace ruby {
 
         /**
          * Registers a data object for cleanup when the API is destructed.
-         * The object must have been created with rb_data_object_alloc.
+         * The object must have been created with rb_data_object_wrap.
          * @param obj The data object to register.
          */
         void register_data_object(VALUE obj) const
diff -uprb facter-3.1.3.orig/vendor/leatherman/ruby/src/api.cc facter-3.1.3/vendor/leatherman/ruby/src/api.cc
--- facter-3.1.3.orig/vendor/leatherman/ruby/src/api.cc	2015-11-25 02:14:00.000000000 +0200
+++ facter-3.1.3/vendor/leatherman/ruby/src/api.cc	2015-12-29 02:03:30.738695043 +0200
@@ -80,7 +80,7 @@ namespace leatherman { namespace ruby {
         LOAD_SYMBOL(rb_to_id),
         LOAD_SYMBOL(rb_id2name),
         LOAD_SYMBOL(rb_define_alloc_func),
-        LOAD_SYMBOL(rb_data_object_alloc),
+        LOAD_SYMBOL(rb_data_object_wrap),
         LOAD_SYMBOL(rb_gc_mark),
         LOAD_SYMBOL(rb_yield_values),
         LOAD_SYMBOL(rb_require),
