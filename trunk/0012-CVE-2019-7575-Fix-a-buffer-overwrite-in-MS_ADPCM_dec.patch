From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
Date: Thu, 14 Feb 2019 14:51:52 +0100
Subject: [PATCH] CVE-2019-7575: Fix a buffer overwrite in MS_ADPCM_decode
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If a WAV format defines shorter audio stream and decoded MS ADPCM data chunk
is longer, decoding continued past the output audio buffer.

This fix is based on a patch from
<https://bugzilla.libsdl.org/show_bug.cgi?id=4492>.

https://bugzilla.libsdl.org/show_bug.cgi?id=4493
CVE-2019-7575

Signed-off-by: Petr Písař <ppisar@redhat.com>
---
 src/audio/SDL_wave.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/audio/SDL_wave.c b/src/audio/SDL_wave.c
index e42d01c9..b6c49dee 100644
--- a/src/audio/SDL_wave.c
+++ b/src/audio/SDL_wave.c
@@ -115,106 +115,109 @@ static Sint32 MS_ADPCM_nibble(struct MS_ADPCM_decodestate *state,
 static int MS_ADPCM_decode(Uint8 **audio_buf, Uint32 *audio_len)
 {
 	struct MS_ADPCM_decodestate *state[2];
-	Uint8 *freeable, *encoded, *encoded_end, *decoded;
+	Uint8 *freeable, *encoded, *encoded_end, *decoded, *decoded_end;
 	Sint32 encoded_len, samplesleft;
 	Sint8 nybble, stereo;
 	Sint16 *coeff[2];
 	Sint32 new_sample;
 
 	/* Allocate the proper sized output buffer */
 	encoded_len = *audio_len;
 	encoded = *audio_buf;
 	encoded_end = encoded + encoded_len;
 	freeable = *audio_buf;
 	*audio_len = (encoded_len/MS_ADPCM_state.wavefmt.blockalign) * 
 				MS_ADPCM_state.wSamplesPerBlock*
 				MS_ADPCM_state.wavefmt.channels*sizeof(Sint16);
 	*audio_buf = (Uint8 *)SDL_malloc(*audio_len);
 	if ( *audio_buf == NULL ) {
 		SDL_Error(SDL_ENOMEM);
 		return(-1);
 	}
 	decoded = *audio_buf;
+	decoded_end = decoded + *audio_len;
 
 	/* Get ready... Go! */
 	stereo = (MS_ADPCM_state.wavefmt.channels == 2);
 	state[0] = &MS_ADPCM_state.state[0];
 	state[1] = &MS_ADPCM_state.state[stereo];
 	while ( encoded_len >= MS_ADPCM_state.wavefmt.blockalign ) {
 		/* Grab the initial information for this block */
-		if (encoded + 7 + (stereo ? 7 : 0) > encoded_end) goto too_short;
+		if (encoded + 7 + (stereo ? 7 : 0) > encoded_end) goto invalid_size;
 		state[0]->hPredictor = *encoded++;
 		if ( stereo ) {
 			state[1]->hPredictor = *encoded++;
 		}
 		state[0]->iDelta = ((encoded[1]<<8)|encoded[0]);
 		encoded += sizeof(Sint16);
 		if ( stereo ) {
 			state[1]->iDelta = ((encoded[1]<<8)|encoded[0]);
 			encoded += sizeof(Sint16);
 		}
 		state[0]->iSamp1 = ((encoded[1]<<8)|encoded[0]);
 		encoded += sizeof(Sint16);
 		if ( stereo ) {
 			state[1]->iSamp1 = ((encoded[1]<<8)|encoded[0]);
 			encoded += sizeof(Sint16);
 		}
 		state[0]->iSamp2 = ((encoded[1]<<8)|encoded[0]);
 		encoded += sizeof(Sint16);
 		if ( stereo ) {
 			state[1]->iSamp2 = ((encoded[1]<<8)|encoded[0]);
 			encoded += sizeof(Sint16);
 		}
 		coeff[0] = MS_ADPCM_state.aCoeff[state[0]->hPredictor];
 		coeff[1] = MS_ADPCM_state.aCoeff[state[1]->hPredictor];
 
 		/* Store the two initial samples we start with */
+		if (decoded + 4 + (stereo ? 4 : 0) > decoded_end) goto invalid_size;
 		decoded[0] = state[0]->iSamp2&0xFF;
 		decoded[1] = state[0]->iSamp2>>8;
 		decoded += 2;
 		if ( stereo ) {
 			decoded[0] = state[1]->iSamp2&0xFF;
 			decoded[1] = state[1]->iSamp2>>8;
 			decoded += 2;
 		}
 		decoded[0] = state[0]->iSamp1&0xFF;
 		decoded[1] = state[0]->iSamp1>>8;
 		decoded += 2;
 		if ( stereo ) {
 			decoded[0] = state[1]->iSamp1&0xFF;
 			decoded[1] = state[1]->iSamp1>>8;
 			decoded += 2;
 		}
 
 		/* Decode and store the other samples in this block */
 		samplesleft = (MS_ADPCM_state.wSamplesPerBlock-2)*
 					MS_ADPCM_state.wavefmt.channels;
 		while ( samplesleft > 0 ) {
-			if (encoded + 1 > encoded_end) goto too_short;
+			if (encoded + 1 > encoded_end) goto invalid_size;
+			if (decoded + 4 > decoded_end) goto invalid_size;
 
 			nybble = (*encoded)>>4;
 			new_sample = MS_ADPCM_nibble(state[0],nybble,coeff[0]);
 			decoded[0] = new_sample&0xFF;
 			new_sample >>= 8;
 			decoded[1] = new_sample&0xFF;
 			decoded += 2;
 
 			nybble = (*encoded)&0x0F;
 			new_sample = MS_ADPCM_nibble(state[1],nybble,coeff[1]);
 			decoded[0] = new_sample&0xFF;
 			new_sample >>= 8;
 			decoded[1] = new_sample&0xFF;
 			decoded += 2;
 
 			++encoded;
 			samplesleft -= 2;
 		}
 		encoded_len -= MS_ADPCM_state.wavefmt.blockalign;
 	}
 	SDL_free(freeable);
 	return(0);
-too_short:
-	SDL_SetError("Too short chunk for a MS ADPCM decoder");
+invalid_size:
+	SDL_SetError("Unexpected chunk length for a MS ADPCM decoder");
 	SDL_free(freeable);
 	return(-1);
 }
