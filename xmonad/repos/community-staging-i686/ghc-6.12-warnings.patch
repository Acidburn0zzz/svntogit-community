Mon Jan 18 19:15:32 CET 2010  Adam Vogt <vogt.adam@gmail.com>
  * Correct warnings with ghc-6.12
  
  Changes include:
    - compatibility with base-4 or 3 (base-2 untested) by using
      extensible-exceptions. This adds an additional dependency for users of
      ghc<6.10)
    - list all dependencies again when -ftesting (change in Cabal-1.8.0.2)
    - remove unnecessary imports
    - suppress -fwarn-unused-do-bind, with appropriate Cabal-1.8 workaround,
      described here:
      http://www.haskell.org/pipermail/xmonad/2010-January/009554.html
diff -rN -u old-xmonad/Main.hs new-xmonad/Main.hs
--- old-xmonad/Main.hs	2010-12-11 22:16:21.689141971 +0100
+++ new-xmonad/Main.hs	2010-12-11 22:16:21.705809756 +0100
@@ -17,7 +17,6 @@
 import XMonad
 
 import Control.Monad (unless)
-import System.IO
 import System.Info
 import System.Environment
 import System.Posix.Process (executeFile)
diff -rN -u old-xmonad/tests/Properties.hs new-xmonad/tests/Properties.hs
--- old-xmonad/tests/Properties.hs	2010-12-11 22:16:21.685808414 +0100
+++ new-xmonad/tests/Properties.hs	2010-12-11 22:16:21.695809085 +0100
@@ -14,7 +14,7 @@
 import Data.Maybe
 import System.Environment
 import Control.Exception    (assert)
-import qualified Control.Exception as C
+import qualified Control.Exception.Extensible as C
 import Control.Monad
 import Test.QuickCheck hiding (promote)
 import System.IO.Unsafe
@@ -613,13 +613,13 @@
 
 -- and help out hpc
 prop_abort x = unsafePerformIO $ C.catch (abort "fail")
-                                         (\e -> return $  show e == "xmonad: StackSet: fail" )
+                                         (\(C.SomeException e) -> return $  show e == "xmonad: StackSet: fail" )
    where
      _ = x :: Int
 
 -- new should fail with an abort
 prop_new_abort x = unsafePerformIO $ C.catch f
-                                         (\e -> return $ show e == "xmonad: StackSet: non-positive argument to StackSet.new" )
+                                         (\(C.SomeException e) -> return $ show e == "xmonad: StackSet: non-positive argument to StackSet.new" )
    where
      f = new undefined{-layout-} [] [] `seq` return False
 
diff -rN -u old-xmonad/XMonad/Core.hs new-xmonad/XMonad/Core.hs
--- old-xmonad/XMonad/Core.hs	2010-12-11 22:16:21.689141971 +0100
+++ new-xmonad/XMonad/Core.hs	2010-12-11 22:16:21.705809756 +0100
@@ -34,7 +34,7 @@
 import XMonad.StackSet hiding (modify)
 
 import Prelude hiding ( catch )
-import Control.Exception (catch, try, bracket, throw, finally, Exception(ExitException))
+import Control.Exception.Extensible (catch, fromException, try, bracket, throw, finally, SomeException(..))
 import Control.Applicative
 import Control.Monad.State
 import Control.Monad.Reader
@@ -171,9 +171,9 @@
 catchX job errcase = do
     st <- get
     c <- ask
-    (a, s') <- io $ runX c st job `catch` \e -> case e of
-                            ExitException {} -> throw e
-                            _ -> do hPrint stderr e; runX c st errcase
+    (a, s') <- io $ runX c st job `catch` \e -> case fromException e of
+                        Just x -> throw e `const` (x `asTypeOf` ExitSuccess)
+                        _ -> do hPrint stderr e; runX c st errcase
     put s'
     return a
 
@@ -386,7 +386,7 @@
 -- | Lift an 'IO' action into the 'X' monad.  If the action results in an 'IO'
 -- exception, log the exception to stderr and continue normal execution.
 catchIO :: MonadIO m => IO () -> m ()
-catchIO f = io (f `catch` \e -> hPrint stderr e >> hFlush stderr)
+catchIO f = io (f `catch` \(SomeException e) -> hPrint stderr e >> hFlush stderr)
 
 -- | spawn. Launch an external application. Specifically, it double-forks and
 -- runs the 'String' you pass as a command to /bin/sh.
@@ -476,11 +476,11 @@
             return ()
         return (status == ExitSuccess)
       else return True
- where getModTime f = catch (Just <$> getModificationTime f) (const $ return Nothing)
+ where getModTime f = catch (Just <$> getModificationTime f) (\(SomeException _) -> return Nothing)
        isSource = flip elem [".hs",".lhs",".hsc"]
        allFiles t = do
             let prep = map (t</>) . Prelude.filter (`notElem` [".",".."])
-            cs <- prep <$> catch (getDirectoryContents t) (\_ -> return [])
+            cs <- prep <$> catch (getDirectoryContents t) (\(SomeException _) -> return [])
             ds <- filterM doesDirectoryExist cs
             concat . ((cs \\ ds):) <$> mapM allFiles ds
 
@@ -503,7 +503,8 @@
 installSignalHandlers = io $ do
     installHandler openEndedPipe Ignore Nothing
     installHandler sigCHLD Ignore Nothing
-    try $ fix $ \more -> do
+    (try :: IO a -> IO (Either SomeException a))
+      $ fix $ \more -> do
         x <- getAnyProcessStatus False False
         when (isJust x) more
     return ()
diff -rN -u old-xmonad/XMonad/ManageHook.hs new-xmonad/XMonad/ManageHook.hs
--- old-xmonad/XMonad/ManageHook.hs	2010-12-11 22:16:21.689141971 +0100
+++ new-xmonad/XMonad/ManageHook.hs	2010-12-11 22:16:21.705809756 +0100
@@ -22,7 +22,7 @@
 import XMonad.Core
 import Graphics.X11.Xlib.Extras
 import Graphics.X11.Xlib (Display, Window, internAtom, wM_NAME)
-import Control.Exception (bracket, catch)
+import Control.Exception (bracket, catch, SomeException(..))
 import Control.Monad.Reader
 import Data.Maybe
 import Data.Monoid
@@ -72,10 +72,10 @@
     let
         getProp =
             (internAtom d "_NET_WM_NAME" False >>= getTextProperty d w)
-                `catch` \_ -> getTextProperty d w wM_NAME
+                `catch` \(SomeException _) -> getTextProperty d w wM_NAME
         extract prop = do l <- wcTextPropertyToTextList d prop
                           return $ if null l then "" else head l
-    io $ bracket getProp (xFree . tp_value) extract `catch` \_ -> return ""
+    io $ bracket getProp (xFree . tp_value) extract `catch` \(SomeException _) -> return ""
 
 -- | Return the application name.
 appName :: Query String
diff -rN -u old-xmonad/XMonad/Operations.hs new-xmonad/XMonad/Operations.hs
--- old-xmonad/XMonad/Operations.hs	2010-12-11 22:16:21.689141971 +0100
+++ new-xmonad/XMonad/Operations.hs	2010-12-11 22:16:21.705809756 +0100
@@ -33,9 +33,8 @@
 import Control.Applicative
 import Control.Monad.Reader
 import Control.Monad.State
-import qualified Control.Exception as C
+import qualified Control.Exception.Extensible as C
 
-import System.IO
 import System.Posix.Process (executeFile)
 import Graphics.X11.Xlib
 import Graphics.X11.Xinerama (getScreenInfo)
@@ -400,7 +399,7 @@
 
 -- | Get the 'Pixel' value for a named color
 initColor :: Display -> String -> IO (Maybe Pixel)
-initColor dpy c = C.handle (\_ -> return Nothing) $
+initColor dpy c = C.handle (\(C.SomeException _) -> return Nothing) $
     (Just . color_pixel . fst) <$> allocNamedColor dpy colormap c
     where colormap = defaultColormap dpy (defaultScreen dpy)
 
diff -rN -u old-xmonad/xmonad.cabal new-xmonad/xmonad.cabal
--- old-xmonad/xmonad.cabal	2010-12-11 22:16:21.685808414 +0100
+++ new-xmonad/xmonad.cabal	2010-12-11 22:16:21.699142642 +0100
@@ -43,12 +43,17 @@
                         XMonad.StackSet
 
     if flag(small_base)
-        build-depends: base < 4 && >=3, containers, directory, process, filepath
+        build-depends: base < 5 && >=3, containers, directory, process, filepath, extensible-exceptions
     else
         build-depends: base < 3
     build-depends: X11>=1.5.0.0 && < 1.6, mtl, unix
 
-    ghc-options:        -funbox-strict-fields -Wall
+    if true
+        ghc-options:        -funbox-strict-fields -Wall
+
+    if impl(ghc >= 6.12.1)
+        ghc-options:        -fno-warn-unused-do-bind
+
     ghc-prof-options:   -prof -auto-all
     extensions:         CPP
 
@@ -66,7 +71,12 @@
                         XMonad.Operations
                         XMonad.StackSet
 
-    ghc-options:        -funbox-strict-fields -Wall
+    if true 
+        ghc-options:    -funbox-strict-fields -Wall
+
+    if impl(ghc >= 6.12.1)
+        ghc-options:    -fno-warn-unused-do-bind
+
     ghc-prof-options:   -prof -auto-all
     extensions:         CPP
 
@@ -76,4 +86,4 @@
         build-depends:  QuickCheck < 2
         ghc-options:    -Werror
     if flag(testing) && flag(small_base)
-        build-depends:  random
+        build-depends:  filepath, process, directory, mtl, unix, X11, base, containers, random, extensible-exceptions
