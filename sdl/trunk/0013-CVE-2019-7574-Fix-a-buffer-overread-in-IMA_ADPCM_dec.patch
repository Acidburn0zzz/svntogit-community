From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
Date: Thu, 14 Feb 2019 15:41:47 +0100
Subject: [PATCH] CVE-2019-7574: Fix a buffer overread in IMA_ADPCM_decode
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If data chunk was shorter than expected based on a WAV format
definition, IMA_ADPCM_decode() tried to read past the data chunk
buffer. This patch fixes it.

CVE-2019-7574
https://bugzilla.libsdl.org/show_bug.cgi?id=4496

Signed-off-by: Petr Písař <ppisar@redhat.com>
---
 src/audio/SDL_wave.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/audio/SDL_wave.c b/src/audio/SDL_wave.c
index b6c49dee..2968b3d1 100644
--- a/src/audio/SDL_wave.c
+++ b/src/audio/SDL_wave.c
@@ -334,70 +334,77 @@ static void Fill_IMA_ADPCM_block(Uint8 *decoded, Uint8 *encoded,
 static int IMA_ADPCM_decode(Uint8 **audio_buf, Uint32 *audio_len)
 {
 	struct IMA_ADPCM_decodestate *state;
-	Uint8 *freeable, *encoded, *decoded;
+	Uint8 *freeable, *encoded, *encoded_end, *decoded;
 	Sint32 encoded_len, samplesleft;
 	unsigned int c, channels;
 
 	/* Check to make sure we have enough variables in the state array */
 	channels = IMA_ADPCM_state.wavefmt.channels;
 	if ( channels > SDL_arraysize(IMA_ADPCM_state.state) ) {
 		SDL_SetError("IMA ADPCM decoder can only handle %d channels",
 					SDL_arraysize(IMA_ADPCM_state.state));
 		return(-1);
 	}
 	state = IMA_ADPCM_state.state;
 
 	/* Allocate the proper sized output buffer */
 	encoded_len = *audio_len;
 	encoded = *audio_buf;
+	encoded_end = encoded + encoded_len;
 	freeable = *audio_buf;
 	*audio_len = (encoded_len/IMA_ADPCM_state.wavefmt.blockalign) * 
 				IMA_ADPCM_state.wSamplesPerBlock*
 				IMA_ADPCM_state.wavefmt.channels*sizeof(Sint16);
 	*audio_buf = (Uint8 *)SDL_malloc(*audio_len);
 	if ( *audio_buf == NULL ) {
 		SDL_Error(SDL_ENOMEM);
 		return(-1);
 	}
 	decoded = *audio_buf;
 
 	/* Get ready... Go! */
 	while ( encoded_len >= IMA_ADPCM_state.wavefmt.blockalign ) {
 		/* Grab the initial information for this block */
 		for ( c=0; c<channels; ++c ) {
+			if (encoded + 4 > encoded_end) goto invalid_size;
 			/* Fill the state information for this block */
 			state[c].sample = ((encoded[1]<<8)|encoded[0]);
 			encoded += 2;
 			if ( state[c].sample & 0x8000 ) {
 				state[c].sample -= 0x10000;
 			}
 			state[c].index = *encoded++;
 			/* Reserved byte in buffer header, should be 0 */
 			if ( *encoded++ != 0 ) {
 				/* Uh oh, corrupt data?  Buggy code? */;
 			}
 
 			/* Store the initial sample we start with */
 			decoded[0] = (Uint8)(state[c].sample&0xFF);
 			decoded[1] = (Uint8)(state[c].sample>>8);
 			decoded += 2;
 		}
 
 		/* Decode and store the other samples in this block */
 		samplesleft = (IMA_ADPCM_state.wSamplesPerBlock-1)*channels;
 		while ( samplesleft > 0 ) {
 			for ( c=0; c<channels; ++c ) {
+				if (encoded + 4 > encoded_end) goto invalid_size;
 				Fill_IMA_ADPCM_block(decoded, encoded,
 						c, channels, &state[c]);
 				encoded += 4;
 				samplesleft -= 8;
 			}
 			decoded += (channels * 8 * 2);
 		}
 		encoded_len -= IMA_ADPCM_state.wavefmt.blockalign;
 	}
 	SDL_free(freeable);
 	return(0);
+invalid_size:
+	SDL_SetError("Unexpected chunk length for an IMA ADPCM decoder");
+	SDL_free(freeable);
+	return(-1);
 }
 
 SDL_AudioSpec * SDL_LoadWAV_RW (SDL_RWops *src, int freesrc,
