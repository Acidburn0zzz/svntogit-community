From e9e0a68a7eb72da7dfa181375e6ec891be89d662 Mon Sep 17 00:00:00 2001
From: electricface <songwentai@deepin.com>
Date: Sat, 29 Dec 2018 09:42:54 +0800
Subject: [PATCH] fix(dbus): failed to find session bus address in systemd 240+

Change-Id: I401cf471ad396003b950fc9fc038bbee0b60bc6c
---

diff --git a/dbus/conn.go b/dbus/conn.go
index 20f65b1..41bb6e5 100644
--- a/dbus/conn.go
+++ b/dbus/conn.go
@@ -110,14 +110,25 @@
 	return
 }
 
+func getSessionBusAddress() (string, error) {
+	if address := os.Getenv("DBUS_SESSION_BUS_ADDRESS"); address != "" && address != "autolaunch:" {
+		return address, nil
+
+	} else if address := tryDiscoverDbusSessionBusAddress(); address != "" {
+		os.Setenv("DBUS_SESSION_BUS_ADDRESS", address)
+		return address, nil
+	}
+	return getSessionBusPlatformAddress()
+}
+
 // SessionBusPrivate returns a new private connection to the session bus.
 func SessionBusPrivate() (*Conn, error) {
-	address := os.Getenv("DBUS_SESSION_BUS_ADDRESS")
-	if address != "" && address != "autolaunch:" {
-		return Dial(address)
+	address, err := getSessionBusAddress()
+	if err != nil {
+		return nil, err
 	}
 
-	return sessionBusPlatform()
+	return Dial(address)
 }
 
 // SystemBus returns a shared connection to the system bus, connecting to it if
diff --git a/dbus/conn_other.go b/dbus/conn_other.go
index 293d8cb..d8d1adf 100644
--- a/dbus/conn_other.go
+++ b/dbus/conn_other.go
@@ -24,23 +24,87 @@
 import (
 	"bytes"
 	"errors"
+	"fmt"
+	"io/ioutil"
+	"os"
 	"os/exec"
+	"os/user"
+	"path"
+	"strings"
 )
 
-func sessionBusPlatform() (*Conn, error) {
-	cmd := exec.Command("/usr/bin/dbus-launch")
+func getSessionBusPlatformAddress() (string, error) {
+	cmd := exec.Command("dbus-launch")
 	b, err := cmd.CombinedOutput()
 
 	if err != nil {
-		return nil, err
+		return "", err
 	}
 
 	i := bytes.IndexByte(b, '=')
 	j := bytes.IndexByte(b, '\n')
 
 	if i == -1 || j == -1 {
-		return nil, errors.New("dbus: couldn't determine address of session bus")
+		return "", errors.New("dbus: couldn't determine address of session bus")
 	}
 
-	return Dial(string(b[i+1 : j]))
+	env, addr := string(b[0:i]), string(b[i+1:j])
+	os.Setenv(env, addr)
+
+	return addr, nil
+}
+
+// tryDiscoverDbusSessionBusAddress tries to discover an existing dbus session
+// and return the value of its DBUS_SESSION_BUS_ADDRESS.
+// It tries different techniques employed by different operating systems,
+// returning the first valid address it finds, or an empty string.
+//
+// * /run/user/<uid>/bus           if this exists, it *is* the bus socket. present on
+//                                 Ubuntu 18.04
+// * /run/user/<uid>/dbus-session: if this exists, it can be parsed for the bus
+//                                 address. present on Ubuntu 16.04
+//
+// See https://dbus.freedesktop.org/doc/dbus-launch.1.html
+func tryDiscoverDbusSessionBusAddress() string {
+	if runtimeDirectory, err := getRuntimeDirectory(); err == nil {
+
+		if runUserBusFile := path.Join(runtimeDirectory, "bus"); fileExists(runUserBusFile) {
+			// if /run/user/<uid>/bus exists, that file itself
+			// *is* the unix socket, so return its path
+			return fmt.Sprintf("unix:path=%s", runUserBusFile)
+		}
+		if runUserSessionDbusFile := path.Join(runtimeDirectory, "dbus-session"); fileExists(runUserSessionDbusFile) {
+			// if /run/user/<uid>/dbus-session exists, it's a
+			// text file // containing the address of the socket, e.g.:
+			// DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-E1c73yNqrG
+
+			if f, err := ioutil.ReadFile(runUserSessionDbusFile); err == nil {
+				fileContent := string(f)
+
+				prefix := "DBUS_SESSION_BUS_ADDRESS="
+
+				if strings.HasPrefix(fileContent, prefix) {
+					address := strings.TrimRight(strings.TrimPrefix(fileContent, prefix), "\n\r")
+					return address
+				}
+			}
+		}
+	}
+	return ""
+}
+
+func getRuntimeDirectory() (string, error) {
+	if currentUser, err := user.Current(); err != nil {
+		return "", err
+	} else {
+		return fmt.Sprintf("/run/user/%s", currentUser.Uid), nil
+	}
+}
+
+func fileExists(filename string) bool {
+	if _, err := os.Stat(filename); !os.IsNotExist(err) {
+		return true
+	} else {
+		return false
+	}
 }
